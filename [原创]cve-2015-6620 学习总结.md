> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-226699.htm)

cve-2015-6620 学习总结
==================

前言
--

想学习下 android 漏洞方面的知识，搜了下发现 Flanker Edward 在知乎上有个回答，提到了 binder 的经典漏洞 cve-2015-6620，所以就从这个漏洞开始学习。作者提供了 poc 以及文档，这篇笔记主要记录下学习中遇到的问题，以及自己的一些理解。

环境搭建与基础知识
---------

第一次调试 android 漏洞，搭建环境花了些力气，主要有如下环境，推荐安装 pead-arm 和 shadow 这两个 gdb 插件。

1.  android 源码环境：Ubuntu16.04 android_6.0.0_r1
2.  gdb 调试环境搭建
3.  [peda-arm](https://github.com/alset0326/peda-arm) 安装，调试界面更加方便
4.  [shadow](https://github.com/CENSUS/shadow) 安装，方便调试 jemalloc

这是 android 平台上的 binder 方面的漏洞，所以涉及一些 android 底层的知识需要学习下。

1.  binder
2.  智能指针

漏洞成因
----

cve-2015-6620 包含两个漏洞，编号分别为 24123723 和 24445127。主要分析的是 24445127 MediaCodecInfo 越界访问，因为这个漏洞可以利用的点更多些。漏洞存在于 MediaCodcList 服务。该 Binder 服务提供了一个 getCodecInfo 的功能, 存在漏洞的代码如下：

```
//http://androidxref.com/6.0.0_r1/xref/frameworks/av/media/libmedia/IMediaCodecList.cpp#54
status_t BnMediaCodecList::onTransact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
    switch (code) {
 
        case GET_CODEC_INFO:
        {
            CHECK_INTERFACE(IMediaCodecList, data, reply);
            size_t index = static_cast(data.readInt32());
            const sp info = getCodecInfo(index); //调用服务端的实现
            if (info != NULL) {
                reply->writeInt32(OK);
                info->writeToParcel(reply);
            } else {
                reply->writeInt32(-ERANGE);
            }
            return NO_ERROR;
        }
        break; 
```

从 Parce 中读取从客户端传来的索引 index，然后调用在服务端的实现的 getCodecInfo。看下在 MediaCodecList 中实现的 getCodecInfo

```
// http://androidxref.com/6.0.0_r1/xref/frameworks/av/include/media/stagefright/MediaCodecList.h#49
struct MediaCodecList : public BnMediaCodecList {
    Vector > mCodecInfos;
     virtual sp getCodecInfo(size_t index) const {
        return mCodecInfos.itemAt(index);   // 未进行任何边界检查
    }
} 
```

可以看到直接调用了 vector 的 itemAt 函数，并未进行任何边界检查。而 index 是我们作为客户端程序可以控制的，这个地方就存在一个越界访问的漏洞。

漏洞利用
----

根据漏洞的成因，我们现在有这样一个能力：可以越界访问 Binder 服务所在进程中的一个 vector<sp<MediaCodecInfo>>，但是只能读取不能写入。漏洞的作者利用这样一种能力可以实现任意地址读取和 pc 寄存器的控制，很是神奇。主要分析下 pc 控制的原理。在分析 poc 原理前，需要了解相关对象在内存的布局，如下图所示：  
![](https://bbs.pediy.com/upload/attach/201805/657395_C8Q48M9A3PRNBZW.jpg)

### pc control poc 原理分析

一个越界读可以造成 pc 的控制，关键在于 getCodecInfo 的调用： const sp\<MediaCodecInfo\> info = getCodecInfo(index);

```
//sp 拷贝构造函数
template sp::sp(const sp& other)
: m_ptr(other.m_ptr)
  {
    if (m_ptr) m_ptr->incStrong(this);
  } 
```

上面的代码是用 getCodecInfo 函数的返回新建了一个 info 对象，这就会调用 info 的拷贝构造函数。info 的类型为 sp，sp 的拷贝构造函数如上所示。可以看看 getCodecInfo 的汇编版本，像这样返回对象的函数，一般会把 R0 指向返回对象保存的地址。

```
//libstagefright.so
.text:000A9478 ; android::sp __usercall android::MediaCodecList::getCodecInfo@(const android::MediaCodecList *this@, size_t index@)
.text:000A9478 return_obj = R0                         ；保存的就是上面info的地址
.text:000A9478 this = R1                               ; const android::MediaCodecList *
.text:000A9478 index = R2                              ; size_t
.text:000A9478                 PUSH.W          {R11,LR}
.text:000A947C                 MOV             R3, R0
.text:000A947E                 LDR             R0, [this,#0x5C]
.text:000A9480                 LDR.W           R0, [R0,index,LSL#2] ; 这里可以越界读取
.text:000A9484                 STR             R0, [R3]; 设置info.m_prt
.text:000A9486                 CMP             R0, #0
.text:000A9488                 ITT NE
.text:000A948A                 MOVNE           this, R3 ; 调用info的拷贝构造函数，因为inline优化直接调用了(info.m_ptr)->incStrong()
.text:000A948C                 BLXNE           _ZNK7android7RefBase9incStrongEPKv ; android::RefBase::incStrong(void const*)
.text:000A9490                 POP.W           {R11,PC}
.text:000A9490 ; End of function android::MediaCodecList::getCodecInfo(uint) 
```

可以看到会将 vector 的内容读取到 R0 中，如果 R0 不为零，会调用 incStrong, 代码如下：

```
//http://androidxref.com/6.0.0_r1/xref/system/core/libutils/RefBase.cpp#322
 
void RefBase::incStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs->incWeak(id);
 
    refs->addStrongRef(id);
    const int32_t c = android_atomic_inc(&refs->mStrong);
    ALOG_ASSERT(c > 0, "incStrong() called on %p after last strong ref", refs);
#if PRINT_REFS
    ALOGD("incStrong of %p from %p: cnt=%d\n", this, id, c);
#endif
    if (c != INITIAL_STRONG_VALUE)  {
        return;
    }
 
    android_atomic_add(-INITIAL_STRONG_VALUE, &refs->mStrong);
    refs->mBase->onFirstRef(); //这里有虚函数的调用
}

```

汇编代码版本，可以清楚看到存在虚函数的调用：

```
// libutils.so
.text:0000E6BE ; void __fastcall android::RefBase::incStrong(const android::RefBase *const this, const void *id)
.text:0000E6BE                 EXPORT _ZNK7android7RefBase9incStrongEPKv    
.text:0000E6BE                                        
.text:0000E6BE this = R0                                         ; const android::RefBase *const
.text:0000E6BE id = R1                                           ; const void *
.text:0000E6BE                 PUSH            {R4,LR}
.text:0000E6C0                 LDR             R4, [this,#4]     ;this存放的就是越界读取的内容
.text:0000E6C2 refs = R4                               ; android::RefBase::weakref_impl *const
.text:0000E6C2                 MOV             this, refs ; this
.text:0000E6C4                 BLX             j__ZN7android7RefBase12weakref_type7incWeakEPKv ;
.text:0000E6C8                 DMB.W           SY
.text:0000E6CC                 LDREX.W         R3, [refs]
.text:0000E6D0                 ADDS            R2, R3, #1
.text:0000E6D2                 STREX.W         R1, R2, [refs]
.text:0000E6D6                 CMP             R1, #0
.text:0000E6D8                 BNE             loc_E6CC
.text:0000E6DA                 CMP.W           R3, #0x10000000
.text:0000E6DE                 BNE             locret_E700
.text:0000E6E0                 DMB.W           SY
.text:0000E6E4                 LDREX.W         R0, [refs]
.text:0000E6E8                 ADD.W           R12, R0, #0xF0000000
.text:0000E6EC                 STREX.W         R3, R12, [refs]
.text:0000E6F0                 CMP             R3, #0
.text:0000E6F2                 BNE             loc_E6E4
.text:0000E6F4                 LDR             R0, [refs,#8]
.text:0000E6F6                 LDR             refs, [R0]  ; vtable
.text:0000E6F8                 LDR             R2, [R4,#8] ; 可以通过这里控制pc
.text:0000E6FA                 POP.W           {R4,LR}
.text:0000E6FE                 BX              R2

```

梳理一下就是，越界读取的内容放入 R0，然后进行如下操作：

```
refs = [R0 + 4]
if ([refs] == 0x10000000)
    mbase = [refs + 8]
    vtable = [mbase]
    call [vtable + 8]

```

也就是说如果我们在内存中伪造了合适的 MeidaCodecInfo，并且将指向该伪造的 MediaCodecInfo 的指针放入 vector<sp<MediaCodecInfo>> 存储区的后面，这样我们就可以通过越界访问，读取到指向该伪造的 MediaCodecInfo 的指针，进而控制 pc。我们可以在内存中伪造如下的 MediaCodecInfo:

```
//BASEADDR 为假MediaCodecInfo的起始地址
*(BASEADDR) = vtale; //设置MediaCodecInfo vtable 随便填写
*((unsigned int *)BASEADDR + 1) = BASEADDR + 12;     //mRefs, 使他指向BASEADDR + 12
*((unsigned int *)BASEADDR + 3) = 0x10000000;        //mRefs指向此处，即虚假的info->mRefs的起始地址
*((unsigned int *)BASEADDR + 5) = BASEADDR + 0x20;   //info->mRefs->mBase字段，使他指向BASEADDR + 0x20
*((unsigned int*)BASEADDR + 8) = BASEADDR + 0x20 + 4;  //mBase的vtable字段，使他指向BASEADDR + 0x20 + 4
*((unsigned int*)BASEADDR + 11) = 0x61616161;          //vtable + 8, 我们可以在此处放置目标pc

```

最终 poc 运行成功，mediaserver 运行到我们指定的位置：0x61616161

 

![](https://bbs.pediy.com/upload/attach/201805/657395_77DUJ9H7J2HFMFX.jpg)

### 堆喷射的问题

要成功的运行 poc 实现漏洞利用的目的，要进行两次堆喷射，第一次是将我们伪造的 MediaCodecInfo 喷射到内存中，第二次是将我们伪造的 MediaCodecInfo 的地址喷射到 vector<sp<MediaCodecInfo>> 的存储区的后面，这样可以通过越界读取，来触发漏洞。  
但是遇到了如下问题：

 

1. 作者的 poc 中，硬编码了一个地址 0xb3003010，就是在作者的测试机器上，作者喷射的伪造的 MediaCodecInfo 有很大概率会落在这个地址上。作者说之所以是 0xb3003010 而不是 0xb3003000 是因为数据前面还有 0x10 字节的元数据，但是我们知道 jemalloc 中存放数据的 region 和 run 都不包含元数据，那么这个元数据是哪里来的？

 

先看下是如何堆喷射的，作者使用 IDrm.provideKeyResponse 进行堆喷射的，服务端在拿到 response 后，最终会调用 Session.provideKeyResponse 处理：

```
typedef android::KeyedVector,
        android::Vector > KeyMap;
 
status_t Session::provideKeyResponse(const Vector& response) {
    String8 responseString(
    reinterpret_cast(response.array()), response.size());
    KeyMap keys;
 
    Mutex::Autolock lock(mMapLock);
    JsonWebKey parser;
    if (parser.extractKeysFromJsonWebKeySet(responseString, &keys)) {
        for (size_t i = 0; i < keys.size(); ++i) {
            const KeyMap::key_type& keyId = keys.keyAt(i);
            const KeyMap::value_type& key = keys.valueAt(i);
            mKeyMap.add(keyId, key);          //在这里会将payload保存到堆
        }
        return android::OK;
    } else {
        return android::ERROR_DRM_UNKNOWN;
    }
} 
```

可以发现喷射的数据最终是保存在 android::Vector 中的，通过查看源码发现：android::Vector 的数据是保存在 SharedBuffer 中的。0x10 字节保存的就是 SharedBuffer 的私有变量

```
int32_t        mRefs;
size_t         mSize;
uint32_t       mReserved[2];

```

2. 第一次堆喷射需要将指向伪造的 MediaCodecInfo 的指针喷射到 vector<sp<MediaCodecInfo>> 的存储区的后方，但是我在运行作者 poc 的时候，越界读取很少可以命中，所以就想如何可以提高命中率。

 

作者的方法是：vector 的存储区肯定是 jemalloc 分配的，肯定是落在某个大小的 region 内，所以作者首先计算出这个大小，然后后面堆喷射时，喷射出大量相同大小的 region，这样后面越界读取就有很大概率命中。所以关键是如下步骤：

*   计算 vector<sp<MediaCodecInfo>> 的存储区所在 region 大小
*   确保堆喷射时，分配的是相同大小的 region

通过调试发现 vector<sp<MediaCodecInfo>> 的存储区所在 region 大小和作者中 poc 给的一致，但是在调试时发现喷射的 payload 并没有落在大小为 160 的 region 内，而是在 0x100 的 region 内。

 

原因就是 payload 在 mediaserver 中是保存在 Vector 中的，Vector 在分配空间时会多分配一些，所以大小为 160 的 payload，最终会放置在大小大于 160 的 region 中，通过调试，我把 payload 大小改为 96 就可以保证分配在 160 的 region 中。

 

修改后，运行 poc 后，内存布局如下图所示：

 

![](https://bbs.pediy.com/upload/attach/201805/657395_MBTVZBB6P2ABKD5.png)

 

3. 作者并未说明是如何找到 0xb3003010 这个地址的，存在这样一个地址的依据是什么呢？

 

查了一些关于 android 堆喷射的资料，都提到 jemalloc 相比之前的 dlmalloc 更脆弱些，具体表现在如下方面：

1.  堆地址中的熵较少
    *   很容易猜测到数据位置
2.  保存数据的 region 中没有元数据
    *   dlmalloc 会检查元数据的合法性

上面的堆地址熵较小表现在：32 位 ARM 系统上的 ASLR 算法的实现很简单，ASLR 会将所有的模块随机向下移动几页，范围在 0~255 页，代码如下，mmap_rnd_bits 可以通过 / proc/sys/vm/mmap_rnd_bits 来改变。

```
// kernel/arch/arm/mm/mmap.c
 
static unsigned long mmap_base(unsigned long rnd)
{
    unsigned long gap = rlimit(RLIMIT_STACK);
 
    if (gap < MIN_GAP)
        gap = MIN_GAP;
    else if (gap > MAX_GAP)
        gap = MAX_GAP;
 
    return PAGE_ALIGN(TASK_SIZE - gap - rnd);
}
 
void arch_pick_mmap_layout(struct mm_struct *mm)
{
    unsigned long random_factor = 0UL;
 
    if ((current->flags & PF_RANDOMIZE) &&
        !(current->personality & ADDR_NO_RANDOMIZE))
        //随机出向下移动几页
        random_factor = (get_random_long() & ((1UL << mmap_rnd_bits) - 1)) << PAGE_SHIFT;
 
    if (mmap_is_legacy()) {
        mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
        mm->get_unmapped_area = arch_get_unmapped_area;
    } else {
        mm->mmap_base = mmap_base(random_factor);
        mm->get_unmapped_area = arch_get_unmapped_area_topdown;
    }
}

```

可以看到随机移动的范围不大，而进程的各个模块在大范围的是相对固定的，比如在我的机器上，堆分配的空间基本落在 0xaf000000 - 0xb6000000 之间，当分配的内存远大于 255 页时，就基本可以找到一个稳定的地址来放置 payload，可以粗略计算下：

 

作者构造的 payload 在 binder 服务端，最终是保存在 Vector 中的，Vector 会多分配一些空间。在我的机器上最终分配的空间大小为 6144 字节，放在大小为 0x1800 的 region 内，都是放在大小为 0x3000 的 run 内，每个 run 可以放置两个这样的 region，并且 run 是页对齐的。也就是说分配两次 payload 就占用了 3 页大小空间，作者的 poc 一共分配了 0x1200 次，理论讲会一共分配了 6912 页，当然实际中会存在回收后再利用的情况，在我的机器上实际上分配了 3000 多页，这是远远大于随机移动的 0~255 页。所以可以找到这样一个相对稳定的地址。

总结
--

作者并没有给出 explicit，但是提到可以用 CVE-2015-1528 exp 的思路，后续会继续学习下这个思路，有成果了就补上。小弟刚开始学习漏洞这块，有错误恳请大佬们指正。

学习资料
----

漏洞作者给的文档以及 poc： https://github.com/flankerhqd/mediacodecoob

 

adb+gdb : https://wladimir-tm4pda.github.io/porting/debugging_gdb.html

 

binder 学习：https://blog.csdn.net/universus/article/details/6211589

 

jemalloc： https://blog.csdn.net/koozxcv/article/details/50973217

 

shadow jemalloc 调试： https://blog.csdn.net/hl09083253cy/article/details/79147625

 

shadow 安装：https://github.com/CENSUS/shadow

 

heap fengshui： https://bbs.pediy.com/thread-55879.htm

 

ASLR：http://drops.xmd5.com/static/drops/papers-14181.html

[[招聘] 欢迎你加入看雪团队！](https://job.kanxue.com/company-read-31.htm)

最后于 2018-5-11 21:45 被 glider 菜鸟编辑 ，原因：