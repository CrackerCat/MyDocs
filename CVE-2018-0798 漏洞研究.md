> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/kWnzqflge25PPOYNMTqSPQ)

本文作者  Strawberry@ QAX A-TEAM

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

CVE-2018-0798 为 Office 公式编辑器中的一个栈溢出漏洞，由于 EQNEDT32 对公式对象的 Matrix(0x05) 记录数据处理不当，导致栈溢出从而造成任意代码执行。本文对该漏洞进行简单分析，并探讨几种利用思路。

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

声明：本篇文章由 Strawberry@ QAX A-TEAM 原创，仅用于技术研究，不恰当使用会造成危害，严禁违法使用 ，否则后果自负。

QAX A-TEAM

**漏洞介绍：**
---------

下图为 CVE-2018-0798 的漏洞公告，描述比较简略：Office 2007、Office 2010、Office 2013、Office 2016 中的公式编辑器在处理对象时而存在一个远程执行代码漏洞，也被称为 “Microsoft Office 内存损坏漏洞”。根据 CheckPoint 发布的关于此漏洞的分析利用以及网上其他信息，可以得知该漏洞点位于 sub_443F6C 函数, 由于其对公式对象的 Matrix(0x05) 记录数据处理不当，导致栈溢出从而造成任意代码执行。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyRHKPtHzlxrLJZibKtHvAnlTfNbmxicgGY0hQnFanOBpk3J4LkqHHs3yw/640?wx_fmt=png)

**分析环境：**
---------

操作系统：Windows 10

测试软件：Word 2013

样本：手动构造

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyAic1RDicBzqXibS5gQqfoSg6vtawKTJnhDZ2lgw1Uy9s7fXKTqr4DoKVw/640?wx_fmt=png)

**漏洞分析及复现：**
------------

在 Word 中插入一个矩阵公式对象，另存为 RTF 格式，使用 OleTools 查看该 RTF 中的 EquationNative 流数据，如下图所示，可以看到在 MTEF Header 之后，有一个 Matric(5) 记录：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlygd2pNqcGjh12bVHWqylPiaURhwiczkYcVjRBia1KV0YwD9KEyiabc8VH8g/640?wx_fmt=png)

下图为 Matric 记录的结构描述，其类型值为 5：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyB0xV2Nia30ibICBhSxZ5YOkQnG3kqlwiauebqYQn1TKpNeYS0SicfJglmA/640?wx_fmt=png)

*   tag(5)              Matric 记录 tag 为 5
    
*   [nudge]           if xfLMOVE is set
    
*   [valign]           容器内矩阵的垂直对齐
    
*   [h_just]           指定行对齐方式
    
*   [v_just]           指定列对齐方式
    
*   [rows]             指定行数
    
*   [cols]              指定列数
    
*   [row_parts]    指定行分割线类型
    
*   [col_parts]     指定列分割线类型
    
*   [object list]    包含该矩阵中的所有元素（顺序为从左到右从上到下）
    

    下面来看 sub_443F6C 函数的代码逻辑，该函数有两个参数，第一个参数为一个 16bit 的数，第二个参数为一个 Byte 型的指针。首先对第一个参数 a1 做 (2 * a1 + 9) >> 3 运算得到 v4，然后使用 v4 控制循环次数，每次调用 sub_416352 函数将返回值复制给第二个参数 a2 指向的地址处。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyMvX5h2Vbnaic19ZNiatYWowRhuYE9m7PTAZ8jIP8OibzianFIHS9iaZ7zOg/640?wx_fmt=png)

接着我们开始调试，使用 Windbg 加载 EQNEDT32 程序，在 0x443F6C 处下断点，然后打开 RTF 文件。首先查看其两个参数，分别为 4 和 0x19efb4（栈地址），这里的 4 表示该矩阵有 4 行：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyQfxk4RSlicTlPVPkrgbVB8bzx0TriaRgVuRj7B01ozFrJl7lWA1I32NQ/640?wx_fmt=png)

然后经过 (2 * 4 + 9) >> 3 运算得到的结果为 2，那么接下来 sub_416352 函数就会被调用两次。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyaFCFylzMwZeJibWxKLqYSXxG6TlSvWPPL57S1HXeqLS3kPZxGYWjwFw/640?wx_fmt=png)

下面再看 sub_416352 函数的伪代码，首先在 0x45BD3C 偏移 12 处获取一个值 v0，并在使用后将其加 1，然后调用 sub_417732 函数。该函数通过 GlobalLock 函数获取一个内存指针，然后加上 a2 变量的偏移得到一个字节 v2，最后调用 GlobalUnlock 函数解锁之前被锁定的内存并返回 v2。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyxv6JwkNOVCia8icJFhHMSUAOSibeTNToQNLGuo00VxRf0cJmdPqTR9zbg/640?wx_fmt=png)

下面为调试 sub_417732 函数时的截图，在此场景下第一次调用该函数时其第二个参数为 0xd，下图为调用 GlobalLock 函数函数后的操作，GlobalLock 函数返回要处理的字符串的首地址，这里为 0x6bbe78，果然，要处理的数据为 MTEFData。然后取其偏移 0xd 处的字节，其相对于 Matric 记录的偏移为 6，属于 row_parts 部分。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyBfn69LA47tPeqabiaRfhf6axyicTm2C32snMnXz2VFDqMeWgrqHAVaqw/640?wx_fmt=png)

由于之前计算了 sub_416352 函数就会被调用两次，因而会读取两个字节放到栈上，之后程序返回到 sub_443E34 函数继续执行。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyx7WkameFaF23WdKy2cyqNwz7KPTJkY3tEks2DSUymR3GUxseWefckw/640?wx_fmt=png)

下图为 sub_443E34 函数的伪代码，可以发现 sub_443F6C 函数被调用了 2 次，注意到上面调用了 5 次的 sub_416352 函数，之前分析过它会通过 0x45BD3C 偏移 12 处的偏移值获取一个字节，根据推算，这 5 个字节分别为 valign、h_just、v_just、rows 和 cols 的值。然后后面分别为 rows 和 cols 调用一次 sub_443F6C，将后面的 row_parts 和 col_parts 复制到栈上。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyvhaG3ibpBY26QpPS2xjTgZ3Id7OWiaxCNPFv4PE9ctTQ1jVtFFgKIictg/640?wx_fmt=png)

为了验证上述推测，重新构造样本 2 如下，由于 (12* 2 + 9) >> 3 为 4，（2 * 2 +9) >> 3 为 1，所以选取一个大于等于 12 的行数（13）和一个小于等于 2 的列数（2），在 Word 中插入一个 13*2 的矩阵。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyo1zy2HzZl5ic7QBoA6WJZagwpPsNcRMbzKgZMsMupxJkeJPqpJRiaicPw/640?wx_fmt=png)

    查看上述文件的 Equation Native 流数据，可以发现其 row_parts 和 col_parts 的长度之和为 5（之前是 4），非常满足 4+1 的设定。重新加载运行程序，在 0x443E34 处下断点，发现程序确实通过 sub_416352 函数依次读取了 01 01 01 0D 02，然后在第一次调用 sub_443F6C 时循环了 5 次（while（1）循环），在第二次调用 sub_443F6C 时循环了 2 次，那就可以做点什么了。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly6iaQ0YOYdYdA0GCxt2mibdfm2enicwSSONBr6ldHFgEApSLwyUqdkiaibtw/640?wx_fmt=png)

还是看 sub_443E34 函数，其第一次调用 sub_443F6C 将数据拷贝到 v6，v6 距离 EBP 的长度为 0x14；第二次调用 sub_443F6C 将数据拷贝到 v8，v8 距离 EBP 的长度为 0xC，因而 v8 距离返回地址只有 0x10 个字节，v6 距离 v8 的长度为 8 个字节。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyh6rgISUnicH0icPnicqywh9F2HIvUSNzxXbBWicrWnZeUoN4F5f37OOTUw/640?wx_fmt=png)

因而我们可以计算某个阈值 x，使 (2x +9) >> 3 的值为 0x14，算出 x 为 0x4C，因而只要将该 Matric 记录的 cols 设置为一个大于等于 0x4C 的值就可以覆盖返回地址。修改上次的 RTF 文件如下，粉色区域用来覆盖 EBP，蓝色区域用来覆盖 sub_443E34 函数返回时的返回地址：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyI8oVgNY48d0tuCicXh71x6IRBo7yGpoQ8Oiak620JqO5Tia2ribMysiaLeQ/640?wx_fmt=png)

    最终，在 sub_443E34 函数返回时成功控制程序执行流程。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly87DQcibaBic5A17SdQElJG5oH6XSUaS1aSg9hFjB9wIXulncvKHeNpWg/640?wx_fmt=png)

**漏洞利用：**
---------

*   **无 ASLR 下漏洞利用：**
    

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly3ozGxBL3q6OdK5pEXaznS2escQMaCru2yFfRsIDYLpZBlovoaE45EQ/640?wx_fmt=png)

       上图为 Check Point 给出的利用该漏洞的 MTEF 数据布局，首先通过第一次复制将 "cmd.exe" 字符串复制到栈上，然后第二次复制后面的 38 个字节。当 sub_443E34 函数执行完会 ret 到 0x44c73a 去执行 add esp, 4；ret 指令，这样可以跳过 0x455b28（为绕过 sub_4428f0 检查设置）返回到 0x410eb6 去执行，其代码为 add eax, ebp；ret 2，其中，在 sub_443E34 函数结束时，ebp 已经被赋值为 0x19，此时，eax 偏移 0x32 的位置有一份 "cmd.exe \c calc" 字符串，因而调用两次 0x410eb6 使 eax 指向该字符串。然后通过 2 个字节的 "\x00" 平衡第一个 ret 2，最后跳转到 0x40ed4b 去执行调用 WinExec 弹出计算器，其代码为 push eax；call sub_430c00。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyHaAT0Pib7vaULeeTBUC4XMBMYvesQRqwnUIW6vHficV4zWAh4WSjpHog/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlySuq9icMxKpCPV8y7P25uMjUia5ZVc0AnexbQbpkRibP6DOnVb6pFffMWA/640?wx_fmt=png)

    虽然成功了，但我还是想知道这个漏洞为什么不能用类似 CVE-2017-11882 式的利用布局，sub_4428f0 函数中存在怎样的逻辑，对返回地址后的参数又有怎样的限制。下图为 CVE-2017-11882 式的栈布局：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyIFhDRKNP5Ap9cvCuLZNXibxQyca1RTBYxL9gBV85Q8JTbicElicTvYxLg/640?wx_fmt=png)

    重新加载执行程序，打开修改后的样本，在单步步过 sub_4428f0 函数的过程中果然出现了异常，如下图所示，程序因为无法访问 0x20657891 处的内存而抛出异常，此时 EAX 为 0x20657865：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyKnbxrBiap0QCekx1KGc20w9htLUnAdPWIgn5ZMshqs44ajiaZibxxNskQ/640?wx_fmt=png)

    根据堆栈调用，可以得出此调用链：sub_4428F0àsub_435B4Aàsub_431794，异常发生在 sub_431794 函数中，程序在通过其第一个参数以及 0x2c 偏移取数据的时候出现错误，通过溯源，发现该参数为 sub_4428F0 的第一个参数，也就是 sub_443E34 的第一个参数，在构造样本的时候我们将其第一个参数覆盖为了 0x19efb4。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly8tTy5OYUG4QFa04Axa0MBZrT1P2JCvefMNMNWTjE13JjEuQtTgCI7A/640?wx_fmt=png)

虽然在第一次循环的时候 0x19efb4 偏移 0x2c 处的数据可以访问到，但循环体最后会将 a1+4 处的双字赋给 a1，那么第二次循环 a1 就变成了 0x20657865，然后触发异常。如果想要快速结束循环，需要找一个可读的地址 x，并且 *(_BYTE *)(x+0x2c)&7) 为 2，或者 x 偏移 4 处的 Dword 值为 0。Check Point 使用的 0x455b28 就属于第二类地址：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyTGLmD9RYlsvSk6klNCk16OKfwSMSibyAxQlj3f0oJibbjdAOpH5N1ePQ/640?wx_fmt=png)

抱着试一试的态度又重新构造了样本，将字符串偏移 0x2c 处的字节设置为 02（还需要将前面的 cols 改为 9C），神奇的计算器就弹出来了：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlytiag69IJEMas9GkZaA59Cqwc0cHvAPG4BKXRCryx9XDmdh4gicpcAWfA/640?wx_fmt=png)

*   **ASLR 保护下的漏洞利用：**
    

如果程序打了 11882 的补丁，并且系统开启了 ASLR，那么该程序的基址就不一定是 0x400000 了。目前，针对该漏洞利用的思路是通过爆破基址来绕过 ASLR。要在样本中插入 256 个矩阵对象，每个对象里面利用的基址都是不同的。这种利用方式还不太稳定，有成功的可能性，但是整个加载起来巨慢。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly1h8picBd40425aJXZhFichbly4yexVhcl72DCgLe3tho9Ex770yDlGlA/640?wx_fmt=png)