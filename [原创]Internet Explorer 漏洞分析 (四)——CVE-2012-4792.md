> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-267090.htm)

> [原创]Internet Explorer 漏洞分析 (四)——CVE-2012-4792

0x01 漏洞信息
---------

### 0x01.1 漏洞简述

*   编号：CVE-2012-4792
*   类型：释放重引用 (Use After Free)
*   漏洞影响：远程代码执行 (RCE)
*   CVSS 2.0：9.3

`mshtml.dll`在释放`CButton`对象后没有更新`CDoc`中 Default Element 对此地址引用，以致后续`CElement::FindDefaultElem`会重新获取此地址，传递给`CMarkup::OnLoadStatusDone`函数，使用已释放内存。

### 0x01.2 漏洞影响

Microsoft Internet Explorer 6 through 8

### 0x01.3 修复方案

[MS13-008](https://docs.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-008)

0x02 漏洞分析
---------

### 0x02.1 分析环境

*   OS 版本：Windows 7 Service Pack 1 x86
*   Internet Explorer 版本：8.0.7601.17514
*   mshtml.dll 版本：8.0.7601.17514
*   jscript.dll 版本：5.8.7601.17514

### 0x02.2 详细分析

分析用 POC：

借助`Math.tan`、`Math.sin`、`Math.cos`(分别对应`jscript!Tan`、`jscript!sin`、`jscript!cos`) 及`mshtml!CreateElement`可观察各对象的创建。`document.createElement("div")`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_K4GTK6EHVNV6MCZ.jpg)

 

`document.createElement("q")`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_PQHS6CDGE3MKYZV.jpg)

 

`document.createElement('button')`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_3HK7F53XX39C7YN.jpg)

 

下面来看如何创建 DOM 流，跟进`CElement::applyElement`函数分析，其创建位于`CElement::EnsureInMarkup`中：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_3MJ4FS3P7EKXHDJ.jpg)

 

`CElement::EnsureInMarkup`—>`CDoc::CreateMarkupWithElement`—>`CTreeNode::CTreeNode`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_DY3RRS46MJR5NMP.jpg)

 

其执行情况如下：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_TVN9S7QAG8HXK52.jpg)

 

调用`CTreeNode::CTreeNode`完成：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_H3YSBEBDZPNPX45.jpg)

 

可以看出`div`元素 (即`e1`) 的`CTreeNode—>parent`初始指向 CRootElement，`CTreeNode`类结构如下所示：

```
class CTreeNode
{
public:
    CElement * element;
    CTreeNode * parent;
    BYTE        _etag;                              // 0-7:     element tag
    BYTE        _fFirstCommonAncestorNode : 1;    // 8:       for finding common ancestor
    BYTE        _fInMarkup : 1;    // 9:       this node is in a markup and shouldn't die
    BYTE        _fInMarkupDestruction : 1;    // 10:      Used by CMarkup::DestroySplayTree
    BYTE        _fHasLookasidePtr : 2;    // 11-12    Lookaside flags
    BYTE        _fBlockNess : 1;    // 13:      Cached from format -- valid if _iFF != -1
    BYTE        _fHasLayout : 1;    // 14:      Cached from format -- valid if _iFF != -1
    BYTE        _fUnused : 1;    // 15:      Unused
    SHORT       _iPF;                               // 16-31:   Paragraph Format
                                                // DWORD 2
    SHORT       _iCF;                               // 0-15:    Char Format
    SHORT       _iFF;
 
    CTreePos    _tpBegin;
    CTreePos    _tpEnd;
    DWORD      unknow1;
    DWORD      unknow2;
    DWORD      unknow3;
};

```

将`CTreeNode`对象地址写入 Element 对象偏移 0x14 位置处：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_DQTMXVUQWFQ5WJ5.jpg)

 

`CMarkup::ReparentDirectChildren`将`q`元素 (即`e2`) 的 CTreeNode 地址写至`div`元素`CTreeNode—>parent`中：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_4NESJMUXFCAZGZP.jpg)

 

CElement 类部分结构含义如下：

```
+0x10        CAttributeCollection
            +0x00    The total size of the Attribute Array<<2
            +0x04    Number of Attributes
            +0x08     CAttrArray
            +0x0c
+0x14        CTreeNode

```

对 POC 执行完`e1.applyElement(e0);`语句后所创建对象作一总结：

```
e0 Address:0x0026e4c8(Form Element)
    CTreeNode Address:0x00307cb0
e1 Address:0x002db1e8(Div Element)
    CTreeNode Address:0x00307af8
e2 Address:0x002dad38(Phrase Element)
    CTreeNode Address:0x00307b50
button Address:0x00311b48
    CTreeNode Address:0x00307ba8

```

对象布局如下：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_RP5EAGJZUDCWF5S.jpg)

 

下面开始漏洞分析部分。`e1.appendChild(document.createElement('button'));`对应函数为`CElement::appendChild`，对于`button`元素，其会执行`CElement::SetDefaultElem`函数，将该元素设为 Default Element：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_T845GAZK9YZG8FS.jpg)

 

具体执行如下：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_DK7DSKG7NRRV9GV.jpg)

 

![](https://bbs.pediy.com/upload/attach/202104/817966_E7WPB3X8CJVCX8P.jpg)

 

`e2.innerHTML = "";`会将 Phrase 内元素清空：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_PXYNHUAPMN93WCK.jpg)

 

`e2.appendChild(document.createElement('body'));`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_RT6SCKGV7DMMZM8.jpg)

 

`CollectGarbage();`对应函数为`jscript!JsCollectGarbage`，它会调用`mshtml!PlainTrackerRelease`对`button`元素进行释放：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_N2PHXY3NGKR3SGC.jpg)

 

![](https://bbs.pediy.com/upload/attach/202104/817966_72QPVHPM7KNKB4G.jpg)

 

但其释放结束后并未更新 CDoc 对象中 Default Element(`Offset 0x1A8`)，以致后续`mshtml!CElement::FindDefaultElem`函数使用已释放内存，触发漏洞：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_8U6QWHQPFMF63JZ.jpg)

 

![](https://bbs.pediy.com/upload/attach/202104/817966_PZY78M37T3UW4G4.jpg)

### 0x02.3 利用分析

#### 0x02.3a Heapspray

首先是对已释放 CButton 对象内存进行占位，可通过两种方式——`className`与`title`。`className`：

`title`：

(注：上述两处代码均来自[用 ClassName 占位和 title 占位的分析](http://t.zoukankan.com/Lamboy-p-3866940.html))

 

两种方式执行流对比：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_EUAUTXQD4E8DJD4.jpg)

 

其最终都会调用`_HeapAllocString`，其会调用`ULongAdd`函数将`substring`传递第二个参数加 1，之后乘 2 传递给`HeapAlloc`分配该数值大小堆块：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_FB6CJJN4ETJ72MC.jpg)

 

![](https://bbs.pediy.com/upload/attach/202104/817966_8D9NTFBDR4EV6GS.jpg)

 

创建 CButton 对象时申请堆块大小为 0x58，如此一来，需要修改`junk.substring(0,(0x58-6)/2)`为`junk.substring(0,(0x58-2)/2)`：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_9NSEM47V5KSKQHX.jpg)

 

完成占位：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_C6PKUKWPSFGWZT5.jpg)

 

![](https://bbs.pediy.com/upload/attach/202104/817966_XMX9W6A3WFV9HWX.jpg)

 

之后进行 Heap Spray：

`var shellcode=junk_offset+code+nops.substring(0,0x800-0x5F4-code.length);`语句中 0x5F4 是因为要实现 Shellcode 精准 Heap Spray 到`0x0c0c0c0c`位置，堆块上数据从`0x0024`开始，`0x0c0c-0x0024=0xbe8`，该值除以 2 即为 0x5f4：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_7VVVNRC93SVCA4R.jpg)

 

最后是 Bypass ASLR&DEP。加入如下语句：

会加载`C:\Program Files\Common Files\microsoft shared\Help\hxds.dll`文件，该文件并未开启 ASLR，故可利用其构造 ROP 链 (注：该文件随 Office 版本不同而不同，笔者采用 Office 2010 进行构造)。`stackpivot`有两处可供使用——`0x51be4a41`与`0x51bd29c7`，最终构造 Exploit 如下：

成功弹出计算器：

 

![](https://bbs.pediy.com/upload/attach/202104/817966_YJP9X8EPKPXMG6M.jpg)

#### 0x02.3b Non-Heapspray

来自 [Happy New Year Analysis of CVE-2012-4792](http://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/)：

```
 
 
 
 
 
 
 
 
 
 
 

 
 


```

![](https://bbs.pediy.com/upload/attach/202104/817966_9EZ54FDU2KE8T3G.jpg)

0x03 参阅链接
---------

*   [CVE-2012-4792 IE 0day (CButton use after free) 漏洞分析](https://www.freebuf.com/articles/system/6702.html)
*   [用 ClassName 占位和 title 占位的分析](http://t.zoukankan.com/Lamboy-p-3866940.html)
*   [CVE-2012-4792 漏洞利用学习笔记](https://blog.csdn.net/Hanxinyi930702/article/details/101457604)
*   [Bypassing Microsoft Windows ASLR with a little help by MS-Help](https://developer.aliyun.com/article/449548)
*   [一种非堆喷射的 IE 浏览器漏洞利用技术研究](http://netinfo-security.org/CN/article/downloadArticleFile.do?attachType=PDF&id=5535)
*   [Happy New Year Analysis of CVE-2012-4792](http://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/)
*   [IE DOM 树概览](https://www.jianshu.com/p/8cd37ffe9a98)

[[看雪官方培训] Unicorn Trace 还原 Ollvm 算法！《安卓高级研修班》2021 年 9 月班火热招生！！](https://bbs.pediy.com/thread-267018.htm)

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#UAF](forum-150-1-158.htm) [#Windows](forum-150-1-160.htm)