> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-267292.htm)

english version：https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred

[](#1）漏洞介绍)1）漏洞介绍
=================

CVE-2020-1350 是 DNS.exe 在处理畸形 DNS Sig 消息时，由于对数据包的字段校验不严格，导致了整型溢出。

 

DNS SIG 消息中包含对 DNS 记录集合的数字签名，DNS 记录集合就是一种名字相同，或者类型相同的 DNS 消息集合；

 

攻击者可以配置一个恶意的域名 TestDnsRce.com，该域名的 DNS 指向的 DNS 服务器作为本次攻击的目标；

 

1. 当客户端查询 evildomain.com 的 DNS 记录；  
2. 目标 DNS 服务器向根域名服务器查询 evildomain.com 的 NS 记录；  
3. 根域名服务器告诉目标 DNS，evildomain.com 的权威 DNS 服务器是 3.3.3.3，并该记录缓存起来；  
4. 客户端向目标服务器查询 evildomain.com 的 Sig 记录；  
5. 目标服务器将请求转发给权威 DNS 服务器;  
6. 权威 DNS 服务器返回畸形 Sig 查询结果;

 

目标 DNS 服务器处理 SigQuery 的畸形消息时触发漏洞第一现场；

 

参考下图：

 

![](https://bbs.pediy.com/upload/attach/202104/749942_92KMKYWSDU57JRU.png)

 

漏洞在 dns!SigWireRead 函数中，该函数用来缓存从另一台 DNS 服务器返回的 DNS Sig 记录

 

![](https://bbs.pediy.com/upload/attach/202104/749942_3CTKMDFXVSZNE9V.png)

 

根据上图漏洞函数中的第 11 行，RR_AllocateEx 传入了一个 16 位无符号整型，经过计算后作为申请内存的大小参数。

 

假如传入的 Sig 查询记录消息包，经过计算后使大小超出 0xFFFF，就会触发整型溢出漏洞；

[](#2）触发漏洞)2）触发漏洞
=================

由于整个消息包大小是有限制的，不能通过类似响应一个数据很大 Signature 的消息包来触发该漏洞；

 

也不能通过 UDP 来触发该漏洞，因为 DNS 消息通过 UDP 传输的大小也是有限制的，上限为 512 或 4096 字节，这取决于目标服务器是否支持 DNS 扩展机制（EDNSO）；

 

如果使用 DNS 截断，就会先发送一个 UDP 请求，如果响应消息被截断，TC 字段被设置，就会尝试用 TCP 协议重新请求，TCP 协议传输 DNS 消息最大限制是 64KB(0xFFFF)，仍然不够触发漏洞；

2.1）DNS 名称压缩
------------

在使用 TCP 协议传输时，通过修改 DNS 消息中被压缩的名称，可以导致 SigName.Length 变大， 而且不改变整个 DNS 消息包的大小；

 

下图为 DNS 消息中使用名称压缩的数据包：  
![](https://bbs.pediy.com/upload/attach/202104/749942_937M9JX38JKNTMW.png)

 

红色框 - DNS 消息开始至偏移 0xC 的数据

 

绿色框 - Flag 标记，0xC0 代表 DNS 名称位置相对偏移在 DNS 消息中；

 

蓝色框 - DNS 名称的偏移，0x0C，表示从 DNS 消息头开始，偏移 0x0C 字节才是 DNS 名称的开始位置；

 

黄色框 - 简单编码后的 DNS 名称

 

DNS 名称被使用以下方式进行编码，域名中的每个 “点” 作为分隔符，替换成了每个点后面的字符个数，并以 NULL 结尾；

 

例如：www.google.com  
![](https://bbs.pediy.com/upload/attach/202104/749942_3D2398HX22FYBJ5.png)

 

编码后：3www6google3com

 

在上面捕获的 DNS 流量数据包中，因为请求的域名是以 “9.xxx" 开头的，所以偏移指向 0x1；

 

因此，如果我们将偏移 0xC 改成 0xD，域名开始的偏移就会指向 0x39，表示域名的下一部分有 0x39 个字节；从而导致下一部分名称数据会扩展到数据包中的签名部分；

 

如之前在 dns!SigWireRead 函数中所见，传入 RR_AllocateEx 参数的大小是经过计算的， （signatureLength + SIgName.Length +0x14）；

 

DNS 名称最大长度为 0xFF 字节，从伪造的 DNS 名称中多出来的大小足以触发整型溢出漏洞，并且整包数据大小不会超过 65KB 的限制；

[](#3）漏洞利用)3）漏洞利用
=================

该漏洞利用最耗时的是了解如何正确操作堆布局的方法；下面部分重点介绍如何利用堆布局避免程序 Crash 并控制堆内存的释放和分配；

3.1）WinDNS 堆管理器
---------------

首先需要了解一下 WinDNS 服务是如何管理堆内存的；

 

WinDNS 服务有它自己的堆内存池，如果申请的 Buffer 大小超出 0xA0 字节，WinDNS 将使用 Windows 自带堆管理器（HeapAlloc）；

 

否则，WinDNS 使用自己的内存池，按照申请的内存大小分类，分别是：0x50，0x68，0x88，0xA0； 每种大小，使用单项链表关联起来；

 

如果链表中没有可用的 WinDNS 内存，则使用 Windows 原生堆来申请一个大内存块（memory chunk）；然后按照大小分别划分给 WinDNS 不同的单项链表中；

 

例如，要分配的内存大小是：0x50，0x68， 0x88，0xA0； 则对应的内存块大小是：0xFF0, 0xFD8, 0xFF0, 0xFA0,

 

每个内存块可分配的 WinDNS 内存数量：

 

0xFF0/0x50 = 0x33  
0xFD8/0x68 = 0x27  
0xFF0/0x88 = 0x1E  
0xFA0/0xA0= 0x19

 

下图为 dns!Mem_Alloc 伪代码：  
![](https://bbs.pediy.com/upload/attach/202104/749942_FAGZGEXAST5UWUZ.png)

 

当 WinDNS 的一块内存被释放时，并不会直接释放内存，而是将内存块再次添加对大小的链表中；减少实际内存分配消耗；

 

WinDNS 内存的分配和释放遵循最基本的 Last In First Out （LIFO）规则， 最后一个释放的，将会再下一次申请时被使用；

 

下图为 dns!Mem_Free 伪代码：  
![](https://bbs.pediy.com/upload/attach/202104/749942_TVKS4CV39GF5EKM.png)

3.2）WinDNS Buffer 结构
--------------------

![](https://bbs.pediy.com/upload/attach/202104/749942_BF3B3RQUCRAXQXY.png)

 

了解 WinDNS 内存管理机制，让我们在后面构造堆布局时更方便；

3.3）如何避免堆拷贝溢出时程序 Crash
----------------------

编写 POC 时，遇到的第一个问题就是通过 memcpy 拷贝 Signature 数据到申请的堆内存时，发生了访问违规；

 

我们必须报证拷贝溢出部分的内存被拷贝到有效的内存地址上；

 

在观察堆布局时发现，Windows 把我们使用原始堆申请的 WinDNS 内存块，放在名为 "Internal" 的堆 Segments 上；

 

Internal Heap Sigments 的大小为：0x41fd0-0x41ff0，经过观察，这些 Heap Segments，只会被 WinDNS 用来申请内存块；  
![](https://bbs.pediy.com/upload/attach/202104/749942_TWTA4NNDYN6MYCF.png)

 

如果我们能报证被覆盖的内存大小低于 0xA0，就能报证被覆盖的内存块一定是 Heap Segments 这里的其中一个内存块；

3.4）构造堆坑
--------

如果我们可以释放这些连续 Heap Segments 中的一块内存，然后重新申请到刚刚被释放的内存，然后再进行溢出我们可以使溢出的数据覆盖到有效的内存地址，这也是最常用的堆溢出利用技术；

 

在这种场景下，我们可以让客户端发送一个 Sig 请求给 DNS 服务器，服务器可以在返回的数据包中设置短 TTL，来控制内存释放；

 

同样的，如果我们想让一块内存长时间存在，则可以修改为长 TTL； 每两分钟就会释放一次 TTL 过期的内存

 

TTL（Time To Live）通常用秒来表示，用来表示 DNS 查询缓存记录的有效时间，不可能一直有效，当过期后，就会丢弃缓存数据，并向上层权威名称服务器获取最新数据；  
![](https://bbs.pediy.com/upload/attach/202104/749942_UKZZ5BW79TRKB7C.png)

 

构造堆坑的经典步骤如下：

 

1. 使 VictimDNS 服务器向 EvilDNS 服务器发送大量 subdomain 查询请求；

 

2.VictimDNS 服务器得到 EvilDNS 服务器响应后，会将数据缓存在堆内存中（Heap Spray）;

 

3.EvilDNS 服务器响应 subdomain 查询请求时，设置一个为短 TTL，剩余全部为长 TTL；

 

4. 等待被设置短 TTL 的 DNS 响应包内存被释放，WinDNS 每两分钟释放一次过期的数据包；

 

5. 再次请求 subdomain 查询，EvilDNS 服务器会响应一个畸形 DNS 包，触发整型溢出；

 

6. 因为内存是 LIFO 分配规则，上一步请求的 DNS 缓存记录，将会使用第 4 步释放的堆坑内存；

 

下图为使用堆喷避免 crash  
![](https://bbs.pediy.com/upload/attach/202104/749942_YDRUZJZCS7Q6SZ7.png)

 

现在可以稳定避免在拷贝数据时发生 Crash 了，但由于覆盖了堆上一些其它对象导致不定时 Crash；

 

下图为 覆盖了 CacheTreeNode 后发生 Crash  
![](https://bbs.pediy.com/upload/attach/202104/749942_ABJXAXD6923R6RB.png)

 

通过在 Windbg 中观察什么到底是什么类型内存，挨着被我们覆盖的内存；

 

下图为 在 Windbg 中跟踪内存申请  
![](https://bbs.pediy.com/upload/attach/202104/749942_DMPTW6JQDMR5X46.png)

 

可以看到在我们溢出的 Buffer 附近，两块新的 WinDNS 内存块被申请了，大小分别是 0xFF0 和 0xFA0，（后者是由于堆喷，记录大小是 0xA0 导致的）

 

那 0xFF0 大小的内存块是干啥的？这个内存块的划分大小是 0x88，用来保存 DNS 记录缓存的二进制 Tree 对象；被我们覆盖的正是缓存树对象；

 

当遍历树时就会发生 Crash；

 

此时思路已经很清楚了，还记得被覆盖的内存是在 Heap Segments 中的，该内存只能被 WinDNS 用来管理内存块；

 

也就是被覆盖的对象大小 <= 0xA0 , 并且是 WinDNS 内存块管理的可用大小 0x55、0x68、0x88、0xA0 这些大小；

 

我们知道 WinDNS 管理的内存被释放后，不会还给 Windows，而是添加到相应大小的链表中；

 

我们可以强制分配大量大小为 0x88 的内存，并释放这些内存，一旦释放后，这些内存就会被添加到 WinDNS 的 FreeList 链表；

 

避免从 Windows 中分配新的堆块，然后向 WinDNS 中申请大量不会释放的内存；确保我们覆盖的内存位于新的 HeapSegments 中

 

这样就不会覆盖到堆中一些重要对象；

 

下图为 堆梳理，避免溢出时覆盖重要的对象  
![](https://bbs.pediy.com/upload/attach/202104/749942_YSVVA8R3CSG64BW.png)

[](#4）覆盖堆上的对象)4）覆盖堆上的对象
=======================

通过前面的布局，我们已经可以为我们溢出对象在堆上构造一个坑了，通过这个坑，我们可以覆盖被我们用来堆喷的 DNS 缓存记录对象；

4.1）了解内存环境
----------

因为我们使用堆喷申请了很多内存块，这些内存被连续添加 FreeList 中，代表它们以连续的顺序进行分配。

 

所以我们进行 DNS SIG 记录查询的顺序，就是它们在堆上出现的顺序，我们必须知道溢出时，我们会覆盖哪些内存；

 

下图为 使用一个伪造的 Record 对象覆盖内存  
![](https://bbs.pediy.com/upload/attach/202104/749942_3ZQADT2EQDHDXZX.png)

4.2）RR_Record 结构
----------------

首先来看看我们用来堆喷的对象结构，缓存的 WinDNS Record：  
![](https://bbs.pediy.com/upload/attach/202104/749942_6ZE6EQE2NAFC2JT.png)

 

了解这些结构和 WINDNS_BUFF 结构，将会更方便构造 RR_Record 对象；

4.3）控制内存释放
----------

前面，我们通过控制 Record 对象的 TTL 字段，等待 TTL 时间到期后，每过 2 分钟就会触发一轮释放；

 

每次都要等 2 分钟，不是我们没有耐心，而是这会影响到我们控制重新申请内存；如果可以立即释放内存就好了;

 

当一个 RR_Record 对象从缓存中响应给对应的 NS 查询时，首先会检查 dwTTL 和 dwTimeStamp 字段是否已经过期；

 

因为每 2 分钟才清理一次过期的缓存记录对象，可能会发生要查询的缓存记录对象已经过期了的场景；

 

我们可以在伪造一个 RR_Record 对象时，将 dwTTL 字段和 dwTimeStamp 字段设置为 0，然后查询对应的 subdomain 就会导致这块伪造的对象内存被立即释放；

4.4）控制内存申请
----------

掌握了前面的控制 WinDNS 内存释放， 现在控制内存申请其实会方便了，因为 WinDNS 内存申请基于 LIFO；

 

一旦我们释放了一块内存，我们下一次申请同样大小的内存时，一定是我们前面释放的那块内存；

 

因为我们同样可以控制 WINDNS_BUFF 结构，我们可以伪造原始 Buffer 大小，这样我们就可以控制 WinDNS 从内存块中返回给我们内存的大小了；

 

下图为 控制申请不同大小的内存  
![](https://bbs.pediy.com/upload/attach/202104/749942_YS6CQ5AY2G5UNHA.png)

[](#5）泄露内存)5）泄露内存
=================

5.1） 泄露堆地址
----------

我们可以通过以下步骤泄露堆地址：

*   构造 2 个连续的 RR_Record 对象，释放第 2 个对象的内存;
    
*   修改第 1 个伪造 RR_Record 对象，wRecordSize 字段大小，这个代表返回的数据大小；
    
*   给 Victim 发送对应第 1 个 RR_Record 对象的 SIG 查询，加上 wRecordSize 的大小；
    
*   Victim 响应时会根据实 Buffer 的大小来读取数据，包括刚刚释放的 Record 对象中 WINDNS_FREE_BUF 结构，堆地址就在 pNextFreeBuff 字段中；
    

下图为使用伪造的 RR_Record 对象泄露堆指针  
![](https://bbs.pediy.com/upload/attach/202104/749942_WDPBP4BCKB3ESVF.png)

 

现在我们知道了一个堆地址，并且这个地址的内存我们可以控制，后面会用到；

5.2）泄露 dns.exe 地址
-----------------

下一步我们需要泄露 dns.exe 中的一个地址，来绕过 ASLR；我们可以申请特殊类型的对象，这里选择 DNS_Timeout 对象；

 

下图为 DNS_Timeout 对象结构：

 

![](https://bbs.pediy.com/upload/attach/202104/749942_PEH8BT5GD5KE5FA.png)

 

当 DNS 记录过期时，dns!RR_Free 被调用；

 

如果 DNS 记录中类型是以下类型时，内存不会立即释放，而是会调用 dns!TimeoutFreeWithFunctionEx 函数

*   DNS_TYPE_NS
*   DNS_TYPE_SOA
*   DNS_TYPE_WINS
*   DNS_TYPE_WINSR

下图为 dns!RR_Free 伪代码：

 

![](https://bbs.pediy.com/upload/attach/202104/749942_C4ZPQES3R9PNHMT.png)

 

在 Timeout_FreeWithFunctionEx 函数中，会使用 WinDNS 为 DNS_Timeout 对象申请内存；

 

在下图中第 13 行，初始化 DNS_Timeout 对象时，将 RR_Free 函数地址赋值给了 pTimeoutObj->pFreeFunction 字段；

 

以及一个字符串变量 pszFile 赋值给了 pTimeoutObj->pszFile 字段；

 

通过之前写了 Heap 地址的方法，将 DNS_Timeout 对象申请到我们控制的内存中，就可以获取 RR_Free 函数地址，

 

进而等于拿到了 dns.exe 的基址；

 

下图为 dns!Timeout_FreeWithFunctionEx 函数伪代码：  
![](https://bbs.pediy.com/upload/attach/202104/749942_DFSEQRMJM9PH6K4.png)

 

通过 Free 伪造的 RR_Record 对象和伪造的 wSize=0x50，该大小其实是申请一个 DNS_Timeout 对象需要的大小；

 

随后在 RR_Free->Timeout_FreeWithFunctionEx 函数中触发申请 RRDNS_Timeout 对象；

 

然后通过发送一些 subdomain 的 NS 查询请求到 VictimDNS 服务器，当查询记录过期时，就会为每个 NS 查询申请一个 Timeout 对象；

 

这里有必要多发送几个 NS 查询，如果等待 NS 查询记录过期时，已经被释放过 0x50 大小内存了；

 

只需要发送一个 NS 查询请求，Timeout 对象上的伪造的 RR_Record 对象和伪造的 wRecordSize，就可以泄露 Timeout 对象的内容了；

 

下图为 通过申请 Timeout 对象泄露 dns.exe 地址  
![](https://bbs.pediy.com/upload/attach/202104/749942_NASQS96VKPR2GMH.png)

 

现在我们有了一个 dns.exe 的基址，通过基址我们可以通过基址 + 固定偏移，来定位 dns.exe 内的任意函数位置；

 

甚至可以为各种 dns.exe 版本，做一个函数地址偏移的映射表；

 

最初，我以为可以简单的通过释放伪造的 RR_Record 对象，且对象的 wRecordType= DNS_TYPE_NS 来触发申请 Timeout 对象的申请；

 

在做这些尝试时，对传入已修改 wRecordType 的伪造 RR_Record 对象，某些检查会阻止 RR_Free 的调用；

[](#6）任意地址读)6）任意地址读
===================

其实我们通过覆盖 DNS_Timout 对象的 pFreeFunction 指针，已经拥有任意代码执行的能力了！

 

在 dns!Timeout_CleanDelayedFreeList 函数中，会依次调用 CoolingDelayedFreeList 列表中每一个 Tiemout 对象的 pFreeFunction 指向的函数地址；

 

CoolingDelayedFreeList 列表中的保存着即将被释放的 DNS_Timeout 对象；

 

幸运的是，Tiemout 对象中包含一个可以传给 pFreeFunction 参数的字段；

 

下图是 dns!Timeout_CleanDelayedFreeList 函数伪代码：  
![](https://bbs.pediy.com/upload/attach/202104/749942_2SD7NNK4TFQ5FJU.png)

 

我们可以等 Timeout 对象申请后通过覆盖 Timtout 对象的这些字段，来触发漏洞；

 

新版本的 dns.exe 编译时带了 CFG，目前公开可以绕过 CFG 的方法：通过覆盖栈上的返回地址，然后执行 ROP 代码；

 

虽然目前我们没有找到稳定的方法来将数据写到栈上；但是可以在 dns.exe 中找一个对 CFG 有效的函数地址作为我们的读写能力；

 

dns!NsecDnsRecordConvert 这个函数比较核实，它只有输入一个参数；

 

下图为 NsecDnsRecordConvert 函数可以接收的参数结构：  
![](https://bbs.pediy.com/upload/attach/202104/749942_RY74M9D875WS46G.png)

 

在函数内申请了一块内存，并且调用了 Dns_StringCopy 函数；这就是我们的任意地址读 Primitive；

 

因为我们可以控制传入的函数参数和参数内容，我们可以将 pDnsString 指向我们想要读的地址；

 

在 DNS_StringCopy 函数内会申请一段内存，并将 pDnsString 指向的内存数据拷贝进去

 

下图为 NsecDnsRecordConvert 函数伪代码：  
![](https://bbs.pediy.com/upload/attach/202104/749942_UAEK6SXBSS8KMY3.png)

 

因为我们可以控制 wSize，我们可以控制上图中 Rpc_AllocateRecord 申请的内存大小；

 

我们可以控制大小，让它申请内存时，申请到我们布置好的堆坑上；等内存拷贝完，我们通过内存泄露来获取读取的数据；  
![](https://bbs.pediy.com/upload/attach/202104/749942_RMEXE9WYDEZZURS.png)

 

我们读取的地址应该在 dns.exe 范围内，并且数据中包含一个 msvcrt.dll 的地址；

 

这里选择的是 dns!_imp_exit 该地址范围内包含一个 msvcrt!exit 的函数地址，通过泄露该地址，我们就可以绕过 msvcrt 的 ASLR；

 

拿到 msvcrt 的基址后，加固定偏移，就可以计算出 msvcrt!system 函数的地址；

 

需要注意的是：Dns_StringCopy 希望拷贝源是一个 NULL 结尾的字符串；如果地址的最低有效字节是 0x00，则计算出的字符串大小是 1，并且该地址不会被复制；

 

在案例中的 msvcrt 文件，这个问题并不会影响，但是作者并没有测试所有版本的 msvcrt；

[](#7）远程代码执行)7）远程代码执行
=====================

一切就绪，我们可以再次触发申请一个 Timeout 对象，然后覆盖 pFreeFunction 字段为 msvcrt!system 函数地址，以及 pFreeFuncParam 为一个堆内存地址，  
该地址上保存着要执行的 payload 命令；

 

为了获取反弹的 shell，最简单的办法是使用 mshta.exe 来执行一个远程 HTA 文件。 不过这个 exp 还有是存在更多扩展性和利用思路；

[第五届安全开发者峰会（SDC 2021）议题征集正式开启！](https://bbs.pediy.com/thread-266645.htm)

最后于 2021-4-30 00:00 被 Adventure 编辑 ，原因：