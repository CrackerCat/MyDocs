> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-247935.htm)

> [原创] 如何优雅的延长 JEB demo 的有效期

起因
--

前段时间 看雪推了《java 应用破解之破解 jeb mips2.3.3》 https://bbs.pediy.com/thread-222503.htm , 最近正好用到 jeb，发现 JDK 高版本的情况下，之前破解的 jeb 版本打开后会闪退，卸载高版本 JDK 回退到 jdk-8u121-windows-x64.exe 之后即可正常打开。Google 了一圈未发现 jeb 3.0 full 版，接下来对 jeb-demo-android-3.0-beta.6 版本学习。下载链接 www.pnfsoftware.com/dl?jebdemoandroid

 

http://jebbuilds2.s3.amazonaws.com/jebdemoandroid/jeb-demo-android-3.0-beta.6.201811202333-JEBDecompilerDemo-121820464987384338.zip

*   旧版本 JEB 在最新版的 JDK 下闪退
    
*   没找到 JEB 3.0 分享版本
    

分析过程
----

整个过程基本就是读代码，分析每行代码做了什么，最后再反其道而行之就能优雅的生成我想要的 License 了。

 

由于已有前人分析过，并且有介绍如何去爆破，那我们可以直入关键处

 

com.pnfsoftware.jeb.client.Licensing

```
static
  {
    pi.uW[4] = 95;
    int i = 0;
    i |= 0x80;
    hasDecompDex = true;
    hasDecompArm = true;
    File localFile = URLUtil.urlToFile(Licensing.class.getProtectionDomain().getCodeSource().getLocation()).getParentFile();
    pi localpi = new pi(new File(localFile, "jeb-license.txt"));
    user_name = localpi.uW();
    user_group = localpi.ku();
    user_email = localpi.Pg();
    user_id = localpi.WV();
    license_id = localpi.cd();
    user_count = localpi.mX();
    license_ts = localpi.vv(); //判断过期参数1，需大于0
    license_validity = localpi.sW(); //判断过期参数2，需大于0
    build_type = i;
    buildkey = localpi.iI();
  }
 
  private static int real_license_ts = license_ts;
  public static String buildkey;
  public static int build_type;
  private static final int FLAG_DEBUG = 1;
  private static final int FLAG_FULL = 2;
  private static final int FLAG_FLOATING = 4;
  private static final int FLAG_AIRGAP = 8;
  private static final int FLAG_ANYCLIENT = 16;
  private static final int FLAG_COREAPI = 32;
  private static final int FLAG_JEB2 = 128;
 
  public static final void setLicenseTimestamp(int paramInt)
  {
    if ((paramInt > 0) && (license_ts == 0)) {
      real_license_ts = paramInt;
    }
  }
 
  public static final int getExpirationTimestamp()
  {
    if ((real_license_ts <= 0) || (license_validity <= 0)) {
      return 0;
    }
    return real_license_ts + 86400 * license_validity;
  }

```

查看 pi 跟入 com.pnfsoftware.jebglobal.pi;

```
public static byte[] uW = { 69, 103, -94, -103, 1, -125, -15, 16 };
private static byte[] cd = "java".getBytes(Charset.forName("UTF-8"));
public pi(File paramFile) // 初始化函数
  {
    try
    {
      for (String str : IO.readLines(paramFile))
      {
        str = str.trim();
        if (str.startsWith(hu.uW(new byte[] { 44, 55, 13, 5, 13, 5, 21, 29, 6, 1, 84 }, 1, 122)))//str.startsWith("Validation:")
        {
          uW(str.substring(11).trim()); //获取Validation: 后面的字符串带入  uW('java.lang.String')
          break;
        }
      }
    }
    catch (Exception localException)
    {
      System.exit(0);
    }
  }
 
private void uW(String paramString)
    throws IOException
  {
    byte[] arrayOfByte1 = Formatter.hexStringToByteArray(paramString);  // 将字符串转成byte数组
 
    tR.uW(cd, arrayOfByte1, 0, arrayOfByte1.length); // 这里改变了 arrayOfByte1
    if (arrayOfByte1.length != 4096) {
      throw new RuntimeException();
    }
    int i = 0;
    for (int j = 0; j < 4095; j++) {
      i += arrayOfByte1[j];
    }
    if ((byte)i != arrayOfByte1[4095]) { // 最后一位校验和， 0-4094之和 等于4095
      throw new RuntimeException();
    }
    LEDataInputStream localLEDataInputStream = new LEDataInputStream(new ByteArrayInputStream(arrayOfByte1));
 
    int k = localLEDataInputStream.readInt(); // 读2个byte return (char)((byte[1] & 0xFF) << 8 | byte[0] & 0xFF);
    int m = 256 + (k & 0xFF);
    localLEDataInputStream.skip(m); // 跳到指定位置
 
    int n = localLEDataInputStream.readInt();
    int i1 = localLEDataInputStream.readInt();
    byte[] arrayOfByte2 = new byte[n];
    localLEDataInputStream.read(arrayOfByte2);
    localLEDataInputStream.close();
 
    byte[] arrayOfByte3 = new byte[16];
    ByteBuffer localByteBuffer = ByteBuffer.wrap(arrayOfByte3);
    localByteBuffer.order(ByteOrder.LITTLE_ENDIAN);
    localByteBuffer.putInt(n);
    localByteBuffer.putInt(i1);
    localByteBuffer.put(uW);
    tR.uW(arrayOfByte3, arrayOfByte2); // 这里变换了一下arrayOfByte2
 
    localLEDataInputStream = new LEDataInputStream(new ByteArrayInputStream(arrayOfByte2));
 
    int i2 = localLEDataInputStream.readInt(); // 这个值需固定为1
    if (i2 == 1)
    {
      int i3 = localLEDataInputStream.readInt() & 0xFFFFFFFF;
      int i4 = Hash.calculateCRC32(Arrays.copyOfRange(arrayOfByte2, 8, arrayOfByte2.length)); //这里有个hash校验
      if (i3 != i4) {
        throw new RuntimeException();
      }
      localLEDataInputStream.readLong();
 
      this.mX = localLEDataInputStream.readUTF();
      this.vv = localLEDataInputStream.readUTF();
      this.sW = localLEDataInputStream.readUTF();
      this.iI = localLEDataInputStream.readInt();
      this.Bi = localLEDataInputStream.readLong();
      this.Dv = localLEDataInputStream.readInt();
      this.zD = localLEDataInputStream.readInt();
      this.mL = localLEDataInputStream.readInt();
      this.XY = localLEDataInputStream.readUTF();
      this.Nj = localLEDataInputStream.readInt();
      this.XM = localLEDataInputStream.readInt();
    }
    else
    {
      throw new RuntimeException();
    }
  }

```

这样把上面看懂，基本就差不多了，接下来说说在看的过程中遇到的一些坑

 

在 com.pnfsoftware.jeb.client.Licensing 中 pi.uW[4] = 95;

 

所以 public static byte[] uW = { 69, 103, -94, -103, 1, -125, -15, 16}; 在使用的时候已经变成

 

uW = {69, 103, -94, -103, 95, -125, -15, 16}; 这个一粗心花了不少时间

 

ByteBuffer 设置了小端序，默认是大端序

 

localByteBuffer.order(ByteOrder.LITTLE_ENDIAN);

 

readUTF() 函数，参考 http://developer.classpath.org/doc/java/io/DataInputStream-source.html

 

是先读字符长度，再读出字符，反其道的时候记得在前面加字符长度值

 

接下来就是喜闻乐见的 keygenerator 实现过程代码

```
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.zip.CRC32;
class create{
    public static byte[] longToByte(long l){
        ByteBuffer buffer = ByteBuffer.allocate(8);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        buffer.putLong(0,l);
        return buffer.array();
    }
 
    public static byte[] intToByte(int i){
        return new byte[]{(byte)(i & 0xff),(byte)((i >> 8) & 0xff),(byte)((i >> 16) & 0xff),(byte)((i >> 24) & 0xff)};
    }
 
    public static byte[] stringToByte(String s){
        byte[] tmp = new byte[s.getBytes().length + 2];
        tmp[0] = (byte)((s.getBytes().length >> 8) & 0xff);
        tmp[1] = (byte)(s.getBytes().length & 0xff);
        for (int i = 2; i < tmp.length; i++) {
            tmp[i] = s.getBytes()[i-2];
        }
        return tmp;
    }
 
    public static byte[] concatAll(byte[] first, byte[]... rest) {
      int totalLength = first.length;
      for (byte[] array : rest) {
        totalLength += array.length;
      }
      byte[] result = Arrays.copyOf(first, totalLength);
      int offset = first.length;
      for (byte[] array : rest) {
        System.arraycopy(array, 0, result, offset, array.length);
        offset += array.length;
      }
      return result;
    }
 
    public static int hash_calculateCRC32(byte[] paramArrayOfByte)
    {
        CRC32 localCRC32 = new CRC32();
        localCRC32.update(paramArrayOfByte);
        return (int)(localCRC32.getValue() & 0xFFFFFFFF);
    }
 
    public static void mT_hr(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3, int paramInt4)
    {
        byte[] arrayOfByte = new byte[256];
        int i = 0;
        for (i=0; i < 256; i++) {
          arrayOfByte[i] = ((byte)i);
        }
        int j = 0;
        int k = paramInt1;
        for (i = 0; i < 256; i++)
        {
          if (k == paramInt2) {
            k = paramInt1;
          }
          j = (j + arrayOfByte[i] + paramArrayOfByte1[k]) % 256 & 0xFF;
          byte m = arrayOfByte[i];
          arrayOfByte[i] = arrayOfByte[j];
          arrayOfByte[j] = m;
          k++;
        }
        i = 0;
        j = 0;
        int m = paramInt3;
        while (m < paramInt4)
        {
          i = (i + 1) % 256 & 0xFF;
          j = (j + arrayOfByte[i]) % 256 & 0xFF;
 
          byte n = arrayOfByte[i];
          arrayOfByte[i] = arrayOfByte[j];
          arrayOfByte[j] = n;
 
          int i1 = arrayOfByte[((arrayOfByte[i] + arrayOfByte[j]) % 256 & 0xFF)];
          int tmp214_212 = m;
          byte[] tmp214_211 = paramArrayOfByte2;
          tmp214_211[tmp214_212] = ((byte)(tmp214_211[tmp214_212] ^ i1));
          m++;
        }
    }
 
    public static String byteArrayToHexString(byte[] b){
        String result = "";
        for (int i=0;i
```

生成后的 license 替换 jeb-license.txt 中的值即可  
测试了最新版的 jeb arm demo 也是一样可用（其余未测）,  
最后无图无真相上一张图  
![](https://bbs.pediy.com/upload/attach/201811/587389_ZMMRED5Y42A7APG.png)  
再贴个 license 吧

```
C6CF3C8A5C21A2D47F56888462033C13EF8C59CC32C74A3CF4402FBF7E56A8B2E300829BEE8A08289FDC234410748018B9679303C30E171BBB64D46DDBE37551D217CFB5A3CDECFFFD1EFB2966A82E97F91FB48A9C2391A908E6A412ABF554DA3A0DB17C88088F39DCE7A4250106CA56994708C7C36EFFDC3C9491F94977900140BE27D41F91E13C6F3B72D45D4E49F4BC97753DDEF95309E050826952DF8BA13B7B16EFAFB0132D773022688CB320C47A93EA3C57B6E53778B3C273477114CB6506C932ECE27E4DD57FAA463BFB4EFB5661F3A050EC2477AF069BA8A6DBB18B944B45BF33D3AE87E85E9B49650944BA2BEEE248DF9035FBF76BCC75394364C9B843F46744EC2463D54976FCD4E75DD2CE6EAECF4BBDE0DAF50C335C08C8D1E57FC24BD78519CC759E95816010BDB9AF996DB0EE5E75BC7B06C1267CC21CDFF31689DC3F30DF50F737235B50378F5D350185776216D33DBDDA88DE6DFB01EF49AF217143AE3FA602068DBDE9CC7AA7EF859444EE75008370164BAF77DE0891AEA3D72E357624A9E91F4DCE226B0B73CB965A8A018A8C162024459FD2909F4DDD4701F4B5A1670F31350FE049C49D29F029978E1ED203CBB33EBCD83B6660058B615BD566ABE2EF65D4A3B45A219CCA70D64F5895ABA3F5F2650DD39D7EC19B63EEAD8D27CE4B9BABB83F0EA9110ECC4ECD9D5939F9BEBB22320068F6DB73F956B6401982DAA0F244A0D01FA94B9AA0199155FA2CCE786C3E90857A392EFD20FA74C2C4DC9C702F34642314C0B865E215B65393AEA4651ECAD813718728DC06CDBB6BBC30D0202C2711183575F836E3141E6E8211EDB88F5BABCCFC53003B0A8372F921918DDC1ABFFFCDE25B6E1D56C378CC2EC6BE80573EAEAE8DF8C0A1A6382B802069FAB311D710893BCB781665577ACF7A3AF6DA0C90706101B0241ADBA0958FFCA87A7369244D5C4C031C3E1FD8A40A5021F2CFD4C921A58373866A3E0F81BBAA4EA12F19AFD31A1D472A97317BD9CF5150F88EC4D9788092A753EE713E27BE4747C1678B7297D5CDEC315005F66153CF5CA7A3F9FD1ECF19E3E989C0710F6F81F2215137705F661954D24E2B04B2FEB8030B1BA0EA3E054F40D4B40190F9EEEEC2C7EABEAAEFCEBB6B8412F10E87A04659A44F14FC7D84DE6FFF02A34F211938462E6830CC028AE2CA6B27880FC669BF428555250A693BF353FA1F1800CFECDEFA76D4C5FE697B72F424F8703828EEED579547ADDE2C1A2E6637EAA713E009EE065513DD4DFE1710B5337056646688899E37912E1A00EAF523257AEF11A3CFB07AF773D94CA1407479B6F6590B582A76268D7994203A922FD28248F79B1F98E8AB5F91D5A193AFA6D309E29C0D3065B20DD6D74A4A6CD56A721ECA7AEA401A1CDCA26E812CA2077998C61E9B63D298FAB655A90ABD7C2FC0A8D077BAF99F87560E65A7F936F70E643265B9C4DCA770B2881501960142018F33D1A0AC5471EF90618F3C54A9701793E71494BCA6FAAF318D7DB2D98CE7250B09DCD8935CF885DD6CC1BC42DC73BBF78C4064AD4E4802C0E9E32466EF23B8DE143565978A890175224DB3A507857B1CB310AFBE1E3EF42B50DDD7E3F4D677CFA9E39F9B6E1650EECC2055CFF64754D0836C4102EFEB43F7662C7B9354598C63C692A96474C59C75ED97D6690137284C9EDCA50F564BEE4813F8EC8F17F4CE5F32B77AD076A671B747CA6614037E335CFE59BE8D79170229DB70962A3C136CAABCABBC226FC53BFB8AB36918B29F894D61B6B9B18F0C8F09F1361AC0E355A651058CA3B029DF139B62FBC4964EA697810CCB7093DB0E80C25DAE564E3743603A7666438D8F2D8EFCBBB76E2B4D2A66CF0B2C0439A487CC8035CB2CA830F2B9764FD94F45856126991824E5102870EAA25491CE21A8150E6608ADF6DEA6F4CA3B235B0800D9BCAAAEEB3AFF2486BF984BD6756CF4D81A1ACEE672F2A87416F5CA51B4019FA8F3DA2EA7FAD46E9E3FE7ED61C91B6F2ABD9D40BCAE89FAB47D5F1781774A280158AD7B1C259FD920949691A2BB07911D63868F6F1A1394F0E86CD940FA2154EB1FDA408F6F3DBFB95C62383394E74A30BA6140E887D6D8542687C8FEAE0876E751E0C093EB8F0B610E5C3A97FBA11DEFBF77AC7F4F037BB8DAF3EFDEE641EA2DF2FB38205E8A8F721263B259E377B098678B24BE3867ABB752CF0DF9F56D0C82E34CC341BCBB8F1614A017224D59538A9EF0A8FD10DFF45E127B8B98772F29F96E85525000DA83E337FE2DF5EEDEB18DB729CE58AF7E7AAA0985FD755DACE479A520B589362D7992FF776B28C01B723E54209171B7428E2ACACDA1BA9CA87680ECCC6E49346344FA726B9B43485236B8790774B8F6BA40DF857B46B588C43351075F3B9791C642475F652CCAAAE3C1F6D43207EC8252CD27602F4E796CBF09CA7F3337053F4AAC9730DB28A7DBC8CF758BB9EF177EAF88F2280806BC5B5597E4D33DE7B3BE3BD390853F3926890888059966CBBAE068A8CF3A0A0C7D373EFA2EF3AB18BAB01DDD1182194265CAE1E4E4E8ABC77C3A11F9F21D4F5289CF494FF7D5E886D5FF5E1F58409F3D50E4638CF2F10D9095B855698111EBC0DAEDB82CD328FA2C01FFA1A37775A7E4868919C6A438D7A710CB28CC450EA9E68352F13F6C21B982AE6353A49897D701E2D835A76E8A9EC46406DF775C2CC153F06D971FDDF70A9D40864E25CE26847D5129E513F2A4217B7B162F142570E92904A8935FA9BD57DECBCFFBABDCD03AFFD60D3C7ABEE1551CA9E7170AC187037D5D1359272A10028A2BDA50B0B5F4ED0E5D7F3DCA097935FBA947492984256379CF822FDEAD48B91D82F1DE315EE259B7B3A883FF37549217C58840B759DC3487AC5E4F46792579E52250BE2A4D89E91B8C2C396D79C12FD1DE73DA830AF67EAE3FA57520149D5F8B4AF5AACC33032A827234B698CEB2C582208EF816226DB61120ABCAEE04F165537E99BDD0DD47B28EB104041E59372BA3497DBAF8FAB66AEE0E23D16E58858E104D01E081F45CB10FC96F3A59097884017178D7077F0EFFF0B920AD5C896AD48184C9B32DFA8DE6F2C79718E6DC3A7FE877929EE80CD47A4160BD277308402E70EE50EFFA1BD09A563BB49F96C2272C72B32CBFA870407A7BD40FA601AE12F629CBF34054EA23A00D968228EB14CD88339EA314DA8715A43241D795EB5A066DF1A6C93EB2F37FB47C12CD12A1016510ACD23940F37A79F86F0A6D5790B75E9EAF65936D818CB1C606FC03A2828DC2972B1A55E62EDD9CCB7E8B61A5A00B6035D0932A3A6D9BA9EDEC0B75BFAA2D426E74E4E3EE97DC00E93BEE6A71D87B1EAFD91471B9207CA23D9AAE37B94BFE8F1CA5F5A0CB5D3F9596C495AC2EDC7D7E52DF3FBDD260EEAF7408F9A27E92F7FC8DB3BBF82CF6B49EEADE5FE67A84AB78E189463AFFA56EC7F7219B1CF5A63E654012C5C33CBD155678D71D58018717E72D0DBBC5858D589799DB165B32EAE708583E9E7B5F97F6FDD30B8E20598918F0CBF50C3942892241A7798C12DE8E513C5859E377BD16543E216331F34F0449A351535DBF3842515CE0CEC9C142B9BB3569797C388459EEEFA555B4F3D714A9DD06DEAAE0DDC2E78D6A4A5FAAB77ACB1FB423EA68C6A9B5B747E3C49418660BD9FA4021C0F9D64D938E0A9608555436FC13553B0DFD59E810E4410D944A7A57977E272EFFA07773534186D44319314B51C784726C61197372AF2E349D6747371330CBB18E0C8803662E8F4BE17F3A3AFCCD6ABEF22F8D2B281C95F220B827E9DA5A7EDF9854C00A98BC2074F877E41043A6934B73C783A4196B8A259685149F3B7FE017E5EB54E8A589EFDB78BD580F85FECFEE39E14AA19E9379A1A9D2F90C2010F1B68C27D9E0767BDCB91FE2FE1578A0CB30DAF2F2DC19CA1B9A195133FE91B46DF557685F56EC65A77DCEB7AD2868FF745ACC04CC0B2C85300184A61D18E0FDA6E42DC194E6366EA609B4B63F0BFEE343D2E7804F7E4A1B5F387F050A4C5123CD03D150E261D1089FDB62B333FC7CAFB683AB68F9836859281D9454AA9E99F9170C6BFB72323B0C99B84F02D591DA80B7974BE07971C433F120353E42B01DC34151CE60A0AA7238CB301EBE40B7EFDFE2BA22DA483DED6B6AD36D12A90E0FE7DE2CBB3AB90CDDB8797BE627E38ACFC3A076AFFE7AB99C69A96F6900685C4040D951A68D3B484196AE5481E950661D0C643D49F2F73CE8FCC9DC1AB59F22E0E4613C61DBB112D8B332B14391CFCCF04FDD5E483B43E3D0653170F08D54407D65EA6474A000019982CA1EEB1F5BD168C71F0DF92DE273FE6755A6997806CFA7CC9122205A89B4DF089864BD397FCC290AED62545F36155338588ED85A602FD9FC4A68F7F81CC017150DAB783B636622AB9D47B776E3B8590D0E5BC0CDBB6A3FAD4565D62BF509CDA322D499BB6F04B2518395744FE747D5380CC731F443B80F58296C8756D71B99F58A720A77813FE5BBE711FEAB2A791336B25262B9C4903FAF257B4F25B7855E4D4B5329E3DEA0F0F9366459C5FC4D0A1A5A59F9B2B7D90FA5A6E5B9FB83E7340125E36C36F2E49ADFC496E4E01A51CA10CA1A0F1ACF9A7EA82B4C86DCF1F191C509B7DEF5880DCCB42DBF79A6CEB869A7F537F62471320E543E3D450D19580721336DCAF3D52431E4C7C783EBFE4B1007749A5B3923B12A551751EAA8009A4B902318D0BCB84111F5F9DFA41EAF05CDC483BEBB942CA9E8F7CBB994BF4F88BFE939D24E77F6277316AB4DE5830A85EAB31DB0066EAEC5B73F4759DEC1E5CE70D25CD437F56405EAD20E8B02615DAC6E082712C7C74DB0824E0B32710EA95F15D503415BE4B2D011F8FDD484679B751E3B62EE417E7E3EC1709A0592043CBF7188C6D02C7140326BC37B12EFBA571CDEE06E8183FD0BADFE52FD0BB5074E7A476111A4247C7E3399573BC0EF3BB63F054BE34A6319CA46782E56A0AEE2FF5C10B0010AC3861DC8E2E3694BF33D27EA17A3D131D9CAE5237AB29BB60DB1F611E39496A0908B1368BABEF19285BF5E4254A31EB0840B66A7BC1E54C2C1DF9F3C392E3C17F495A3835D465163AEF520FB71981E626E266FB6D9A9A298093ACF17242AEB255FCFA2B28BC05B2511E417347D9BC623470EDFCC6BFFBB992B147A72C68F29E6B5A9D654B1CDF6CB2A17352BCB4DA192A3089D9461EAB489F27C0C8F621BF7E46C3F54595BDE3E92F7EA154D4D175136B7590A862D08C491B7AFB54B548D8DD568247A3DEB9915E9709B91589216CFDF76876575D6F9637B72F92AB41B7EA050540794B1C0A6D9388D2F0B968FC791D18BBA9E756EC4D7C0D6C88F15679371D87702996D7413415111A4AD63DEF38A19E8DFC9F2144AF0A79FD991EBCB9C0489E92E36217E774DDAF2B71F3512D8164995D4D1091F2C706A7632B05BEA84074B8069EB68E02962D5C512618C80D8B67C5724444287D2C7173F071A0A49472C4FDA9329E8B4030ED382C9F82DA49EC4B3D8143F7540E18910D49282A6DDEA5D5B9047143B5614D014A8DF3E71B811958C77C945ABC5800F88889F9BB76D0FB5C29C4E5E559CACA0425BE2613CB6AA57CCC19BC1C872E4F41A8A10047C99428825155EC1DAAD425CA2EFFD2567E16484FFC3F77EC11682DDE33DF329C1CFA0B3E7F8CA8558D88E8033F1D4FDBA781B450F83D79E3CF6DF7CE69DA5FB99C4B33A9BBF0B4A4D94DB955A03D45B959C09037A37FBC13ACD6BE3E4049B04F1AF54845028BCB5C297B6263B8C078DADF68BAAD3C0B0072C

```

食用方法：  
下载新版 demo, 找到 bin/app/jeb-license.txt 文件，替换 Validation: 后面的字符串后再打开

[[看雪官方培训] Unicorn Trace 还原 Ollvm 算法！《安卓高级研修班》2021 年 6 月班火热招生！！](https://bbs.pediy.com/thread-267018.htm)

最后于 2018-11-23 13:26 被 kimoh 编辑 ，原因：