> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_38365495/article/details/80537000)

**1、关于 B（跳转指令）与 BL（带返回的跳转指令）：**

B 指令与 BL 指令均能使指令跳转到目标地址，两个指令和目标地址处的指令都属于 ARM 指令集。二者也都可以根据 CPSR 中条件标志位的值和指令中的执行条件决定是否执行跳转操作。二者不同的是，B 指令只会执行跳转操作；BL 指令在跳转的同时还会将 PC 寄存器的值保存到 LR 寄存器中。

指令的编码格式：![](https://img-blog.csdn.net/20180601141658732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzY1NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

指令的语法格式：B{L}{<cond>}<target_address>

其中：

●    L 决定是否保存返回地址。但有 L 时，当前 PC 寄存器的值会保存到 LR 寄存器中；当没有 L 时，指令只会跳转，当前 PC 值不会保存到 LR 寄存器中；  
●    <cond> 为指令执行的条件码；  
●    <target_address> 为指令跳转的目标地址。这个目标地址的计算方法是：将指令中的 24 位带符号的补码立即数扩展为 32 位（扩展其符号位）；将此 32 位数左移两位；将得到的值加到 PC 寄存器中，即得到跳转的目标地址。由这种计算方法可知，跳转的范围大致为 - 32M~+32M。

**2、B、BL 跳转目标地址计算：**

汇编代码：  

```
.text
.global _start
 
_start:
	/* 设置内存: sp 栈 
	 * ldr sp, =4096 nand启动 
	 * ldr sp, =0x40000000+4096 nor启动 
	 */
	ldr sp, =4096  
	
	/* 调用main */
	bl main
halt:
	b halt
```

C 文件代码：

```
int main()
{
	while(1);
}
```

反汇编代码：

```
00000000 <_start>:
   0:	e3a0da01 	mov	sp, #4096	; 0x1000
   4:	eb000000 	bl	c <main>
 
00000008 <halt>:
   8:	eafffffe 	b	8 <halt>
 
0000000c <main>:
   c:	e1a0c00d 	mov	ip, sp
  10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  14:	e24cb004 	sub	fp, ip, #4	; 0x4
  18:	eafffffe 	b	18 <main+0xc>
```

目标地址计算方法：  
    1. 将指令中的 24 位带符号的补码立即数扩展为 32 位（扩展其符号位）；  
    2. 将此 32 位数左移两位；  
    3. 将的到的值加到 PC 寄存器中，即得到跳转的目标地址。

**例 1**- 以汇编代码中第十二行代码（bl main）为例：【相对跳转】  
    1. 根据反汇编代码可知 bl main 的机器码为 0xeb000000；  
    2. 将指令中 24 位带符号的补码：0x000000，将它扩展为 32 位得到：0x00000000；  
    3. 将此 32 位数左移两位得到：0x00000000，其值就是 0；  
    4. PC 的值是当前指令的下两条 (下一条的下一条) 指令的地址，加上第三步的到的 0（当前指令地址为 4，当前指令的下两条指令即 + 8，所以 PC=4+8+0=c（12））；由此可得 bl main 跳转的目标地址为 c，即反汇编代码中第八行 main 的地址。**（因为 ARM 的流水线使得指令假设执行到 A 处时, PC 实际的值是 A+8）**

**例 2**- 以汇编代码中第十四行代码（b halt）为例：【相对跳转】  
    1. 根据反汇编代码可知 b halt 的机器码为 0xeafffffe；  
    2. 将指令中 24 位带符号的补码：0xfffffe，将它扩展为 32 位得到：0xfffffffe；  
    3. 将此 32 位数左移两位的到：0xfffffff8，其值就是 - 8；  
    4. PC 的值是当前指令的下两条 (下一条的下一条) 指令的地址，加上第三步的到的 - 8（当前指令地址为 8，当前指令的下两条指令即 + 8，所以 PC=8+8+(-8)=8 ）；由此可得 b halt 跳转的目标地址为 8，也就是自身当前地址（此条代码起循环作用）。

（以上部分内容摘自《ARM 体系结构与编程》）  

**3、为什么跳转范围是 - 32M~+32M：**

在指令的编码格式中 bit[23:0] 跳转的目标地址，在计算时会左移两位扩展为 26 位有符号数，是表示要跳转的目标地址相对于 PC 的偏移值，表示范围为 - 2^25~2^25（其中有一位为符号位），也就是只能跳到相对于当前 PC 值偏移 - 32MB~+32MB 的位置去，与地址绝对位置无关。