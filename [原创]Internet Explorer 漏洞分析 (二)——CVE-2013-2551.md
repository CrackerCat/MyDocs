> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-266150.htm)

> [原创]Internet Explorer 漏洞分析 (二)——CVE-2013-2551

0x01 漏洞信息
---------

### 0x01.1 漏洞简述

*   编号：CVE-2013-2551
*   类型：整数溢出 (Integer Overflow)
*   漏洞影响：远程代码执行 (RCE)
*   CVSS 2.0：9.3

VGX.dll 中`COALineDashStyleArray::put_length`函数在处理 length 数据时未做有效验证，以致 length 为负数可造成整数溢出，进而实现任意读写。

### 0x01.2 漏洞影响

Microsoft Internet Explorer 6—10

### 0x01.3 修复方案

[MS13-037](https://docs.microsoft.com/en-us/security-updates/securitybulletins/2013/ms13-037)

0x02 漏洞分析
---------

### 0x02.1 分析环境

*   OS 版本：Windows XP Service Pack 3
*   Internet Explorer 版本：8.0.6001.18702
*   VGX.dll 版本：8.0.6001.18702

### 0x02.2 前置知识

VML 的全称是 Vector Markup Language(矢量可标记语言)，其基于 XML，矢量图形——意味着图形可以任意放大缩小而不损失图形的质量。VML 相当于 IE 里面的画笔，能实现你所想要的图形，而且结合脚本，可以让图形产生动态的效果。(不仅是 IE，Microsoft Office 同样支持 VML)

 

使用 VML 首先要通过`<style>`引入：

之后声明 VML Namespace：

如此便可添加 VML 元素以绘制图形。

 

一例:

```
 VML Sample 
 


 

    


```

Shape 是 VML 最基本的对象，利用它可以画出所有你想要的图形。其主要属性 Path 可参阅 [VML Path Attribute—Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-path-attribute)。

### 0x02.3 详细分析

使用 IE 打开`poc.html`：

```


 POC by VUPEN 

 

 
 


```

允许阻止内容后，WinDbg 附加进程并运行，单击`crash`按钮，崩溃点如下：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_DJNUZWEEEFYVXGN.jpg)

 

使用`gflags.exe`为`iexplore.exe`开启页堆，WinDbg 启动`iexplore.exe`，通过`.childdbg 1`命令启用子进程调试并运行后，崩溃点如下：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_3N9VQ227JBWVZWA.jpg)

 

`kb`查看调用堆栈：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_MR62QF28QP45ZD8.jpg)

 

重新启动`iexplore.exe`，加载`VGX.dll`完成后于`ORG::Get`函数处设断，查看其`this`参数：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_Q4UQ95UMXKMBNPA.jpg)

 

继续向下分析，可以看到`vgx!ORG`对象结构偏移 0x10 处存储指向`dashstyle`数组指针：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_8UPM4BTPWFSVQ4N.jpg)

 

`marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16);`操作由`memecpy`完成：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_DTXXPWM325YHUKG.jpg)

 

漏洞成因显然不位于该函数，继续向上回溯至`vgx!COALineDashStyleArray::get_item`，其调用`vgx!ORG::CElements`获取数组元素个数：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_39UXT8A4FZAGPBF.jpg)

 

要读取元素下标需大于`0xFFFFFFFF`，小于`vgx!ORG`对象结构偏移 0x04 处值 (WORD)。若下标合法，之后便会调用`vgx!ORG::Get`。可以从上图看到数组 Length 值`0xffff`，该值需跟进`COALineDashStyleArray::put_length`函数分析。

 

首先获取数组原长度，与更改长度进行比较：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_U74Z57AA2YQ53HP.jpg)

 

此处即为漏洞触发位置，其调用`vgx!ORG::CElements`函数获取长度使用`movzx eax, word ptr [eax+4]`指令，将长度当作无符号整数处理 (而非采用`movsx`指令)，但跳转语句`jge`是基于有符号整数比较的跳转。

 

大于等于则会调用`vgx!ORG::DeleteRange`：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_673HVV38VF4WTV2.jpg)

 

跟进发现其调用`MsoDeletePx`：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_7Q8SWJXKCZSRR7P.jpg)

 

继续跟进，写入更改长度操作位于`MsoFRemovePx`函数内：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_MF28DP8JBHUUA7K.jpg)

 

如此一来，将数组 Length 修改为 0xFFFF，进而可以实现越界读写——前文分析`vgx!COALineDashStyleArray::get_item`函数对应越界读操作，下面看越界写操作。该操作对应`vgx!COALineDashStyleArray::put_item`函数，其与`get_item`不同之处是调用`vgx!ORG::PGet`函数：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_DJ6TMHK6CUKWQC4.jpg)

 

该函数用于计算写入位置：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_ATJR2MD7QC9KE5Y.jpg)

 

之后写入操作由`put_item`中`mov [eax], ecx`指令完成：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_TUBRTWV7W9T9F9V.jpg)

### 0x02.4 利用分析

#### 0x02.4a 信息泄露

有两种信息泄露方法，详见下文分析。

##### `_anchorRect`属性

访问`_anchorRect`属性时会调用`COAShape::get__anchorRect`函数，而该函数会通过`malloc`申请 0x10 字节空间：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_AQ3GFERTF4XQJFT.jpg)

 

该空间用于存储`COAReturnedPointsForAnchor`对象：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_YNMRRN9G2CKEESZ.jpg)

 

如此一来，可申请大量空间存储`COAReturnedPointsForAnchor`对象，中间放置 Dashstyle Array，之后便可访问后续`COAReturnedPointsForAnchor`对象虚表以获取 VGX.dll 基址。但笔者在进行布局时发现其后并非紧接`COAReturnedPointsForAnchor`对象：

```
for(var i=0; i<0x1000; i++){
    rect_array[i]    = document.createElement("v:shape")
    rect_array[i].id = "rect" + i.toString()
    document.body.appendChild(rect_array[i])
  }
  ....
  for (var i=0; i<0x1000; i++){
    a[i] = document.getElementById("rect" + i.toString())._anchorRect;
    if (i==0x800){
      vml1.dashstyle="1 2 3 4";
    }
  }

```

![](https://bbs.pediy.com/upload/attach/202102/817966_XHN8ZHAC4UWXSAH.jpg)

 

由上图可以看到是`COAShape`对象，其虚表相对于 VGX.dll 基址偏移为`0x82a48`。经计算，读取该地址数组下标为 0x12，故笔者构造信息泄露 POC 如下：

```


 
 INFO LEAK 
 

 
 

 

 

 


```

![](https://bbs.pediy.com/upload/attach/202102/817966_Z6JQWE85PHND2ZA.jpg)

##### `_vgRuntimeStyle`属性

`_vgRuntimeStyle.rotation`对应`COARuntimeStyle::get_rotation`函数，初次访问会申请 0xAC 大小空间 (`COARuntimeStyle::get_rotation`——>`CVMLShape::GetRTSInfo`——>`CParserTag::GetRTSInfo`)：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_ANSZA2UFP9SMCSE.jpg)

 

实际占用空间大小：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_A6XRXMEFHBXUH2R.jpg)

 

那么于其中插入 Dashstyle Array 大小为 0xB0(即 44 个元素，加上头部占用 8 字节，恰为 0xB8)：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_NG5PU4STU99M9BR.jpg)

 

之后写`_vgRuntimeStyle.marginLeft`，对应`COARuntimeStyle::put_marginLeft`函数，由于先前已经申请内存空间，该函数调用`CVMLShape::GetRTSInfo`——>`CParserTag::GetRTSInfo`时便不会再次申请，而是返回内存地址，写入字符位置相对于该地址偏移为 0x58：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_CD98J4XQR5T9V9Y.jpg)

 

而读`_vgRuntimeStyle.marginLeft`，对应`COARuntimeStyle::get_marginLeft`函数，该函数会将偏移 0x58 处指针指向内容读取出来：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_5VASU78S4V89HJJ.jpg)

 

如此一来，控制 0x58 处指针内容，可实现任意地址读取。

 

利用漏洞可读写该地址处内容，下标为 0x2E(0x2B 对应数组最后一个元素，0x2C-0x2E 是头部所占用 12 字节)+0x16(0x58/4)。完整 POC 如下：

```


 
 INFO LEAK 
 

 
 

 

 

 


```

![](https://bbs.pediy.com/upload/attach/202102/817966_KY82EBEU9WRE5V5.jpg)

#### 0x02.4b 劫持 EIP

后续覆盖虚表指针劫持 EIP 部分，可能是由于笔者环境问题，并未完成。重新搭建环境如下：

*   OS 版本：Windows 7 Service Pack 1 x86
*   Internet Explorer 版本：8.0.7601.17514
*   VGX.dll 版本：8.0.7600.16385

该环境下对象布局稍有不同：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_WU7MEMVGFB28FX6.jpg)

 

可以有两种不同的方式覆盖虚表指针。

##### `vgx!COAReturnedPointsForAnchor::vftable`：

![](https://bbs.pediy.com/upload/attach/202102/817966_QPR3W98MZUWN7VN.jpg)

```


 

 


```

##### `vgx!COAShape::vftable`：

![](https://bbs.pediy.com/upload/attach/202102/817966_7GYJ6AYMR5M9YC9.jpg)

```


 

 


```

第一种利用方式若要将栈转移到堆上 (没有找到类似`xchg ecx,esp`直接交换 ECX 与 ESP 的 gadget)，需要再配合两次漏洞进行越界写：

```
 

 

 


```

与之相配合堆上 gadgets 如下：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_U8UPZ4A8QUMZBAH.jpg)

 

而第二种覆盖方式，直接用`xchg eax,esp;ret`这样的 gadget 即可。两种利用方式效果展示：

 

![](https://bbs.pediy.com/upload/attach/202102/817966_TC9PGRT24AGM382.jpg)

0x03 参阅链接
---------

*   [Vector Markup Language (VML)—Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/vml/web-workshop---specs---standards----introduction-to-vector-markup-language--vml-)
*   [Shape Element (VML)—Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/vml/shape-element--vml)
*   [VML Stroke Element—Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-stroke-element)
*   [VML DashStyle Attribute](https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-dashstyle-attribute)
*   [VML 教程—美洲豹](http://www.t086.com/code/vml/index.html)
*   [<meta>—W3school](https://www.w3school.com.cn/tags/tag_meta.asp)
*   VUPEN Blog
*   [Hpasserby Blog](https://hpasserby.top/post/ef2727d8.html)

[[注意] 招人！base 上海，课程运营、市场多个坑位等你投递！](https://bbs.pediy.com/thread-267474.htm)

[#漏洞分析](forum-150-1-153.htm) [#Windows](forum-150-1-160.htm)