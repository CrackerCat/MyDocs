> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.mitchellzakocs.com](https://www.mitchellzakocs.com/blog/vmprotect3)

> Welcome to the second part of my multi-part series on virtualization-based obfuscators. If you didn't......

*   [Introduction](#introduction)
*   [Setup](#setup)
*   [Analysis](#analysis)
    *   [Static Obfuscations](#static-obfuscations)
    *   [Bytecode Location](#bytecode-location)
    *   [Virtual Stack](#virtual-stack)
    *   [Self-Modifying Encryption Key](#self-modifying-encryption-key)
    *   [Fetch, Decrypt, Jump (FDJ) Routine](#fetch-decrypt-jump-fdj-routine)
    *   [Virtual Registers](#virtual-registers)
    *   [Instruction Trace](#instruction-trace)
    *   [Multiple Virtual Machines](#multiple-virtual-machines)
    *   [Lifecycle](#lifecycle)
*   [Comparison Data](#comparison-data)
    *   [General](#general)
    *   [Strengths and Weaknesses](#strengths-and-weaknesses)
*   [Conclusion](#conclusion)

Welcome to the second part of my multi-part series on virtualization-based obfuscators. If you didn't read the first post where I analyzed Tigress, I recommend reading that first as it introduces many concepts that are important for understanding this write-up. There's also a great _Terminology_ section that defines a couple of frequently-used terms. Here's a [link to the post](https://www.mitchellzakocs.com/blog/tigress) if you want it. I've also published all of the IDA databases, binaries, and diagrams from this writeup [here](https://github.com/mzakocs/VirtualizationObfuscatorAnalysis/tree/main/VMProtect%203).

VMProtect is a commercial obfuscator for software protection and is widely considered to be one of the best. While VMProtect does offer a trial version, it applies much simpler obfuscations that are different from the commercial version, so I ended up choosing to reverse the full version of VMProtect. In this write-up, I will be analyzing a simple "Hello World" binary virtualized with VMProtect v3.5.0.1274 (the latest version at the time of writing).

![](https://www.mitchellzakocs.com/blog/vmprotect3/image7.png)

The sample program for VMProtect, hello_world.exe

Even though VMProtect supports all kinds of Windows, Linux, and macOS binaries (and even .NET/C# applications), I decided to just make a simple C "Hello World" Windows application to ease analysis. Inside the VMProtect software, I selected _hello_world.exe_ as my target and started to mess around with the settings. It is required to select the individual functions that you want VMProtect to obfuscate, so I went ahead and added _helloWorld_. I also made sure to only enable virtualization for the binary as I didn't want to deal with mutation. After this, I turned off all of the extra protection such as import protection and packing in the options menu. These extra protections are not the main focus of this write-up and would only hinder our analysis of the virtual machine.

![](https://www.mitchellzakocs.com/blog/vmprotect3/image19.png)

Function obfuscation options for helloWorld

![](https://www.mitchellzakocs.com/blog/vmprotect3/image34.png)

Options selected for hello_world.exe in VMProtect

After this, I pressed the compile button and had my obfuscated binary in seconds. From now on, when I refer to _hello_world.exe_, I will be referring to the VMProtect obfuscated version of the binary.

![](https://www.mitchellzakocs.com/blog/vmprotect3/image9.png)

The *main* Function for hello_world.exe

I put the string _"Main Function"_ inside the source code to be able to quickly locate the main function. By looking at the IDA string view, it took about 3 seconds to find it. Taking a peek at the assembly, it looks fairly normal; I renamed some of the functions to make it easier to read. The _"Main Function"_ string is printed by _printf_, and then the _helloWorld_ function is called. I knew I needed to check in there for any signs of obfuscation.

![](https://www.mitchellzakocs.com/blog/vmprotect3/image4.png)

The obfuscated helloWorld function

After entering the _helloWorld_ function, a couple of isolated jumps led to the code seen above. As you can see, it pushes a seemingly random value onto the stack and then jumps to the VM entry point.

Static Obfuscations
-------------------

![](https://www.mitchellzakocs.com/blog/vmprotect3/deadstore.png)

Dead Store-filled vm_entry (left) vs. De-obfuscated vm_entry (right)

One of the most obnoxious parts about reversing VMProtect is the number of static obfuscations that they apply to the binary. Even with mutation disabled, VMProtect still implements dead store code, opaque branching, jump obfuscation, code duplication, and more to protect the internals of their virtual machine. While some of these are fairly difficult to eliminate without drastic measures, dead store code can be manually replaced with _nop_'s and hidden in IDA. I created an IDA Plugin called [NOPnHIDE](https://github.com/mzakocs/VirtualizationObfuscatorAnalysis/blob/main/ida/plugins/nop_and_hide.py) for this exact purpose. For the rest of the analysis, I will be using this plugin to eliminate dead store code.

Another annoying static obfuscation that is much harder to remove is control flow obfuscation. The most obvious form of this is how VMProtect separates small blocks of code into even smaller blocks of code connected by _jmp_ instructions (opaque branching). This seriously clutters the IDA graph view and makes it much more difficult to analyze. Also, while the general architecture of VMProtect is incredibly hard to analyze in IDA (simply due to the amount of jumps it incorporates), they also use _push+ret_ jump obfuscations to break IDA's control flow graphs. While I won't talk about either of these obfuscations in-depth, just know that they do hinder analysis and are fairly difficult to remove.

Looking back at the de-obfuscated code, the first thing to occur after entering the VM is all of the registers being pushed onto the stack. This is done so that the registers can be restored to their original states after the VM exits.

Bytecode Location
-----------------

![](https://www.mitchellzakocs.com/blog/vmprotect3/image21.png)

Instruction Pointer and Stack Initialization in vm_entry

After the registers are pushed, the value _0x7FF695820000_ is moved into _rcx_ and pushed onto the stack. It seems to be some sort of base address that is used to compute jumps with RVA's. Keep this value in mind as it will have a use on the stack later. A pointer to the virtualized bytecode is also moved into _rsi,_ which is now our instruction pointer for the VM. The pointer is then decrypted by a series of subtraction, negation, addition, and another negation. This transformation sequence is randomized by VMProtect for each different VM. Moving along, the value _0x7FF695820000_ (in _rcx_) and then _0x100000000_ is added to the decrypted pointer. While these seem like random constants at the moment, it does provide us with the decrypted pointer to the bytecode, so something is working 🙂.

Virtual Stack
-------------

Now that the pointer to the bytecode has been decrypted, the current location of the stack is moved into _r10_. After this, _0x180_ bytes are allocated on the stack for the VM. About _0x40_ of these bytes are for the virtual stack and the other _0x140_ bytes are for the virtual register space. The register _r10_ is now our virtual stack pointer since it points to the location underneath the allocated bytes and _rsp_ is now the pointer to the top of the virtual register space. I will describe these structures in greater detail [later](#virtual-registers). Finally, an _and_ operation is performed on _rsp_ which aligns the address to a 16-byte boundary. These operations also show that VMProtect chooses a specific physical register to store pointers to VM context data.

Self-Modifying Encryption Key
-----------------------------

![](https://www.mitchellzakocs.com/blog/vmprotect3/image27.png)

Self-Modifying Encryption Key initialized in r9

Now that the VM has successfully initialized the virtual stack and register space, the current value of _rsi_ gets moved into _r9_ and some seemingly random calculations happen to it. While it may not seem apparent at the moment, this register now stores the self-modifying encryption key. The numerical value that is stored here has no significance, as VMProtect could use any value it wanted as the initial decryption key, but it seems like they decided to use some numbers that were already on hand. We will see how this encryption key gets used in a moment.

Fetch, Decrypt, Jump (FDJ) Routine
----------------------------------

![](https://www.mitchellzakocs.com/blog/vmprotect3/vmprotect_instruction.png)

Representation of the Virtualized Instructions in VMProtect 3

To understand the next section of code, I will quickly explain how a significant portion of the VMProtect 3 architecture works. The most prominent difference between VMProtect and other virtual machines is the fact that it does not use opcodes or a handler table. Instead, it uses an offset that is decoded with the self-modifying decryption key and added to the address of the current handler. This may be slightly hard to visualize, so I'll show the next code segment to hopefully clear things up.

![](https://www.mitchellzakocs.com/blog/vmprotect3/image3.png)

The Fetch, Decrypt, Jump Routine for VMProtect

This routine is the Fetch, Decrypt, Jump routine. I will refer to this routine as FDJ from now on. It is incredibly important and can be found in every single handler in the VM, so pay attention 🙂. It starts by moving the address of the current handler into _rdi_. This address will be used in a while, so just remember that it's there. After this, the bytecode pointer is... _reduced by four_? I was initially confused by this, but after some investigation, it seems that this VM interprets the bytecode backward in memory. I also found that this is randomized by VMProtect, so other VM's it generates may store it normally, but this VM specifically stores it backward. Either way, the bytecode pointer is now pointing to a 4-byte value included with every instruction: the handler jump offset. This value is stored into _ecx_ which marks the start of the decryption sequence.

Now, the self-modifying decryption key stored in _r9_ is _xor'd_ with the encrypted handler jump offset in _ecx_. After this, four random transformations are applied to the handler jump offset. In this case, it is negated, rotated left by one, incremented by one, and then negated again, but these transformations seem to be randomized for each handler. After all of this, the self-modifying encryption key itself (stored in _r9_) is _xor'd_ again with the final decrypted handler jump offset. This is why it is self-modifying: after it finishes decrypting a value, it _xor's_ the decrypted value with itself. While this seems incredibly convoluted, this self-modifying encryption key serves multiple purposes. Starting with the most obvious, it makes reversing the VM incredibly confusing. While this is the ultimate goal of VMProtect, this specific encryption routine had me stumped for a while. Other than that, it also protects the VM bytecode from being modified or hooked in any way as the self-modifying encryption key will be thrown out of order if any instructions are added, modified, or removed. This design from VMProtect is impressive and adds another layer of protection to an already incredibly complex VM.

![](https://www.mitchellzakocs.com/blog/vmprotect3/vmprotect_jump_handler.png)

Pseudo-code representation of the FDJ routine

After the handler jump offset is decrypted, it is added to _rdi._ From the start of the routine, we know that _rdi_ stores the base address of the previous handler. After the handler jump offset is added to the previous handler address, we now have the address of the next handler, which is jumped to immediately. This routine is repeated after every instruction handler until the VM exits

![](https://www.mitchellzakocs.com/blog/vmprotect3/image8.png)

The first handler for the virtualized helloWorld function

Now that we understand the FDJ routine, we can start analyzing some of the actual instruction handlers. The handler pictured above is the very first handler that the virtualized _helloWorld_ function executes after initializing. It starts by moving the value that _r10_ points to into _rbp._ If you remember from earlier, _r10_ is the virtual stack pointer register, meaning this instruction is reading from the virtual stack. After, _r10_ gets increased by _8_, meaning the stack pointer goes _down_ on the stack. These instructions clearly popped a value off the virtual stack. After this, _rsi_ is subtracted by 1 and a byte is moved into _eax._ This is the operand for this instruction. Directly afterward, we can see a very familiar sequence of instructions. First, _al_ (the byte register for _eax_) is _xor'd_ with _r9._ Since _r9_ is the self-modifying encryption key, we can assume that this is a decryption sequence for the operands. The _xor, not, neg,_ and _rol_ instructions afterward are the transformations I talked about earlier. After decrypting the operands, _x9_ is _xor'd_ with _al,_ which again shows the self-modifying nature of the encryption key. As you can see, this encryption key is used in more places than just the handler jump offset decryption; it also decrypts the operands for the instructions.

Virtual Registers
-----------------

![](https://www.mitchellzakocs.com/blog/vmprotect3/stack&register.png)

A diagram of the virtual stack and virtual register space implementation in VMProtect 3

After the operand is decrypted, it is used as an offset for _rsp_ and the value from the virtual stack (_rbp_) is moved into it. It seems like _rsp_ is being used as a virtual register space. Even though the VMProtect architecture is a stack machine, it still has registers for temporary storage, similar to how x86 has a stack even though it's a register-memory machine. Also, even though I have named them virtual registers, there are 40 of them, meaning they can also be used as a temporary data storage space and for local variables.

Going back to the handler, since we know _r10_ points to the virtual stack and _rsp_ is the virtual register space, we can assume that this handler is popping a value off of the virtual stack and putting it into the virtual register space. After it does this, the handler begins the FDJ routine and moves on to the next instruction. Looking at the handler dynamically, it starts to make sense what it is doing in the context of the original function. Since _0x7FF695820000_ (the base address from earlier) was pushed onto the stack right before the virtual stack was defined, it is the value that is now being moved into the virtual register space, specifically at the location _0xB8_. If I had to guess, this base address will likely be used to calculate the address of _printf_ in the future.

Instruction Trace
-----------------

To find that out, I'm going to painstakingly step through all of the instruction handlers and record the purpose of each in the table below. Since there are no opcodes in the VMProtect 3 architecture, it's fairly hard to classify the instruction handlers, but I'll do my best to give each handler a name based on its behavior, list its operands, and write down its location (I'll explain this shortly).

<table><thead><tr><th>#</th><th>Behavior</th><th>Handler Name &amp; Operands</th></tr></thead><tbody><tr><td>0</td><td>VREGISTERS[0xB8] = [VSP] (0x7FF695820000)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>1</td><td>VREGISTERS[0x58] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>2</td><td>VREGISTERS[0xA0] = [VSP] (0x7FF6C5239BC0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>3</td><td>VREGISTERS[0x38] = [VSP] (0xE510467C0ADD0000)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>4</td><td>VREGISTERS[0xB0] = [VSP] (0xFFFFFD7F)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>5</td><td>VREGISTERS[0x30] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>6</td><td>VREGISTERS[0x68] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>7</td><td>VREGISTERS[0x28] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>8</td><td>VREGISTERS[0x10] = [VSP] (0x7FFE431CCF24, ptr to ntdll:NtWriteFile+14)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>9</td><td>VREGISTERS[0x0] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>10</td><td>VREGISTERS[0x80] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>11</td><td>VREGISTERS[0x40] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>12</td><td>VREGISTERS[0x48] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>13</td><td>VREGISTERS[0x18] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>14</td><td>VREGISTERS[0x8] = [VSP] (0xD)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>15</td><td>VREGISTERS[0x60] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>16</td><td>VREGISTERS[0x90] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>17</td><td>VREGISTERS[0x20] = [VSP] (0x7FF6C534330D, return address from vm_entry)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>18</td><td>VREGISTERS[0x78] = [VSP] (0xFFFFFFFF80745CDA)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>19</td><td>VSP -= 0x8<br>[VSP] = 0x140011890<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>20</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF690780000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>21</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF7D0791890)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>22</td><td>VREGISTERS[0xA8] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>23</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF7D0791890)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>24</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>25</td><td>VREGISTERS[0xC8] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>26</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x68] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>27</td><td>VREGISTERS[0xD0] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>28</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x80] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>29</td><td>VREGISTERS[0xD8] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>30</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x40] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>31</td><td>VREGISTERS[0xE0] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>32</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x18] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>33</td><td>VREGISTERS[0xE8] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>34</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x68] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>35</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>36</td><td>VREGISTERS[0xC8] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>37</td><td>VSP -= 0x8<br>[VSP] = 0x140011892<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>38</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF690780000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>39</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF7D0791892)<br>[VSP] = efl (0x246)</td><td>AddStack()</td></tr><tr><td>40</td><td>VREGISTERS[0x70] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>41</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF7D0791892)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>42</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x40] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>43</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>44</td><td>VREGISTERS[0xC8] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>45</td><td>VSP -= 0x8<br>[VSP] = 0x140011893<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>46</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF690780000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>47</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF7D0791893)<br>[VSP] = efl (0x246)</td><td>AddStack()</td></tr><tr><td>48</td><td>VREGISTERS[0x50] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>49</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF7D0791893)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>50</td><td>VSP -= 0x8<br>[VSP] = 0xE8<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>51</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>52</td><td>VSP -= 0x8<br>[VSP] = 0x8<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>53</td><td>[VSP + 8] = [VSP] + [VSP + 8] (dynamic stack addr.)<br>[VSP] = efl (0x246)</td><td>AddStack()</td></tr><tr><td>54</td><td>VREGISTERS[0xA8] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>55</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>56</td><td>VSP -= 0x8<br>[VSP] = 0x10<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>57</td><td>[VSP + 8] = [VSP] + [VSP + 8] (dynamic stack addr.)<br>[VSP] = efl (0x202)</td><td>AddStack()</td></tr><tr><td>58</td><td>VREGISTERS[0xA8] = [VSP] (0x202)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>59</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (0x282)<br>[VSP] = efl (0x282)</td><td>NotThenAnd()</td></tr><tr><td>60</td><td>VREGISTERS[0x98] = [VSP] (0x282)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>61</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0xFFFFFF540B28093F)<br>[VSP] = efl (0x286)</td><td>AddStack()</td></tr><tr><td>62</td><td>VREGISTERS[0x78] = [VSP] (0x286)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>63</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>64</td><td>[VSP] = [[VSP]] (0xFFFFFF03FC42052F)</td><td>ReadMemory()</td></tr><tr><td>65</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (dynamic stack addr.)<br>[VSP] = efl (0x246)</td><td>NotThenAnd()</td></tr><tr><td>66</td><td>VREGISTERS[0x20] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>67</td><td>VSP = [VSP]<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>ChangeVSPToCurrentStackValue()</td></tr><tr><td>68</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>69</td><td>VREGISTERS[0x78] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>70</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x282)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>71</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x78] (0x282)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>72</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (0xFFFFFFFFFFFFFD7D)<br>[VSP] = efl (0x286)</td><td>NotThenAnd()</td></tr><tr><td>73</td><td>VREGISTERS[0x98] = [VSP] (0x286)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>74</td><td>VSP -= 0x8<br>[VSP] = 0xFFFFFFFFFFFFF7EA<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>75</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (0x0)<br>[VSP] = efl (0x246)</td><td>NotThenAnd()</td></tr><tr><td>76</td><td>VREGISTERS[0x88] = [VSP] (0x246)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>77</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x20] (0x202)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>78</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x20] (0x202)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>79</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (0xFFFFFFFFFFFFFDFD)<br>[VSP] = efl (0x282)</td><td>NotThenAnd()</td></tr><tr><td>80</td><td>VREGISTERS[0x50] = [VSP] (0x282)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>81</td><td>VSP -= 0x8<br>[VSP] = 0x815<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>82</td><td>[VSP + 8] = AND(NOT([VSP]), NOT([VSP + 8])) (0x202)<br>[VSP] = efl (0x202)</td><td>NotThenAnd()</td></tr><tr><td>83</td><td>VREGISTERS[0x70] = [VSP] (0x202)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>84</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x206)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>85</td><td>VREGISTERS[0xA8] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>86</td><td>VREGISTERS[0x70] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>87</td><td>VSP -= 0x8<br>[VSP] = 0x14001189A<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>88</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF588180000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>89</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF6C819189A)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>90</td><td>VREGISTERS[0x50] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>91</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF6C819189A)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>92</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>93</td><td>VSP -= 0x8<br>[VSP] = 0x20<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>94</td><td>[VSP + 8] = [VSP] + [VSP + 8] (dynamic stack addr.)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>95</td><td>VREGISTERS[0xA8] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>96</td><td>VREGISTERS[0x78] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>97</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x78] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>98</td><td>VREGISTERS[0xD0] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>99</td><td>VSP -= 0x8<br>[VSP] = 0x14001189F<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>100</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF588180000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>101</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF6C819189F)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>102</td><td>VREGISTERS[0x68] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>103</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF6C819189F)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>104</td><td>QWORD temp = VSP<br>VSP -= 8<br>[VSP] = temp<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVSPToVirtualStack()</td></tr><tr><td>105</td><td>VREGISTERS[0xA8] = [VSP] (dynamic stack addr.)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>106</td><td>VSP -= 0x8<br>[VSP] = 0x1400118A2<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>107</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>108</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF6C81918A2)<br>[VSP] = efl (0x202)</td><td>AddStack()</td></tr><tr><td>109</td><td>VREGISTERS[0x90] = [VSP] (0x202)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>110</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF6C81918A2)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>111</td><td>VSP -= 0x8<br>[VSP] = 0x3A<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack_32(DWORD constant)</td></tr><tr><td>112</td><td>VREGISTERS[0x38] = [VSP] (0x3A)<br>VSP += 0x8</td><td>PopStackToVRegister_32(BYTE vRegisterNumber)</td></tr><tr><td>113</td><td>VSP -= 0x8<br>[VSP] = 0x0<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack_32(DWORD constant)</td></tr><tr><td>114</td><td>VREGISTERS[0x3C] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister_32(BYTE vRegisterNumber)</td></tr><tr><td>115</td><td>VSP -= 0x8<br>[VSP] = 0x1400118A7<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>116</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF588180000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>117</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF6C81918A7)<br>[VSP] = efl (0x202)</td><td>AddStack()</td></tr><tr><td>118</td><td>VREGISTERS[0x98] = [VSP] (0x202)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>119</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF6C81918A7)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>120</td><td>VSP -= 0x8<br>[VSP] = 0xCCCCCCCC<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack_32(DWORD constant)</td></tr><tr><td>121</td><td>VREGISTERS[0x8] = [VSP] (0xCCCCCCCC)<br>VSP += 0x8</td><td>PopStackToVRegister_32(BYTE vRegisterNumber)</td></tr><tr><td>122</td><td>VSP -= 0x8<br>[VSP] = 0x0<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack_32(DWORD constant)</td></tr><tr><td>123</td><td>VREGISTERS[0xC] = [VSP] (0x0)<br>VSP += 0x8</td><td>PopStackToVRegister_32(BYTE vRegisterNumber)</td></tr><tr><td>124</td><td>VSP -= 0x8<br>[VSP] = 0x1400118AC<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>125</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF588180000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>126</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF602BB18AC)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>127</td><td>VREGISTERS[0x90] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>128</td><td>VREGISTERS[0xC0] = [VSP] (0x7FF602BB18AC)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>129</td><td>VSP -= 0x8<br>[VSP] = 0x140123324<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushConstantOntoStack(QWORD constant)</td></tr><tr><td>130</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB8] (0x7FF4C2BA0000)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>131</td><td>[VSP + 8] = [VSP] + [VSP + 8] (0x7FF602CC3324)<br>[VSP] = efl (0x206)</td><td>AddStack()</td></tr><tr><td>132</td><td>VREGISTERS[0x98] = [VSP] (0x206)<br>VSP += 0x8</td><td>PopStackToVRegister(BYTE vRegisterNumber)</td></tr><tr><td>133</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x70] (0x206)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>134</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x60] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>135</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x8] (0xCCCCCCCC)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>136</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x18] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>137</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x48] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>138</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xA8] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>139</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x0] (0x246)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>140</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x10] (0x7FFE431CCF24)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>141</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x28] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>142</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x78] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>143</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x30] (0x0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>144</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xB0] (0xFFFFFD7F)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>145</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x38] (0x3A)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>146</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0xA0] (0x7FF602BB9BC0)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>147</td><td>VSP -= 0x8<br>[VSP] = VREGISTERS[0x58] (dynamic stack addr.)<br>if (VSP &lt; (VREGISTERS + 0x140)):<br>relocateVirtualRegisters()</td><td>PushVRegisterToStack(BYTE vRegisterNumber)</td></tr><tr><td>148</td><td>rsp = VSP<br>popAllRegisters()<br>retn (jmp to 0x7FF602CC3324)</td><td>vmExit()</td></tr></tbody></table>

Keep in mind that there are a lot more virtual instructions than this implemented in VMProtect. This binary was fairly simple so it only used a couple of them, but you now know how to find more yourself. One of the most noticeable things I saw while stepping through the handlers was that there are tons of them doing the exact same thing. For example, the first 10 handlers all contain the same instructions (including the operand decryption transformations) yet their handlers are all in different locations. The handlers are eventually reused, but not immediately. For example, the handlers for _PopStackToVRegister_ start getting reused after 11 cycles, so it seems like whatever algorithm VMProtect uses to generate handlers creates 11 duplicate handlers per behavior (as long as it is used inside of the VM at least 11 times). This is a fairly advanced form of code duplication and helps make the VM much more confusing.

Before I talk about the VM execution as a whole, I want to analyze the behavior of two specific handlers. The first interesting handler is _AddStack_, which seems like a normal handler at first, but it also does something slightly strange. While it does add the two values on the top of the stack, putting the result at _[VSP + 8]_, it also puts the value of the _efi_ register into _[VSP]_. While this was strange at first, it seems to be the only viable way to get the _efi_ register into a virtual register (which is always done through a _PopStackToVRegister_ instruction directly afterward) after the _add_ instruction finishes executing. If this seems confusing, I wouldn't stress about understanding it as it's fairly unimportant and would only matter in cases where the _efi_ register is being utilized in the original assembly.

The other interesting handler I wanted to talk about is _PushConstantOntoStack_. If you look at the pseudo-code behavior that I wrote out for this handler, you may notice a small _if_ check and a function underneath it called _relocateVirtualRegisters._ This isn't actually a function in VMProtect, but I labeled it as one due to the size of the pseudo-code for this routine. In short, it will relocate the virtual registers if the stack starts to become too large. If you recall from the virtual stack & register diagram from [earlier in the write-up](#virtual-registers), the virtual register space sits directly on top of the virtual stack, meaning the virtual stack pointer can eventually enter the virtual register space if the virtual stack grows too large. The check runs anytime a handler pushes a value onto the virtual stack to make sure that this doesn't happen. If the virtual stack does start to intrude upon the virtual register space, the virtual stack will grow by _0x40_ bytes and the virtual register space pointer will be moved up by _0x40_ bytes. After this happens, a _rep movsb_ instruction moves all of the virtual register values into their new space.

Multiple Virtual Machines
-------------------------

Now that we've analyzed some specific parts of the handlers, let's now analyze the VM as a whole. I was originally confused by the instruction trace as there seemed to be no calls to _printf_ or any mention of the _"Hello World"_ string, but I quickly found out why that was. The VM seems to exit whenever it needs to execute an x86 instruction with no virtual handler (such as _rep stosd_) or call a non-virtualized function. While this seems normal at first, it actually enters a brand-new VM when it is finished instead of returning to the same VM. This seems to be done intentionally by VMProtect; I believe that they may have re-entered the same VM in past versions of the virtualizer but changed it to confuse analysts. While this was disheartening at first, I found that the first VM was the largest out of all of them and that the other ones were fairly simple to analyze by just observing the virtual stack and registers as they execute. There is also a clear pattern to when the executable enters and exits the separate VM's so it was quite interesting to analyze.

![](https://www.mitchellzakocs.com/blog/vmprotect3/4-vms-flow.png)

Simplified control flow graph for the 4 VM's in the helloWorld function

All of these VM's have similar entry points, FDJ routines, decryption routines, and instruction handlers that we discussed with the original VM. The only variation that is immediately apparent between the VM's is the registers used for certain context variables inside the VM (VIP, VSP, self-modifying encryption key, etc.) and the direction of the bytecode execution (forward or backward, the original VM was backward). I've made a table below to highlight these differences.

<table><thead><tr><th>VM #</th><th>Virtual Instruction Pointer</th><th>Virtual Stack Pointer</th><th>Virtual Register Pointer</th><th>Self-Modifying Encrypt Key</th><th>Handler Jump Base</th><th>Bytecode Execution Direction</th></tr></thead><tbody><tr><td>1</td><td>rsi</td><td>r10</td><td>rsp</td><td>r9</td><td>rdi</td><td>Backward</td></tr><tr><td>2</td><td>rbp</td><td>r9</td><td>rsp</td><td>rdi</td><td>r11</td><td>Backward</td></tr><tr><td>3</td><td>r11</td><td>rsi</td><td>rsp</td><td>rbx</td><td>rbp</td><td>Backward</td></tr><tr><td>4</td><td>rdi</td><td>rsi</td><td>rsp</td><td>rbp</td><td>rbx</td><td>Forwards</td></tr></tbody></table>

The most interesting concept out of all of this is the bytecode execution direction. While the first 3 VM's all have the strange backward bytecode, the fourth VM increments the virtual instruction pointer and has the instructions forward in memory (similar to Tigress). This confirms that this is randomized by VMProtect, which is fairly impressive on their part. Looking at the register usage, _rsp_ is always used as the virtual register pointer, which makes sense considering how it's allocated. Other than that, it seems to be fairly randomized between the VM's. Any register that is not used for one of the context variables is used as a general-purpose register throughout the handlers.

Lifecycle
---------

![](https://www.mitchellzakocs.com/blog/vmprotect3/single_vm_lifecycle.png)

Lifecycle of an individual VM

Now that we have a general understanding of the four separate VM's, we go back to analyzing the individual VM's themselves. The first thing to happen in all of the VM's is that all of the values on the stack (the physical registers that were all pushed right before we entered the VM) are put into virtual registers. This allows the VM to take in parameters through the registers as if it was a normal function. Using VM_1 as an example, instruction 0 puts a base address for future jump calculations (either to non-virtualized functions or to the next VM) into virtual register _0xB8_. After this, instruction 17 puts the original return value for _vm_entry_ (_main+0x4A_) into virtual register _0x20._ If you remember from the simplified control graph of all the VM's, this value is used inside VM_4 for the final _vmExit_ instruction.

After all of the physical register values are put into virtual registers, we start to get into the actual meat of the VM. This can vary quite heavily between the VM's, but some parts are present in multiple VM's. The first instructions to execute after the virtual register pushes are the fake address calculation instructions. If a VM has to calculate a jump address for the next VM/non-virtualized function/non-virtualized instruction, it will have a couple of these fake address calculations scattered throughout the VM. Using VM_1 as an example, instruction 19 pushes a constant (which is an RVA to some random location) onto the stack. After this, instruction 20 pushes the jump base address (which was put into virtual register _0xB8_ by instruction 0) onto the stack. Then, instruction 21 adds both of these values together while instruction 22 & 23 puts the resulting values into virtual registers. We now have the full jump address inside the virtual register _0xC0_. This register is used throughout _VM_1_ to store these fake address calculations. These addresses are never used once they are calculated and are overwritten shortly afterward by more fake calculations; I believe that this is intentional obfuscation by VMProtect. If we keep following these random address calculations, instructions 129, 130, and 131 follow the same address calculation process yet don't store the address in a virtual register afterward. Instead, it keeps it on the stack and uses it shortly after to jump to the next VM. This is a real jump address calculation and should not be ignored.

Other than the jump address calculations, there aren't many more similarities between the virtual instructions inside the separate VM's. While the fake address calculations aren't the only form of obfuscation/dead-store in the virtualized instructions, the other ones are fairly easy to spot and ignore. Everything else is fairly consistent with the original function code, so let's move on to when the VM exits. Using _VM_1_ as an example, the VM has to push values from the virtual registers back onto the stack before the _vmExit_ instruction is executed (which pops the values off the stack back into their physical registers). This process happens in instructions 133-146, where the VM chooses which virtual registers it wants to restore into the physical registers. Through close analysis of the entry and exit points of the VM, I noticed that there are actually virtual registers that are directly linked with the physical registers. For example, at the entry point of the VM, the value in the physical register _eax_ gets put into the virtual register _0x8_. At the exit point of the VM, the value in the virtual register _0x8_ gets put back into the physical register _eax._ This finding is consistent with all of the physical registers except for _efi_ which receives the value of the virtual register from whenever the last time the _efi_ register was saved (which happens when _AddStack_ or a similar instruction is executed). This finding is interesting because it may ease the process of turning the virtualized bytecode back into x86. Even though some of the virtual registers are directly bound to a physical register, some of them are used for random purposes and temporary data storage, so there is definitely still some translation difficulty. After all of the virtual registers have been put back into their physical registers, a _retn_ instruction is executed and the instruction pointer jumps to the next VM/non-virtualized function/non-virtualized instruction. The entire VM process repeats itself when entering the next VM, meaning the separate VM's can only pass values to each other through the stack and physical registers. This behavior would be very interesting to analyze on larger & more complex functions, but that's for another time.

These charts can be found at the end of each write-up to allow you to easily compare the different the obfuscators I've analyzed.

General
-------

<table><thead><tr><th>🝰</th><th>VMProtect 3</th></tr></thead><tbody><tr><td><strong>Obfuscation Layer</strong></td><td>Compiled Binary</td></tr><tr><td><strong>Architecture Type</strong></td><td>Stack Machine, Randomized Instruction Set</td></tr><tr><td><strong>Context Variables</strong></td><td>Stored in random physical registers. Virtual stack and virtual register space are allocated on the stack. Includes a virtual instruction pointer, a virtual stack pointer, a virtual register space pointer, a self-modifying encryption key, and a base address for handler jumps.</td></tr><tr><td><strong>Dispatch Type</strong></td><td>None, jumps using static offsets from the separate opcode handlers</td></tr><tr><td><strong>Local Variables</strong></td><td>Put into the virtual register space</td></tr><tr><td><strong>Virtual Stack</strong></td><td>Grows negatively like a normal stack, gains an extra 0x40 bytes in size when it hits the virtual register space</td></tr><tr><td><strong>Static Obfuscations</strong></td><td>Dead store code, opaque branching, jump obfuscation, code duplication; fairly easy to overlook</td></tr><tr><td><strong>Bytecode Encryption</strong></td><td>Rolling encryption key that decrypts both the jump handler offset (opcode) and the operands</td></tr><tr><td><strong>External Functions</strong></td><td>Exits the VM, calls the function, enters a new VM with a brand new instruction set and context</td></tr></tbody></table>

Strengths and Weaknesses
------------------------

<table><thead><tr><th>Strengths</th><th>Weaknesses</th></tr></thead><tbody><tr><td>Very Customizable, Simple to Use, Incredibly Unique Architecture, Compatible with Everything, Great Mitigations for Static Virtual Instruction Analysis and Hooking</td><td>Expensive, Weak Static Obfuscations, Simple Instruction Set, Tons of Signatures for Various Components of the VM, Correlation Between Virtual and Physical Registers</td></tr></tbody></table>

In this write-up, we closely analyzed the architecture of the VMProtect virtual machines and virtual instructions. In the future, I'd love to revisit VMProtect by taking a look at the mutation feature and maybe some of the other protections it offers (memory protection, import protection, packing, etc). I also want to take a look at how the software handles more complex programs, conditional statements, and calls to other virtualized functions. Thanks for reading and I hope you learned something about the exceptionally complex virtualization-based obfuscator known as VMProtect.