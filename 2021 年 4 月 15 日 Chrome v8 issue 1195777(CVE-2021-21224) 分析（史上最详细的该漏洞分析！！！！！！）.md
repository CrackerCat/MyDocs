> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-268752.htm)

> 2021 年 4 月 15 日 Chrome v8 issue 1195777(CVE-2021-21224) 分析（史上最详细的该漏洞分析！！！！！！）

**第一部分：写在前面：**
==============

 标题要吓人，才有人来！

 紧跟着前面：

 [https://bbs.pediy.com/thread-267529.htm](https://bbs.pediy.com/thread-267529.htm)

 **环境：**

 Ubuntu 18.04

 turbofan 图表都是在 release 的 v8 下产生的

 命令./d8 poc.js  --allow-natives-syntax --trace-turbo 

1.1：在 v8 执行时，在 poc.js 后面加上 --trace-turbo 执行参数，会产生 turbofan（优化过程各个阶段的处理逻辑）图表。

1.2：分析 turbofan 的图表时，最重要的是找到第一个出现错误的地方。v8 优化的漏洞有一点不同于一般的溢出或 UAF 是，漏洞的根源通常很难在调试器中直接体现出来。不像溢出和 UAF，我们经常可以制造一个崩溃，来体现漏洞发生的直接原因，看 v8 优化的 POC 经常给人一种，怎么地，就溢出了的感觉。究其原因，比较个人感觉合理的解释是其漏洞出现的根源往往是在 v8 工程师自己设计的逻辑层面。

1.2：0xFFFFFFFF 是个什么？或者说 v8 会把他当作什么？

首先我们可以简单排除 v8 把他当成 int64 或 unsigned int64 的可能性。（这样会造成资源上的浪费），可能的解释为一个 int32 数字或一个 unsigned int 32 数字。如果解释为 int32 类型，那么我们打印就会输出 - 1，如果解释为 unsigned int 类型，那么我们打印就会为 4294967295。那到底 v8 会将其解释为什么类型呢，我们可以写个简单的代码验证一下：

var x=0xFFFFFFFF

console.log(x);

       ![](https://bbs.pediy.com/upload/attach/202108/808412_XWW2P59CRGDT25H.jpg)

                                                                      图 1.1.1

显然 v8 把 0xFFFFFFFF 当成了 unsigned int32 的类型。换一句话说 v8 把 0xFFFFFFFF 当成 unsigned int32 才是其规定的合法操作，如果当成了 int32 类型，则会出现前后不一致，会导致出现错误的结果。

这里写的有点啰嗦，主要是这点对理解这个漏洞挺重要。

1.3：v8 优化的过程中往往会会对计算的结果进行预估，成为一个范围，预估的范围本身，会影响到后面优化的过程，我们分析优化的漏洞通常就是分析其预估的范围是否有误，以及对后面优化的影响。

这点有点像那种综艺节目，第一个人看到一个东西，然后口述给第二个人听，然后第二个人口述给第三个人听，以此信息传递下去，中间有一个人理解错误的话，就会导致后面全部人理解错误。

**第二部分：poc 的 turbofan 过程分析。**
=============================

2.1：POC 的简单研究
-------------

原始的 poc1.js

```
  (function(){
      Function foo(b){
   let x=-1;
   if(b)x=0xFFFFFFFF;
   return -1
```

分别输出的是：

 ![](https://bbs.pediy.com/upload/attach/202108/808412_7942JPPQRUNF6KE.jpg)

                                                             图 2.1.1

这里可以看到经过优化后，参数 x=0xFFFFFFFF 的情况下，-1<Math.max(0,x,-1) 的结果为 **false**。和优化之前的结果不一样！

这里把 poc1.js 调整下，以下将其称为 poc2.js：

```
   (function(){
      Function foo(b){
       let x=-1;
       if(b)x=0Xffffffff;
       return Math.max(0,x,-1)
   }
   console.log(foo(true));
   %PrepareFunctionForOptimization(foo);
   console.log(foo(false));
   %PrepareFunctionForOptimization(foo);
   console.log(foo(true));
  })

```

![](https://bbs.pediy.com/upload/attach/202108/808412_VE873ZAFHYJC7BQ.jpg)

                                                                图 2.1.2

从图 2.1.2 可以看到，v8 对 Math.max(0,x,-1) 优化前后计算的**值****都是一样**，那为什么前面 poc1.js 经 v8 优化后的 - 1<Math.max(0,x,-1) 会返回 false 呢？

我们可以推测经过 v8 的优化，在 poc1.js 在运算完 Math.max(0,x,-1) 之后，对其结果 0xFFFFFFFF（4294967295）的解释出现了问题，原本应该解释为 unsigned int32 类型的，结果确解释为 int32 类型。0xFFFFFFFF 如果解释为 int32 的话，结果就会为 - 1，这样的话 - 1<-1，最终结果自然就会变为 false。

2.2：turbofan 图表分析
-----------------

关于 v8 turbofan 图表分析这一块本人也是新手，看别人写的都是直接看几个重要的阶段，本人不是太懂，就用笨一点的方法，把每个图相关过程都看一下。

第一个看到有对结果进行范围判断的是：

**2.2.1：V8.TFTypedLowering 57**

![](https://bbs.pediy.com/upload/attach/202108/808412_YND92A5FCH5B8TE.jpg)

                                                                                            图 2.2.1

图 2.2.1 可以看出

a)：这一阶段的优化初始化过程为**节点** **1****3** 和**节点** **19** 合并产生 **20 节点** **Phi[kRepTagged]Range(-1, 4294967295)** 。

b)： 这一阶段的优化是将 poc.js 中的 Math.max(0,x,-1) 拆分为两个 **NumberMax，**将初始化数值分别与**节点** **31** 的常数 0 和**节点** **13** 的常数 - 1 运算。

      这里并未看出存在什么问题。

**2.2.2：V8.TFLoopPeeling57**

![](https://bbs.pediy.com/upload/attach/202108/808412_MF9K22C8R7XXXD2.jpg)                                                                                                 图 2.2.2

**2.2.3：V8.TFLoadElimination 57**

 **![](https://bbs.pediy.com/upload/attach/202108/808412_FWE79YMUFTBABJT.jpg)**           图 2.2.3

**2.2.4：V8.TFEscapeAnalysis 57**

![](https://bbs.pediy.com/upload/attach/202108/808412_GGRURQQRX85U2Y5.jpg)

                                                                                          图 2.2.4

     以上几个优化过程大同小异，基本和第一个图表没什么区别。

**2.2.5：V8.TFSimplifiedLowering 77**

![](https://bbs.pediy.com/upload/attach/202108/808412_4FYPTTGFJXAK5MD.jpg)

                                                                                                          图 2.2.5

如图 2.2.5：

a)：这个一阶段，初始化将 **74 节点**和 **75 节点**经过 **20 节点 Phi[kRepFloat64]** 运算后得到预估范围为 **Range(-1,4294967295)**，再通过**节点 65**  **ChangeFloat64ToInt64** 运算。

b)：图 2.2.5 中所示在这一阶段将 poc1.js 中的 Math.max(0,x,-1) 拆分为两个 **Int64LessThan**，分别与 **66 节点 Int64** 常数 0 和 **70 节点 Int64** 常数 - 1 运算。这里得到的范围就应该是 **Range(0,4294967295)**

流程到这里，是没有什么问题的，这里的 Int64LessThan 其实只是把 32 位数放入 64 位寄存器计算。

但是紧接进行 **68 节点**的:**Truncation64Int32** 运算，这个节点问题就非常大了，他是把结果进行 **int32 转化**，按照这个逻辑进行推断的话，结果就会从 **Range(0,4294967295)** 变成 **Range(0,-1)**，对原本正确的计算结果进行错误的解释，导致出现了错误的结果。

由此，我们可以推测，这个 Truncation64Int32 节点的生成是这里计算错误根本原因。如果说在这里还不能清晰的说明对返回结果的影响的话，那么翻到后面的 V8.TFLateOptimization 190 阶段就很明显了。

**2.2.6 V8.TFLateOptimization 190**

  ![](https://bbs.pediy.com/upload/attach/202108/808412_J2SXRUMHHFN7P7M.jpg)

                                                                                         图 2.2.6

a)  如图 2.2.6 所示：在这个阶段经过初始化 **20 节点 Phi[kRepFloat64]** 的运算, 结果为 **Range(-1,4294967295)**

b)  在这个阶段 **Math.max(0,x,-1)** 变成分别和**节点 66Int64** 常数 0，**节点 70Int64** 常数 - 1 进行 **Phli[kRepWord64]** 运算，可以推断出其结果为 **(0,4292967295)**。

再经过**节点 68** **TruncateInt64ToInt32** 就会转化为 **int 类型**，结果就为**（0，-1）**，最后和**节点 67** **int32 常数 - 1** 进行**节点 40** **Int32LessThan** 运算（这边用 **Int32LessThan** 可以进一步证明 v8 已经把上面**结果解释为 Int32**），得到的结果就为**（true，false）**，然后做一些常规合法性校验，紧接着就是返回。

 也就是为什么 poc1.js 在优化后当参数 x=0xFFFFFFFF 的情况下，结果得到的计算为 false。

第三部分：exp 核心分析 
==============

```
    function foo(a){
          let x=-1;
          if(a) x=0xFFFFFFFF;
          var arr = new Array(Math.sign(0-Max.max(0,x,-1)));
          arr.shift();
          let local_arr=Array(2);
          local_arr[0] = 5.1;
          let buff = new LeakArrayBuffer(0x1000)
          arr[0]=0x1122;
         return [arr, local_arr, buff];
     }

```

a）根据前面的分析，v8 在优化过程中 Math.max(0,x,-1) 产生了错误，使得结果为（0，-1）。在 Math.sign(0-Math.max(0,x,-1)) 运算后就会变成（0，1），产生了一个意外的 1，使得优化后，如果参数 x=0xFFFFFFFF 的话，arr 的结果就会为 new Array(1)，产生了一个有效数组。

b）然而在 v8 的预估判断中，Math.max(0,x,-1) 结果为（0，0），arr 长度始终为 0，不会是其他的值，为无效数组，所以 arr.shift() 这代码的优化结果就直接在长度的那里减 1，变成 0xFFFFFFFF（在内存中存储的为 - 1*2 为 0xFFFFFFFE），优化后会直接在代表数组长度的内存位置中填入 0xFFFFFFFE，没有别的操作。但是因为此时 arr 为有效数组，结果就产生了一个长度为 0xFFFFFFFF 的数组。（这里的利用手法和 issue 1196683 的利用手法一样）

c) 紧接着申请一个浮点数组和一个 0x1000 的 Buffer，然后用前面的超长数组越界改写浮点数组的长度，用于对对象的地址进行泄露。这里的原 exp 是通过修改 DataView 的相关指针来实现对任意地址的读写，这些都是 v8 漏洞利用的常规套路了，这里不做细究了。不过要注意这里用于写 shellcode 的 Buffer 是 0x1000，shellcode 长度要是超过这个值要重新修改 DataView 的相关指针，不过在情况实际中应用中貌似也不太可能发生......

参考：[https://github.com/r4j0x00/exploits/blob/master/chrome-0day/exploit.js](https://github.com/r4j0x00/exploits/blob/master/chrome-0day/exploit.js)

          [https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html](https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html)

          [https://chromium-review.googlesource.com/c/v8/v8/+/2820971](https://chromium-review.googlesource.com/c/v8/v8/+/2820971)

          [https://www.anquanke.com/post/id/229482](https://www.anquanke.com/post/id/229482)

[[注意] 招人！base 上海，课程运营、市场多个坑位等你投递！](https://bbs.pediy.com/thread-267474.htm)

最后于 1 小时前 被苏啊树编辑 ，原因：

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#Windows](forum-150-1-160.htm) [#Linux](forum-150-1-161.htm)