> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.haboob.sa](https://blog.haboob.sa/blog/cve-2019-13764-from-root-cause-to-bash)

> Overview: Over the past couple of weeks, some of the team members were tasked with researching brow......

**Overview:**

Over the past couple of weeks, some of the team members were tasked with researching browsers. Since Chrome is the most popular browser nowadays, the team decided to jump into Chrome and Chrome exploitation research.

There are quite a lot of resources that can get anyone started with Chrome vulnerability research. In our experience, the best way is to get our hands dirty and jump directly into root-causing a vulnerability followed by an attempt to write an exploit for it.

There has been a lot of noise about JIT bugs, due to the sheer amount of bugs found exploited in the wild. They’re definitely having their fair share nowadays due to the massive complexity of JIT which in turn comes with a price. That said, we decided to go ahead and research JIT bugs and JIT exploitation in general.

So, what’s the best way to get started? Pick a CVE and tear it apart. Root-cause and exploit it. There’s a lot out there, one in particular that we decided to pursue was CVE-2019-13764.

The bug is a Type-Confusion in V8 according to Google’s [bulletin](https://chromereleases.googleblog.com/2019/12/stable-channel-update-for-desktop.html). The root-cause of the vulnerability was unclear from the initial [report](https://bugs.chromium.org/p/chromium/issues/detail?id=1028863). Besides that, there was a reference that a threat actor was trying to exploit it in the [wild](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-exploits.html), which made it more interesting for us to pursue.

**Root Cause:**

With the lack of public information about this vulnerability, the best way to start understanding this vulnerability is by checking the patch commits. Two modifications were made in order to fix this bug, the modifications were made in the following files:

*   Src/compiler/graph-reducer.cc
    
*   Src/compiler/typer.cc
    

Armed with that, we started analyzing the changes made in those files. During the analysis of the typer source, we noticed that at line typer.cc:855 the bug occurs when the induction variable sum -Infinity with +infinity this will result (NaN). Compiler infers (-Infinity; +Infinity) as the induction variable type, while the actual value after the summation will be NaN.

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322021599-GG45YVY1M3CR2KPBWWVZ/TypeInductionVariablePhi.PNG)

Next step was to dynamically look into the bug under the microscope.

**  
Triggering the Bug:**

The bug can be triggered using the following PoC:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627313538586-DIFJH811F6UR6XUYR1VN/triggering+the+bug.PNG)

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627314173905-P5731R6UFWF2OIXS4QAV/gdb+analysis.png)

**Exploitation:**

After a lot of reading and researching about JIT bugs and JIT exploitation, it seemed that exploiting JIT vulnerabilities follow the same methodology:

1.  Trigger the bug and the integer miscalculation to gain R/W using a corrupted array
    
2.  Create _addrof_ and _fakeobj_
    
3.  Getting arbitrary read and write using _addrof_ and _fakeobj_
    
4.  Create RWX page using WebAssembly
    
5.  Leak the address of the RWX page
    
6.  Copy shellcode to RWX page
    
7.  Execute shellcode by calling a Wasm instance method.
    

**Step 1: Triggering the bug and the integer miscalculation.**

The initial trigger was modified to perform a series of operations aimed to transform the type mismatch into an integer miscalculation. We then used the result from the integer miscalculation to create a corrupted array in order to achieve R/W access.

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627314849394-JW7AVPGNXEBVSWRGE5US/trigger.PNG)

**Step 2: Create _addrof_ and _fakeobj_ functions**

The _addrof_ function is a helper function that takes an object as an argument and returns the address in memory of that object. The _addrof_ function uses the corrupted array in order to achieve the arbitrary read.

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627315015652-KEEQ8TM831W05UNZHNB9/Create+addrof+and+fakeobj+functions.PNG)

Using the corrupted array, we change the value from the object map to a float array map:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322656851-TP3EPAXTM8BG6R2RWAN1/corrupted+Array.PNG)

After storing the address, we then restore the map back to its original value:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320032964-OQ9PS0TLP10L6LUV0S5J/restore+original+value.PNG)

The _fakeobj_ function is a helper function that takes an address and uses it to return a fake object. We need to use a float array and store the given memory address at index 0:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322623846-8F17FRNL0PJRTZG39Z9U/store+memory+address.PNG)

Afterwards, the float array map is changed to an array of objects:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322597984-ZA5NNX7L11BFNM2I2MY6/change+array+to+array+of+objects.PNG)

Finally, store the value then return the map back to its original value:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320452390-4ZZQDE3Z030CHFAZHJVW/return+to+original+value.PNG)

**Step 3: Getting arbitrary read and write using _addrof_ and _fakeobj_**

To get arbitrary read we need to create a float array and set index 0 to a float array map as follows:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320548868-L7EG24SI87L4MAGVNLJ6/arbitrary+read+array.PNG)

Now we need to position a _fakeobj_ right on top of our new crafted array with a float array map:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322558854-C8KD2IZKUTM73NFDZL8U/position%2Ba%2Bfakeobj.jpg)

Change the elements pointer using our crafted array to _read_addr_-0x10:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322476814-MDB5XS9VRN330LQ4KU6O/Change+the+pointer+using+crafted+array.PNG)

Index 0 will then return the value at _read_addr_.

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320833505-9P8QLOTNT9N0E6S07L8M/return+index+0.PNG)

To get arbitrary write we will use _arb_rw_arr_ array that we declared before, then we will place a _fakeobj_ right on top of our crafted array with a float array map:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320899145-4MOVTILN699AYP3U1JGV/get+arbitrary+write.PNG)

Then, change the elements pointer using our crafted array to _write_addr_-0x10:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627320972197-73M9E5W98C9SFSZULYTM/change+the+elements+pointer.PNG)

Finally, write at index 0 as a floating-point value:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627321054265-PFXVQGQ2JY5C1ALZJTI5/Write+at+index+0.PNG)

**Step 4: Create RWX page using WebAssembly:**

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627321206489-8AV3DWU357Z673K9ILT0/create+RWX+WebAssembly.PNG)

**Step 5: Copy the shellcode to the RWX page:**

First, we need to locate the RWX page address using the _addrof_ function:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627321569325-Z79IBQFYNB39VKQ5LDZJ/locate+the+RWX.png)

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627321348811-QZKKPIGELRD2N7CH1O7K/RWX+WebAssembly+page+address.PNG)

Then, we create and copy the shellcode:

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627321719674-EUOTCOMYWZR2UBUKCK4G/shellocde.PNG)

Finally, we copy our shellcode to the RWX page

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322309325-JFHP82C6UW6IF23MDN30/copy+shellcode.PNG)

**Step 6: Execute shellcode by calling a Wasm instance method.**

The shellcode execution is achieved by calling a Wasm function.

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627322318967-QHS94U2NSFGX5NV00WEE/executing+bash.PNG)

![](https://images.squarespace-cdn.com/content/v1/60d08f10063a3d3fb6875391/1627367012187-ZHUDA92DZXHEFUUWCAKG/POC+of+executing+bbash.PNG)