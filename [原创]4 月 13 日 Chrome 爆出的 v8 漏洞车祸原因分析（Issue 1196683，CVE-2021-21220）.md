> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-267529.htm)

紧接着前文：https://bbs.pediy.com/thread-267128-1.htm#1687388

这里将前文的 poc.js 命名为 poc1.js，因为这篇文章会有其他该 poc 的简单变种。

poc1.js 为：

```
const _arr = new Uint32Array([2**31]);
function foo() {
    var x = 1; 
       x = (_arr[0] ^ 0) + 1; 
  
       x = Math.abs(x); //前文在这里发现了x计算的错误
       x -= 2147483647;
       x = Math.max(x, 0); 
       x -= 1;//
       if(x==-1) x = 0; 
       var cor = new Array(x);
       cor.shift();//前文这里发现了将-1写进代表长度的内存
       var arr = [1.1, 1.2, 1.3];
  
       return [cor, arr];
}
console.log("ready !!");
for(i=0;i<0x3000;i++)
{
      foo();
}
%SystemBreak();
var x = foo();
var cor=x[0];
var arr=x[1];
%DebugPrint(corr);
%DebugPrint(arr);
console.log("Analyze Over!") ;

```

通过前面对 v8 优化 poc1.js 后生成指令的逆向分析，我们知道要了解这个漏洞的原因可以分解为以下两个问题：

第一：为什么 v8 对 poc1.js 进行优化后生成的指令，对 x 计算会出现错误，使得随后可以获得长度为 1 的有效数组对象 var cor = new Array(x)。(前面文章，我们通过逆向分析 v8 对 poc1.js 进行优化后生成的指令的过程，是在 x = Math.abs(x); 这一条代码语句对应的指令执行中发现了 x 计算错误)。

第二：为什么在 v8 对 poc1.js 进行优化后, 数组对象 cor.shift() 操作后会直接写入 0xFFFFFFFE 到代表其数组对象长度的内存位置。

**写在前面：**

1：v8 优化的漏洞利用的核心就是获得可以越界读写的数组。

2：v8 优化的漏洞不能直接通过二进制逆向分析寻找漏洞的真正原因，是因为最后能调试的指令只是优化的结果生成的指令，而不是优化的本身，优化的本身是如何生成这些优化指令。所幸 google 提供了 turbofan 工具来分析 v8 优化的各个过程。

3：v8 运行 poc1.js 加上参数 --trace-turbo 会生成一个.json 文件的，这个.json 文件会记录优化的各个阶段，我们使用 turbofan 工具时打开该.json 文件时，看到的图表只会显示某个优化过程的部分节点。

我们可以先找到显示的要分析的目标节点附近节点，再一步步追踪到我们需要关注的节点 (如图 1.1.1 和 1.1.2 操作)。用这操作可以用 turbofan 分析每个优化阶段的详细过程。

       ![](https://bbs.pediy.com/upload/attach/202105/808412_HA2RTEWBMVKYDW5.jpg) 

                                                                                图 1.1.1

      ![](https://bbs.pediy.com/upload/attach/202105/808412_CPBUTPVD4XWF9MW.jpg)

                                                                             图 1.1.2

**第一部分，模拟正确** JIT **优化过程**：

既然是车祸原因分析嘛，就先来个简单车祸现场模拟。

如果对计算机和 v8 符号数的处理机制，以及 x64 汇编指令有足够的了解的话，可以直接定位错误的位置，这一步可以省略应该，但本人对这些知识不太熟悉，因此用自己的思路解决问题。

这里主要的方式是通过对构造相似的 js 代码，模拟 v8 正确优化 poc1.js 的情况下生成指令，然后对该指令进行逆向分析。

**1.1：v8 优化错误的指令定位**：

车祸分析，最开始的是确定在那个路口出现问题。

在前面动态调试之中，我们是因为在 v8 在对 poc1.js 优化后的，其语句 x = Math.abs(x); 对应的指令执行时，返回了其参数自身，从而发现其是将参数处理产生错误的。

![](https://bbs.pediy.com/upload/attach/202105/808412_JM5TUUTNYEAVQ73.jpg)

                                                                              图 1.1.3

如图 1.1.3 所示的 ecx=0x80000001。

这里是我们发现错误的位置，但这不代表这就是错误的开始位置。

这里列举 2 个可以想到的原因：

              a)：v8 在 poc1.js 优化后，执行 x = Math.abs(x) 这一句代码对应的指令之前的部分就已经把他作为无符号数处理了，也就是这句代码的前一句，x = (_arr[0] ^ 0) + 1 这句生成的对应的指令就已经是错误的，在往前就没有有代码了。

       b)：v8 在 poc1.js 优化后，生成的 x = Math.abs(x) 这一句代码对应的指令是错误的。

**1.2：****模拟 v8 正确的优化**：

  接下来是对错误指令位置的验证：

  这里采用的参照的方法 

  猜测 poc1.js 错误的优化和使用 0 这个自然数有关， 因此可以尝试将常数 0 用一个 Uint32Array 变量来存储，让 (_arr[0] ^ 0) +1 这句代码得到 v8 正确优化。(也可以尝试别的办法)

因此这里简单修改 poc1.js 构造 poc2.js，获得正确优化情况下的指令：

```
const _arr = new Uint32Array([2**31]);
const _arr_0 = new Uint32Array([0]);
function foo() {
    var x = 1; 
       x = (_arr[0] ^ _arr_0[0]) + 1; 
       x = Math.abs(x); 
       x -= 2147483647;
       x = Math.max(x, 0); 
       x -= 1;//
       if(x==-1) x = 0; 
       var cor = new Array(x);
       cor.shift();
       var arr = [1.1, 1.2, 1.3];
  
       return [cor, arr];
}
console.log("ready !!");
for(i=0;i<0x3000;i++)
{
      foo();
}
%SystemBreak();
var x = foo();
var cor =x[0];
var arr=x[1];
%DebugPrint(corr);
%DebugPrint(arr);
console.log("Analyze Over!")

```

v8 对 poc2.js 优化后  x = (_arr[0] ^ _arr_0[0]) + 1; 这一句代码对应的指令如下图所示：                                                       

![](https://bbs.pediy.com/upload/attach/202105/808412_DRHK3A7HG2GM34T.jpg)

                                                                                 图 1.2.1

![](https://bbs.pediy.com/upload/attach/202105/808412_AJQBPTB5ZUC4THU.jpg)

                                                                                图 1.2.2

如图 1.2.2 所示，v8 对 poc2.js 进行优化以后，代码 x = (_arr[0] ^ _arr_0[0]) + 1; 这一句代码生成的对应的指令为：

xor ecx, dword ptr ds:[rdi]

**movsxd** rcx, ecx

add rcx,1

这里我们发现 v8（可能是 x64 架构的别的软件也这么处理）将有符号 32 位数转移到 64 位寄存器中，正确的处理指令为 **movsxd**。

处理结果为：FFFFFFFF80000000，带有符号扩展，然后再 add rcx,1，这样是得到的正确的结果，我们推测这个是 v8 期望的优化处理结果。

而在 v8 在优化 poc1.js 后，生成的 x = (_arr[0] ^ 0) + 1; 这句 js 对应的指令如下：

![](https://bbs.pediy.com/upload/attach/202105/808412_HA3P498C7FX3VJJ.jpg)

                                                                                  图 1.2.3

如图 1.2.3 所示：

生成的指令为

mov ecx, dword ptr ds:[rcx]

       add rcx, 1

这里直接把_arr[0] ^ 0 优化为一个值，然后传递值是采用了 **mov** 这个无符号扩展指令，也没有其他的任何符号处理措施，就进行将 32 位数 ecx 扩展为 64 位 rcx 进行接下来的 add rcx,1 操作。

![](https://bbs.pediy.com/upload/attach/202105/808412_V8B4DNPWTYHNNFY.jpg)

                                                                          图 1.2.4

在这里我们发现车祸真正开始出现问题的路口了。

v8 优化 poc1.js 后，生成的 x = (_arr[0] ^ 0) + 1; 这句代码对应生成的指令是将的_arr[0]^0 优化为固定的结果放入内存中，但取出来进行接下来的操作时出现了问题。这里在传递过程中没有对符号位进行处理就直接进入接下来 add rcx, 1 运算，导致结果错误出现错误。

换句话说在 poc1.js 的优化中，v8 应该采用 movsxd 这样带有符号扩展的传值指令，而不是使用无符号扩展的 mov 指令，这是导致我们看到的，在绝对值操作之后产生错误数值的根本原因。

但是为什么会这样呢，为什么 v8 优化 poc1.js 时对 x = (_arr[0] ^ 0) + 1; 这句代码的_arr[0]^0 结果从 32 位扩展为 64 位时，选择错误的 mov 指令，而不是使用正确的 movsxd 来传递数据呢？这像是探索出现车祸背后的交通规则设计的缺陷。

单靠逆向优化后的指令是无法知晓这个问题的答案的。这里就要就要借助 google 提供的 turbofan，对优化的重要阶段进行分析；  

**第二部分：对 poc1.js 优化过程的 turbofan 进行分析：**

这里对 poc1.js 进行简单的修改，tubofan 分析变得简单一点，这里将这新文件命名为 poc3.js。

```
const _arr = new Uint32Array([2**31]);
function foo() {
    var x = 1; 
       x = (_arr[0] ^ 0) + 1; 
  
       x = Math.abs(x); 
       x -= 2147483647;
       x = Math.max(x, 0); 
       x -= 1;//
       if(x==-1) x = 0; 
       var cor = new Array(x);
       cor.shift();
       return cor;
}
for(i=0;i<0x3000;i++)
{
      foo();
}
var cor = foo();
console.log(cor.length);

```

**2.1：TFTyper 阶段分析**

2.1.1：在我这环境中用 turbofan 查看 v8 生成的.json 文件是顺着 **70:Branch[None, NoSafetyCheck]** 节点往上看，可以找到 v8 优化后的 poc1.js 中 x = (_arr[0] ^ 0) + 1; 这句代码对应的所有节点。(不同环境可能会不同)

![](https://bbs.pediy.com/upload/attach/202105/808412_DM9ESRS9JMNW2NE.jpg)

                                                                          图 2.1.1

接着我们从 return 节点往上找

![](https://bbs.pediy.com/upload/attach/202105/808412_8XUHBJYWBHKS4M5.jpg)

                                                                       图 2.1.2                 

2.1.2：图 2.1.2 中的 **162: StoreField[+12]** 该节点为重要节点，是 cor.shift() 这句代码优化的重要部分,StoreField[+12] 也就是偏移 12 的位置存放数值，根据对这图表的分析可以知道这节点代表的是往 cor 数组对象的 +12 的位置存放数据，而这个内存位置代表的正是数组的长度。

我们需要的是知道是后面阶段是如何优化的，最后为什么会直接写进 0xFFFFFFFE 这个数值。

![](https://bbs.pediy.com/upload/attach/202105/808412_EC7GTMEABQY43EB.jpg)

                                                                      图 2.1.3

2.1.3：从图 2.1.4 可以看出，v8 优化 poc3.js 的这个阶段过程是，18:Branch[false,safeCheck] 判断为 ifFalse 时就会进入 85:JSCreateArray 阶段，由于 Call[Code:ArrayShift] 然后会有 162:StoreField[+12] 操作。

也就是说 cor.shift() 这句的优化过程是先会先创建一个数组对象，然后用 StoreField[+12] 这个操作对数组大小的内存进行填充改写。

![](https://bbs.pediy.com/upload/attach/202105/808412_2NTYGEMZXDFHYSP.jpg)

                                           图 2.1.4

如图 2.1.4 所示，162:StoreField[+12] 填充数据为 161:NumberSubtract 运算结果，其输入节点为为 136:LoadField[+12]，13:NumberConstant[1]。

也就是说在 StoreField[+12] 这个节点的操作，**是取出原来内存的值再减 1 然后就直接 return 返回了**。

       ![](https://bbs.pediy.com/upload/attach/202105/808412_X39PJ2QXYMM3GWJ.jpg)

                                                图 2.1.5

如图 2.1.5 所示：**163:StoreElement 到 97:Return 之间没有再进行数组合法性检查**。

**2.2：TFSimplifiedLoweringPhase 阶段分析**

![](https://bbs.pediy.com/upload/attach/202105/808412_35V5GNPK5WSPPP9.jpg)

                                                                               图 2.2.1

    v8 在这个阶段的优化中对 poc1.js 的 x = (_arr[0] ^ 0)+1; 这句代码的优化，如图 2.2.1 所示，比上个阶段多插入了一个 ChangeIn32ToInt64，也就是将_arr[0]^0 结果扩展到 64 位，然后进行 +1 操作，接着进行 Float64Abs 绝对值计算。

   ![](https://bbs.pediy.com/upload/attach/202105/808412_29KBKUPRXYDP67N.jpg)

                                                                    图 2.2.2

v8 在这个阶段的优化中对 poc3.js 中 cor.shift() 这句代码的优化，如图 2.2.2 所示，这里可以看到，后面已经直接将 -2(0xFFFFFFFE) 通过 162: StoreField[+12] 写进了数组代表其长度的内存中了。

**在这里可以回答开篇的第二个问题了：**

即：为什么在 v8 对 poc1.js 进行优化后, 数组对象 cor.shift() 操作后会直接写入 0xFFFFFFFE 到代表其数组对象长度的内存位置

因为在 v8 运行 poc1.js 的过程中一直反复生成长度为 0 的数组对象 cor，因此在这个优化阶段，v8 已经认为 cor 的数组一定是无效数组对象，因为认定 cor 为 0，cor.shift() 就将原本长度为 0 的数值再减 1，结果就是 - 1 这个固定的值。在优化后就直接将 0xFFFFFFFE 这个值写进代表数组长度的内存。因为已经认定 cor 数组是不合法，所以直到返回也没有再进行数组合法性的检查。

也就是说从这个阶段以后，无论前面数组 cor 怎么变，这个数组的长度都会被判定为 0xFFFFFFFFF。这时候如果我们 cor 合法，我们就可以得到一个大小为 0xFFFFFFFFF(内存中的数值 0xFFFFFFFFE 除以 2) 的数组。

**2.3：TFEarlyOptimization 阶段**

 ![](https://bbs.pediy.com/upload/attach/202105/808412_M2G6DE9TFDWXQVY.jpg)

                                                                                  图 2.3.1

 v8 在这个阶段的优化中对 poc1.js 的 x = (_arr[0] ^ 0)+1; 这句代码的优化，如图 2.3.1 所示，已经直接跳过了_arr[0]^0 这个操作，变成直接取_arr[0]，这两个结果数值虽然相同，**但这里有个隐含的变化，****_arr[0]^0** **的结果为 Int32 类型，而我们申请的****_arr[0]** **为 UInt32 类型**。

然后经过 206：ChangeInt32ToInt64，扩展为 64 位再进行 +1 操作。

![](https://bbs.pediy.com/upload/attach/202105/808412_WHQRA9JHDB8U36V.jpg)

                                                                                 图 2.3.2

v8 在这个阶段的优化中对 poc3.js 中 cor.shift() 的处理，如图 2.3.2 所示，和上一个阶段相比没有什么变化，后面的阶段也没再发生什么变化。

在接下来的阶段，对 poc3.js 这两句我们最关心的这两句 js 代码的优化都没发生什么变化，因此这个 ChangeInt32ToInt64 处理过程就很可能就是漏洞关键。

**这里我们已经知道开篇提到的第二个问题的答案，现在要知道第一个问题的答案，也就是为什么选择了** **mov** **指令传递数据。**

**这里的问题似乎是发生在 ChangeInt32ToInt64 这个处理节点上。(通过前面分析我们知道了经过优化后其输入为_arr[0], 是一个 UInt32 类型)**

这个 ChangeInt32ToInt64 处理过程也就是我们需要研究的导致车祸的具体规章流程。

**第三部分：对 ChangeInt32ToInt64 的探索**

3.1 查找 ChangeInt32ToInt64 的函数实现：

![](https://bbs.pediy.com/upload/attach/202105/808412_2BVBG7PT5GSM9VA.jpg)

                                                                            图 3.1.1

如图 3.1.1，我们可以借助 Windbg 符号查找的功能，可以看到所有的 ChangeInt32ToInt64 相关的符号。后面的 4，6，8，9 断点按英文意思判断是对节点判断的函数，不是我们关心的，把这几个断点排除，接下来利用命名空间和调试可以判断 VisitChangeInt32ToInt64 是选择指令的函数，也是我们需要分析的 ChangeInt32ToInt64 的实现。

**3.2 对** **VisitChangeInt32ToInt64 的研究分析：**

WinDbg 在这里断点指向了源码的

void InstructionSelector::VisitChangeUint32ToUint64(Node* node) 是有点问题的

![](https://bbs.pediy.com/upload/attach/202105/808412_DX3AXRPJMAXWCBQ.jpg)

                                                                    图 3.2.1

3.2.1：由于看这里指令跳转分析源代码会很乱，无法直接借助 WinDbg 分析代码的执行流程，因此接下来我们使用 IDA 和 x64debug 来定位代码执行流程。

用 IDA 代开 v8 查看 void InstructionSelector::VisitChangeInt32ToInt64(Node* node)

![](https://bbs.pediy.com/upload/attach/202105/808412_7GDZ2AGUAXGHS2D.jpg)

                                                                        图 3.2.2

3.2.2：这里用 x64debug 运行可以看到程序进入的判断：

![](https://bbs.pediy.com/upload/attach/202105/808412_E647CQ77NPXGNZS.jpg)

                                                                    图 3.2.2

这里也就是我们源代码中的图 3.2.3 所在蓝色标注的位置：

![](https://bbs.pediy.com/upload/attach/202105/808412_EASHKTJQH785YGR.jpg)

                                                                  图 3.2.3

**3.2.3**：如图 3.2.3 代码所示，因为通过优化以后，我们传递进去的类型为 UInt32，所以这里

opCode =load_rep.IsSigned()？kX64Movsxlq:kX64Movl; 会返回的是无符号扩展传送指令 kX64Movl，而不是 kX64Movsxlq，也就是最终会选择了 mov 指令，而不是 movsxd 指令。

**第四部分：漏洞原因总结：**

对开篇问题的回答：

第一：为什么 v8 对 poc1.js 进行优化后生成的指令，对 x 计算会出现错误，使得随后可以获得长度为 1 的有效数组对象 var cor = new Array(x)。

这是因为 v8 优化 poc1.js 过程中，会将 x = (_arr[0] ^ 0) + 1; 这句代码的_arr[0]^0 优化为_arr[0]，将这里产生的结果从 Int32 有符号 32 位整型改变为 Uint32 无符号 32 位整型，然后在接下来的运算之中要扩展为 64 位，然后进行 + 1 操作。

在这里优化过程扩展为 64 位的指令选择是通过

void InstructionSelector::VisitChangeInt32ToInt64(Node* node) 这个函数来判断的，

而这个函数输入的 node 节点如果为 Signed 类型，则返回 movsxd 这个有符号扩展的指令，如果为 Unsigned 类型，则返回 mov 这个无符号扩展的指令。因为_arr[0] 为 UInt32 类型，所以最后返回了 mov 这个无符号扩展的指令作为扩展到 64 位的操作符，变得没有在扩展过程中对符号有进行任何处理，导致接下来计算错误，最后导致 x=1，结果是生成有效的数组。

第二：为什么优化后, 在数组对象 cor.shift() 操作后会直接写入 0xFFFFFFFE 到其数组对象的长度的内存位置。

因为在 v8 运行 poc1.js 的过程中一直反复生成长度为 0 的数组对象 cor，因此优化阶段时，v8 已经认为 cor 的数组一定是无效数组对象，因为认为 cor 一定为 0，cor.shift() 就将原本长度为 0 的数值再减 1，结果为 -1 这个固定的值。在优化后直接将 0xFFFFFFFE 这个值写进代表数组长度的内存。因为已经认定 cor 数组是不合法，所以直到返回也没有再进行数组合法性的检查。

当我们意外生成一个有效的 cor 数组时，实际上就拥有了长度为 0xFFFFFFFF 的数组。

这就是这个漏洞产生的根本原因。

 _参考：_

        [https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/](https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/)

        [https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html#rca-of-issue-1196683](https://iamelli0t.github.io/2021/04/20/Chromium-Issue-1196683-1195777.html#rca-of-issue-1196683)

[第五届安全开发者峰会（SDC 2021）议题征集正式开启！](https://bbs.pediy.com/thread-266645.htm)

最后于 38 分钟前 被苏啊树编辑 ，原因：