> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Wg7G0vZXlx16ntoL84q65w)

本文作者  Strawberry @ QAX A-TEAM

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

CVE-2016-0010 为 Office 堆溢出漏洞，该漏洞允许攻击者通过精心构造的文档在当前用户上下文中执行任意代码。本文参考 Kai Lu 于 16 年发布的 Deep Analysis of CVE-2016-0010 - Microsoft Office RTF File Handling Heap Overflow Vulnerability 文章，对该漏洞进行再次分析。如有错误，欢迎批评指正。

![](https://mmbiz.qpic.cn/mmbiz_gif/EkibxOB3fs4icwQQAZE6MBepadE7zAutkviaEmicgZWqGCPAvRDxD3EhVvrLJQckeqTGqC7Hmc08MTUxXeaMq5pVXw/640?wx_fmt=gif)

声明：本篇文章由 Strawberry@ QAX A-TEAM 原创，仅用于技术研究，不恰当使用会造成危害，严禁违法使用 ，否则后果自负。

QAX A-TEAM

**漏洞介绍：**
---------

下图为 CVE-2016-0010 的漏洞公告，Office2007 SP3、Office 2010 SP2、Office2013 SP1、Office 2016、Excel forMac 2011、PowerPoint for Mac 2011、Word for Mac 2011、Excel 2016 for Mac、PowerPoint 2016 for Mac、Word 2016 for Mac 以及 Word Viewer 允许攻击者通过精心构造的文档在当前用户上下文中执行任意代码，该漏洞也被称为 Microsoft Office 内存损坏漏洞。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyOYAPuR3iaa9DjL5wgOMvMSRHSsFxXict0ibKoPia8nicNpvee2TmfGyArMQ/640?wx_fmt=png)

**分析环境：**
---------

操作系统：Windows 10

测试软件：Word 2013 SP1

样本：触发堆溢出的 POC

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlywib25CHQo1wNUyLUx1Hmyhh0gy35nMzB1UjScOVFjrSmeXvfWkOcibhg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyjAiaibvm7mOcB1oV6s9Z1GrZUbyRg2UXmhbbrfUvrzFmaF59iaAKJKW6w/640?wx_fmt=png)

**漏洞分析及复现：**
------------

根据这篇文章，我们可以知道该漏洞存在于程序对 RTF 文件的 pict 结构的处理流程中，下图为针对该漏洞的一个典型的 pict 结构样本，由 \ dibitmap0 控制字可知，该样本中嵌入了一个 BMP 文件。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyrK4OgD5icL8mbibcPweAsBcvLeSphgj9Yrd0nao1uRjBFeA5FribmG5pg/640?wx_fmt=png)

首先我们使用 Windows 自带的画图创建一个图片并将其另存为 BMP 文件，然后使用 010editor 对其进行解析。BMP 文件由文件头、信息头、颜色表和颜色点阵数据组成。如下图所示，BMP 文件以‘BM’标记开头，后面是 4 字节的 BMP 文件长度，后面四个字节是两个保留字默认为 0，最后是 4 字节的颜色点阵数据偏移（这里是 0x36）。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyMWnty61S90Lu72TPWnylHAY6pavzfaJvUQnpEeGCuTt9yV5ZaPEprA/640?wx_fmt=png)

中间蓝色部分是 BMP 信息头结构，和样本中的数据相吻合，是我们学习的重点。首先，前四个字节指明本信息头的长度（一般均为 0x28），后面依次是位图宽度（这里为 71）、位图高度（这里为 100）、位图平面数（一般为 1）、每个像素的位数（这里为 24）、压缩方式（0 表示没有压缩）、颜色点阵数据所占用的字节数（这里为 21600）、水平分辨率、垂直分辨率、位图使用的颜色数（0 表示颜色数为![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlysRwFHFmH0kqMTxGxUft7dWImycRicM9cLyV439KtY3UEhypAhqGwnicg/640?wx_fmt=png)）以及重要的颜色数（0 表示所有颜色都重要）。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyCS299YoxP10DcEPzlicGQfHkkXp13ph8lcmNO5MDIz9gvxrib1N1b9gg/640?wx_fmt=png)

由于 24 位位图没有颜色表，所以信息头后面直接跟颜色点阵数据，这里不再探讨。下面我们再来看样本中的 BMP 信息头结构（如上图所示），值得注意的是，该结构中的位图宽度为 0xC000004（即 201,326,596）。

下面进一步分析该漏洞，使用 WinDbg 附加 Word 进程并运行，然后在 Word 中打开样本。下图为崩溃现场，我们可以看到程序在读取 RSI 指向的数据时产生异常，0x1ea5c671000 处设置了不可访问页

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlytOTQvwvwVfLUfRibxku5qFrlw9owsiaDtCciaAdVJ43tWWl0rjeXIRoaQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyX3uSczN5u0Y6T8b8N1J8oOxqr3Tm8QKUPCFIkBJy8gnibQbWbMycZhQ/640?wx_fmt=png)

通过函数调用堆栈，定位到 mso!Ordinal1236 函数，根据 mso.dll 的加载基址和崩溃点地址得到偏移，在 IDA 中定位到崩溃代码，查看 mso!Ordinal1236 函数伪代码

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyMiaawUKWazoE1fbqpib3ZTmGyVP7fPUOz18tzLpMekSVZ9M9ia0KyiaKqw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyGQ9XetibaG5RmbqH3BWhAmoku10vqOajCvCyZlgxOHxEicYj39xfdxHA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly0AD3nia5ORzv51ibad8tA58h6rTSa58FDfPkNe5geuKwQdeCibr6PgoMg/640?wx_fmt=png)

漏洞触发代码为 “*v28 = v29;”，由于 v28 指向不可访问的内存却要向其赋值而产生异常，v28 来自 v9，而 v9 主要来自 v7（可以看出 v8 是个偏移值而不是指针）。最终指向 v5，而 v5 和 MSO_737 函数相关。重新运行程序并附加，在 mso!Ordinal737 下条件断点，当其第三个参数为 0x28 时断下，运行至返回发现该函数新开辟了一个堆，大小为 0x28，这个堆就是 v5 指向的堆。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyezSEuWc3KRzfiafH6YltlCYSLslSfxerP4hLzYCppibU2PJh1YP523jw/640?wx_fmt=png)

查看 mso!Ordinal737 函数伪代码，发现它首先计算了 a1*a2+a3+a4，即 0*4+0x28+0（结果为 0x28），然后将其作为参数传递给 mso!Ordinal712 函数，根据结果可以推测在这个函数中开辟了一个大小为 0x28 字节的堆。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlycKvDfNIicia3WeTN31bygpicKo1AAG87KJsxFU31DaosSmSLOkS791ufA/640?wx_fmt=png)

由于 mso!Ordinal6017+0x210 函数的第一个参数为 v6，所以跟进去看一下，该函数的第二个参数指向了 BMP 信息头结构，单步跟踪发现这个函数就是将 BMP 信息头结构（0x28 字节）复制到前面开辟的堆中（v6 指向的堆）。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyCSlpgy5IrQNlVnvWFiaEB3LkjAqZ9KQ3RN1GfkRkmtUiahufdrHOPviaQ/640?wx_fmt=png)  

mso!Ordinal6017+0x210 函数的第二个参数 & Dst 最早作为 memcpy 函数的第二个参数，如下图所示。因而此时 RDX 所指向的数据来源于 v12，v12 来自 mso!Ordinal1236 函数的第三个参数 a3，可以推测 a3 指向的内存区域也保存了 BMP 信息头结构。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyWShQK5CJeiaQYvSSic6BAaJfSy9oXgYeNEq4Z9QhI5OWmgykicwDjYd6w/640?wx_fmt=png)

然后会去调用 memcpy 函数，在向新开辟的堆复制完 40 字节之后继续复制 v8 字节。令人震惊的是，内存复制的长度 v8 居然为 0，由于 v8 = 4*v15，而 v15 在 mso!Ordinal737 函数调用的时候已经为 0，这可能是一个值得关注的点。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyTu4Tq7NysUBaH0lSy3ZGpgbweuINCc5X5gelwtljeoNia8ib0SXvqRibw/640?wx_fmt=png)

然后判断 BMP 信息头偏移 14 处是否为 0x20，表示 32 位位图，然后调用 mso!Ordinal1236+0x144 函数，并计算其返回值减去 3 * 位图宽度得到一个后续要用的值（这个值在触发漏洞的时候还没有被用到）。  

下图为后续流程，根据静态分析可知 v40 为位图高度（这里为 1），v39 为位图宽度（这里为 0xC000004），因而 v23 等于 0，满足判断条件。后面进入 do-while 循环，结束条件为 v25 大于等于 v39，v25 为一个从 0 开始累加的数，v39 为 0xC000004，每次循环会处理原始 BMP 信息头的 4 个字节，将 v13 处的数据处理并复制到 v9 处，v9 = (char *)v7 + v8（此时 v8 为 0），就是将数据复制到新开辟的堆中，然而那个堆的大小只有 0x28 个字节。因而只要继续复制就会产生溢出，最终程序会由于内存不可访问而触发异常。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyZVebMupia5PNibZWt1DvdzmepxaChKOicGLFt1OZTcfrEibaxarCiaqykZA/640?wx_fmt=png)

在本次调试中，程序崩溃在如下图所示的位置，也就是上图 v26 = *v13 的位置，此时 v13 指向的内存不可访问。EDX 对应了上图的 v25，EAX 为 v39。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyRBicqvwvTjLDnh0N4XJYZfz7hPoS9FyibuGeI3wmCicNVH3XuwcRyhuWw/640?wx_fmt=png)

根据此时 EDX、RSI、RDI 的值可以推算出循环开始时的 v9 和 v13，如下图所示，v9 为 0x244947a7948，也就是新开辟堆的 0x28 偏移处，通过静态分析可知，v13 来自 mso!Ordinal1236 函数的第二个参数。

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly37l6OvH0AyVKXPcWm3naeqmtZCsicbWbWGp3MsWofesKgqAVenr0TTw/640?wx_fmt=png)

下图为复制操作后 v9 和 v13 指向的内存数据，可见该流程并不是将 v13 指向的数据直接复制到 v9 处，而是每取四个字节复制前三个字节过去，下图标记了一些明显的数据。如果这个 do-while 循环执行成功，将向 v9 处复制 0xC000004*3（0x2400000c）字节的数据。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyv9ic9TeMVVyeaXiclWvuKjMibqCTSZ5M6kZ2LEOJ9qqhd9XLIClTZJlicg/640?wx_fmt=png)

我们现在可以知道，该漏洞是由于设置了过大的位图宽度，导致程序向一个 0x28 字节的堆中尝试复制 0x28+3 * 位图宽度字节的数据导致溢出，那又出现另一个疑问，位图宽度那么大，为什么却只开辟了 0x28 字节的堆。前面在分析 mso!Ordinal737 函数的时候通过计算 v15*4+0x28+v19 得到了 0x28，然后开辟了 0x28 字节的堆，其中 v15 来源于 v42，v42 相对于 Dst 的偏移为 0x20，位于 biClrUsed 字段，样本中相应的值为 0，那么重点就落在 v19 这个变量上了。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyW2VibOFcDlZH04yLeiaNlzEKS87nAoBxGgWwUqW55TmzQicfmcoLS5Zicg/640?wx_fmt=png)

如上图所示，sub_180313814 函数就是决定 v19 的关键函数了，下面是这个函数的伪代码，首先将 BMP 信息头偏移 0x14 处的 4 字节赋值给 v1，即颜色点阵数据所占用的字节数（样本中为 0x10，但只用于压缩的 BMP 文件，因而被置为 0），然后判断 v1 是否为 0，如果 v1 为 0 的话，将 v1 赋值为 abs(*（dword *）(a1 +8)) * sub_1803142F4(a1)，如果 v1 小于等于 0xFFFFFFFF 的话，就返回 v1。 其中，在样本环境下，*（dword *）(a1 + 8) 为 1（指向位图高度），动态调试可知，sub_1803142F4 返回值为 0。因而 v1 为 0，v1<0xFFFFFFFF，所以条件判断成功，返回 v1（0）。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrly9VzLa36VsmOrydkIlIcGhaGeePZPAvRKmYIgLbLjrCJoticlWTv0x6g/640?wx_fmt=png)

再来看 sub_1803142F4 函数，BMP 信息头偏移 0x4 处为 0xC000004，sub_1803137BC(a1) 返回值为 0x18，由于 0xC000004*0x18 > 0xFFFFFFFF 满足条件判断，因而 sub_1803142F4 函数返回 0。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyu3WibKsvBextic6vAjL11NwIExccSrj3aZjakHG70yb8Hf3TD6FFM0Eg/640?wx_fmt=png)

下图为 sub_1803137BC 函数的逻辑将 BMP 信息头偏移 0xC 和 0xE 处的值（如果为 0 则置为 1）相乘得到 v4（0x18），满足最后一个 else 语句中的条件判断，最终因为 v4 等于 0x18，得到返回值为 24（0x18）。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyTZ6fKWPHX2JcjBrbT2Ag6NCeLEpXvxW74oV3lS7AUibWgAeeRE6m5zA/640?wx_fmt=png)

    样本中原本的像素位数为 0x20，但由于以下代码变成了 0x18，不过这个不重要。![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlymQUeY41BAXnibt2dDrRZZF1lhfeMmgjUoibxLdCyRkE0oX1LibWLaI8sQ/640?wx_fmt=png)

所以函数的主要流程就是解析 BMP 信息头，并根据得到的信息开辟一个新堆，然后依次将处理后的 BMP 信息头、颜色表、颜色点阵数据等复制进去。由于 biClrUsed 字段可以为 0，所以 v8 为 0 也是正常的。但是程序虽然判断了位图高度 * 位图宽度 * 像素位数 * 位图平面数是否过大，过大就不增加即将要开辟的堆的大小，但后面依然使用位图宽度为基准，向堆中复制数据，从而导致堆溢出

![](https://mmbiz.qpic.cn/mmbiz_png/EkibxOB3fs4icQruEt2fjdB9tV4KMBGrlyQpxxjicdsRkyeT3qIY0gfDMuwDhBSJc8ln9wbZRicfOQWyI0KFicuWOoQ/640?wx_fmt=png)

**参考链接：**

https://www.fortinet.com/blog/threat-research/deep-analysis-of-cve-2016-0010-microsoft-office-rtf-file-handling-heap-overflow-vulnerability.html