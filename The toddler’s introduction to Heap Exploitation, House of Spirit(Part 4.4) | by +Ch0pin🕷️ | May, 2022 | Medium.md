> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [valsamaras.medium.com](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-house-of-spirit-part-4-4-252cd8928f84)

> Please let me know, if I start to sound weird….

> Please let me know, if I start to sound weird….

_The Author_

The specific attack was initially introduced on **October 11th 2005**, on the bugtraq mailing list by [_Phantasmal Phantasmagoria,_ with the title _The Malloc Maleficarum_](https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt)_._ The idea is very simple and got even simpler with the introduction of the [Thread Local Cache](https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29) (tcache):

> The general idea involves overwriting a pointer that was previously returned by a call to malloc(), and that is subsequently passed to free(). This can lead to the linking of an arbitrary address into a fastbin. A further call to malloc() can result in this arbitrary address being used as a chunk of memory by the application. If the designer can control the applications use of the fake chunk, then it is possible to overwrite execution control data [1].

Simply said, assume that you have a pointer to a chunk that you are able to overwrite in order to point to an arbitrary address that you control its contents. Then it is possible to “fool” the allocator to use your address as a pointer to a free chunk and add it to the fastbins list. When malloc is called again and your chunk suits the requirements, the memory address returned will point to your controlled memory area.

![](https://miro.medium.com/max/840/1*3oPL5NF_5nR5ldFfCgnEpQ.png)

Before free

**After free:**

![](https://miro.medium.com/max/1004/1*eaY-W5fnsKdraUdaA5zOMg.png)

**And finally, after malloc:**

![](https://miro.medium.com/max/1400/1*AJoM5RKRQs7BVhv6NKvfWQ.png)

Before the introduction of the tcache bin, the attacker had to craft **adjacent fake chunks with proper size values** (due to the double linking of the particular bin) in order to pass the validity check of the allocator. The tcache bin (single linked) made things more simple, thus crafting a single fake chunk will pass the validity checks.

**As always, please find below the references to my previous posts relative to heap exploitation:**

*   [The toddler’s, Heap Exploitation, **Introduction** (Part 1)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8)
*   [The toddler’s, Heap exploitation, **Introduction** (Part 2)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286)
*   [The toddler’s, Heap exploitation, **Overflows** (Part 3)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e)
*   [The toddler’s, **Use After Free & Double free** (Part 4)](https://valsamaras.medium.com/use-after-free-13544be5a921)
*   [The toddler’s, **FastBin Dup to Stack** (Part 4.1)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b)
*   [The toddler’s, **FastBin Dup Consolidate** (Part 4.2)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8)
*   [The toddler’s, **Unsafe Unlink**(Part 4.3)](https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68)

Tcache was introduced in glibc 2.26 back in 2017 in order to speed up the heap management. In regards to the **house of spirit attack**, this addition made things easier due to the single-list nature of this bin.

Let’s see a simple example:

We call malloc at **Line 6** to initialise the heap and subsequently (at **Line 7**)we declare a pointer to an **unsigned long long** (ull). At **line 8,** we declare an array of **ull**s and cause the compiler to allocate its members on a 16-byte boundary (similar to a chunk boundary). This array will imitate a chunk, with its header starting at the address of **fake_chunk[0].** More specifically, we have the following correspondence:

**fake_chunk**[0] → mchunk_prev_size, **fake_chunk**[1] →mchunk_size (recall the chunk structure to get a better understanding of this concept):

![](https://miro.medium.com/max/1400/0*20NFlbcCPjnnmOaS.png)

The statement `fake_chunks[1] = 0x40;` at **line 10**, will set the size of the fake chunk to **0x40**. If so far so good, assume that the attacker is able to overwrite the address where **a** points to. This assumption is represented by the `a = &fake_chunks[2];` statement at **line 12**. Finally, the `free(a)` at **line 14** will add the fake chunk to the **tcache bin**, thus the next call to malloc (of size 0x30), will return a pointer to the attacker-controlled chunk. Remember that the size of the fake chunk is also controlled by the attacker, thus the requested malloc size wouldn’t be an issue to the exploitation. Let’s load the program to gdb, to get a deeper understanding:

![](https://miro.medium.com/max/1114/1*E2w5EGv6xYjCpvFE0-FqNw.png)

At `main+57` we will have the following values at `**$rbp-0x30**`:

![](https://miro.medium.com/max/908/1*2Syo2P0rA3EQh815IPD6rw.png)

`**$rax**` after `main+57` will point to the data section of the fake chunk:

![](https://miro.medium.com/max/852/1*ekKAGImgX0TfnJ-nxMoGdg.png)

The call to **free** with the address of $rax in $rdi, will move the fake chunk to tcache:

![](https://miro.medium.com/max/1400/1*7YBhHv9O1Ndl9SjHKHQjMQ.png)

At this point the fake chunk will be assigned to the next malloc(0x30). To make things a bit more interesting, add the following lines to our initial program (Line 16 onwards):

![](https://miro.medium.com/max/1400/1*nULaaNo-mjY-qMr6J3Hhzw.png)

The strcpy equates the attacker’s capability to control the fake_chunk and so where str points to:

![](https://miro.medium.com/max/1400/1*OCF5Mb_6IATICbvV0r2RPQ.png)

This is it for now…see you in the next post.

[1] [https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt](https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt)