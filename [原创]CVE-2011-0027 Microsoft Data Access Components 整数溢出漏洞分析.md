> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-268697.htm)

> [原创]CVE-2011-0027 Microsoft Data Access Components 整数溢出漏洞分析

0. 前言
=====

这篇文章对 CVE-2011-0027 整数溢出漏洞进行了分析，之前在没有系统看过 0day 安全之前也曾经分析过[一个整数溢出漏洞](https://bbs.pediy.com/thread-261984.htm)，只不过导致溢出的运算不太一样，感兴趣的可以去看一下那篇文章。

 

在分析这个漏洞的过程中，花费精力最多的其实是环境的搭建，因为漏洞已经比较老了，遇到了各种坑。之前的漏洞分析最晚在周四也能完成，这次到周四才把环境搭建好。

 

本文首先对 MDAC 进行了简单的介绍，然后花费了一定篇幅说明了搭建环境过程中遇到的各种问题，之后大致按照《漏洞战争》中的流程对漏洞进行了调试分析。总体来说漏洞原理其实并不复杂，只是环境搭建花费了很多时间。

1. 先决知识
=======

1.1 漏洞简介
--------

在 MDAC 处理`RecordSet`时，没有正确验证其指定缓冲区大小的`CacheSize`属性，如果属性值过大，会导致整数溢出，造成实际分配的空间大小小于原来指定的内存空间。由于漏洞发生在堆上，最终会导致堆溢出。

1.2 MDAC 是什么
------------

MDAC 全程是`Microsoft Data Access Components`，即微软数据库访问组件。它为应用程序访问数据库提供了一个标准的接口。

 

MDAC 在应用程序层使用的编程语言接口叫做`ActiveX Data Objects(ADO)`，使用 ADO 可以建立`Connection`对象，表示一个对数据库的会话连接，`Connection`对象包含一个`Execute`方法，应用程序通过这个方法执行想要的操作。ADO 还支持`Command`对象，可以使用`Command`对象建立一个参数化的命令并执行；`Recodset`对象代表的就是数据库中表格形式的数据，`Execute`或者`Command`执行后返回的数据就是`Recordset`格式的，`Recordset`对象支持各种用于控制数据的选项。通常来说，`Recordset`对象表示的是整行数据，或者一行数据中的其中几列，而访问单独的列要使用`Field`对象。虽然通过`RecordSet`每次只能访问一行的数据，但是这并不表示每次访问的时候都需要访问一次数据库，`RecordSet`可以缓存多行数据，而`CacheSize`就表示了它可以缓存的数据大小。

 

更详细的关于 ADO 的信息可以查看[参考资料 3](https://www.notion.so/CVE-2011-0027-Microsoft-Data-Access-Components-afe7ee39f11e44ccafb914d1765f1b57)。

1.3 进一步的知识点
-----------

在 HTML 中可以使用 <XML> 标签插入需要的数据，并提供方法访问这些数据，这一过程实际上就是在使用 MDAC 对数据库进行访问，这里使用的对象就是上面介绍的 ADO。

 

因此可以在访问 XML 中的数据时使用我们上面介绍的一些对象和方法的名称，也可以在这一过程中，触发`CacheSize`中存在的整数溢出漏洞。

2. 漏洞分析
=======

2.0 关于环境配置（绝望的一周）
-----------------

这个东西我搞了一周，终于在周四得到了正确的异常和 symbol 信息…… 中间遇到各种问题：操作系统版本的问题、Windbg 版本的问题、IE 的版本问题、symbol 找不到……

*   操作系统：我先后换了四个版本的操作系统，Win7 的 32 位和 64 位，Win7 SP1 的 64 位以及 WinXP SP3。其中 Win7 SP1 中的 IE 版本偏高无法触发异常；Win7 的系统在调试的时候! heap 总是找不到 wow64.pdb。然后我开始用 WinXP 进行调试……
*   IE 版本：IE 的版本要小于 8.0.7601。
*   Windbg 版本问题：如果是在 Win XP 上面调试，直接使用最新的 Windbg 是不行的，`!heap`显示堆信息也会出问题，具体可以查看[这篇文章](https://www.cnblogs.com/organic/p/5005633.html)。所以最后在网上找了很久，找到了一个 6.6.07.5 的版本，这个版本可以在 WinXP 上面使用

但是……

 

后来发现在 Winxp 下调试的时候输出的调试信息会和正确的地址有误差，我也不知道是 Windbg 版本的问题还是符号文件有问题；与此同时，我也发现 Win7 64 位上面的符号文件是可以正常下载的，wow64.pdb 也在正确的位置上，就是不知道为什么会报错。正当我几近绝望的时候，在 [stackoverflow](https://stackoverflow.com/questions/26795510/wow64-teb32-not-found) 上面搜索到了这样一条回复：

> My Windbg is 6.3.9600. I think you attach to some process, not open a wow64 process dump. If I attach to a wow64 process using 32bit windbg, all the commands can works fine. But when I open a wow64 process dump, both 32bit and 64bit windbg can not work. – Leon Nov 17 '14 at 5:08

 

感谢 Leon，我突然意识到了我的问题，我选择的 Windbg 的位数可能是错的。因为用的是 64 位的虚拟机，所以我自然而然的选择了 64 位的 Windbg。最终我安装了 32 位的 Windbg，成功得到了正确的调试信息。

 

**Windbg 位数选择**：

*   如果你的调试主机运行的是 32 位版本的 windows，使用 32 位的调试工具（不管此时被调试的目标机是 x86-based 还是 x64-based）
*   如果你的调试主机使用 x64-based 的处理器，并且运行 64 位的 windows，请参考如下规则：
    *   如果你在分析 dump 文件，你可以使用 32 位或者 64 位的调试工具集。（不管 dump 文件是用户态的还是内核态的，也不管这个 dump 文件是在 x86-based 还是 x64-based 的平台上抓的。）
    *   如果你在进行实时内核调试，你可以使用 32 位或者 64 位的调试工具集（不管此时被调试的目标机是 x86-based 还是 x64-based）
    *   如果你在进行实时用户态调试，并且调试器也在同一台机器上，对于 64 位的代码和 32 位的 WOW64 代码都需要使用 64 位的调试工具集。使用 [.effmach](http://msdn.microsoft.com/en-us/library/windows/hardware/ff562949(v=vs.85).aspx) 命令设置调试器的模式。
    *   如果你在实时调试 32 位的用户态代码，但是这些代码运行在一个单独的目标机器上，使用 32 位的调试工具集。

2.1 调试代码
--------

以下是调试代码，保存成 poc.html：

2.2 确定函数的对应关系
-------------

之前只在分析 MS06-055 这个漏洞的时候有过调试 IE 的经历，在已经确认漏洞所在文件名时，可以直接根据漏洞相关信息在`Function name`中进行搜索，确定相关函数地址，然后在该地址处下断点进行调试。

 

在《漏洞战争》中，还讲到了另外一种调试的方法，在谷歌中搜索：`【关键词】 site:https://www.geoffchappell.com`

 

_我在测试的时候一开始只搜到两个结果，最关键的那个没有搜索到，后来换了一个代理地址，就成功了，(lll￢ω￢)_

 

这样搜索的目的是为了找到在 IE 中存在的和`recordset`有关的类方法，因为需要在对应的方法处设置断点进行调试。

 

根据搜索结果，得到了三个和`recordset`有关的类：

```
CEventObj::get_recordset
CEventObj::putref_recordset
 
CGenericElement::get_recordset
 
CObjectElement::get_recordset
CObjectElement::putref_recordset

```

其中`CEventObj`是为 html 中`event`对象提供的接口，可以忽略不记，代码中是一个获取`recordset`的行为，所以最终要在`CGenericElement::get_recordset`和`CObjectElement::get_recordset`上下断点。

 

poc.html 打开之后，设置好断点，继续执行，程序断在了`CGenericElement::get_recordset`这个函数上，说明代码中`localxmlid1 = document.getElementById('xmlid1').recordset;`这个语句对应的是`CGenericElement::get_recordset`函数。

2.3 开始调试
--------

先确定一下漏洞发生的位置，还是使用之前漏洞分析时介绍的方法，为 iexplor.exe 设置页堆：

```
C:\Documents and Settings\test>"C:\Documents and Settings\test\Desktop\Global Flags.lnk" -i iexplore.exe +hpa
Current Registry Settings for iexplore.exe executable are: 02000000
    hpa - Enable page heap

```

打开 poc.html，根据 IE 的默认安全设置，此时 JS 脚本是不会执行的，需要额外的步骤进行确认。这时使用 windbg 附加到 iexplore.exe 上，继续执行，再在 IE 上面 "允许阻止的内容"，此时就会发生异常：

```
(a14.a2c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0000036b ebx=0000035b ecx=00000000 edx=00000001 esi=0eace000 edi=00000000
eip=720f746f esp=0848e744 ebp=0848e748 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
mshtml!CImpIRowset::HRowNumber2HROWQuiet+0x23:
720f746f 8906            mov     dword ptr [esi],eax  ds:002b:0eace000=????????
0:005> !heap -p -a 0eace000
    address 0eace000 found in
    _DPH_HEAP_ROOT @ ea21000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 ea22750:          eacd298              d64 -          eacd000             2000
    74be8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
    779c02fe ntdll!RtlDebugAllocateHeap+0x00000030
    7797ac4b ntdll!RtlpAllocateHeap+0x000000c4
    77923b4e ntdll!RtlAllocateHeap+0x0000023a
    7171975d MSDART!MpHeapAlloc+0x00000029
    715e06e7 msado15!CRecordGroup::AllocateHRowRange+0x00000085
    715e0650 msado15!CRecordset::PrepareForFetch+0x000000e2
    716744ae msado15!CRecordset::MoveAbsolute+0x000003e3
    716080a5 msado15!CRecordset::_MoveFirst+0x0000007d
    71677957 msado15!CRecordset::MoveFirst+0x00000221
    715efde6 msado15!CRecordset::Invoke+0x00001560
    7182db38 jscript!IDispatchInvoke2+0x000000f0
    7182da8c jscript!IDispatchInvoke+0x0000006a
    7182d9ff jscript!InvokeDispatch+0x000000a9
    7182db8a jscript!VAR::InvokeByName+0x00000093
    7182d8c8 jscript!VAR::InvokeDispName+0x0000007d
    7182d96f jscript!VAR::InvokeByDispID+0x000000ce
    7182e3e7 jscript!CScriptRuntime::Run+0x00002b80
    71825c9d jscript!ScrFncObj::CallWithFrameOnStack+0x000000ce
    71825bfb jscript!ScrFncObj::Call+0x0000008d
    71825e11 jscript!CSession::Execute+0x0000015f
    7181f3ee jscript!NameTbl::InvokeDef+0x000001b5
    7181ea2e jscript!NameTbl::InvokeEx+0x0000012c
    718196de jscript!NameTbl::Invoke+0x00000070
    71e2aa7b mshtml!CWindow::ExecuteTimeoutScript+0x00000087
    71e2ab66 mshtml!CWindow::FireTimeOut+0x000000b6
    71e56af7 mshtml!OnTimer+0x0000003d
    71e51e57 mshtml!GlobalWndProc+0x00000183
    75c06238 USER32!InternalCallWinProc+0x00000023
    75c068ea USER32!UserCallWinProcCheckWow+0x00000109
    75c07d31 USER32!DispatchMessageWorker+0x000003bc
    75c07dfa USER32!DispatchMessageW+0x0000000f

```

书中使用`!heap -p -a`指令显示出了具体的栈回溯信息，之前进行其他漏洞分析的时候没发现这条指令这么好用，b(￣▽￣)d。

 

从输出信息中可以看出堆块起始地址是`0xeacd298`，大小为`0xd64`，所以在写到`0xeace000`的时候就超过这个堆块的范围了。

 

_我这里的 windbg 输出好像是有一些问题，函数名后面的偏移量是错误的，可能我下载的 symbol 还是有些问题，所以我这里的分析步骤也有一些调整。_

 

从栈回溯中可以看到异常发生在调用`CRecordset::MoveFirst`之后，而`CRecordset::MoveFirst`又调用了`CRecordGroup::AllocateHRowRange`，从函数名看这应该是一个分配空间的函数，所以我打算在这里下一个断点，查看一下这个函数的参数情况。

 

但是在我在`CRecordset::PrepareForFetch+0x000000e2`下断点的时候，程序并没有断在正确的位置，而是断在了

```
Breakpoint 1 hit
eax=00000001 ebx=00000001 ecx=0d8afd70 edx=00000000 esi=0d8afd70 edi=73a09730
eip=724106d1 esp=0833ed90 ebp=0833ed9c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msado15!CRecordGroup::AllocateHRowRange+0x6f:
724106d1 8b0d10f04c72    mov     ecx,dword ptr [msado15!g_hHeapHandle (724cf010)] ds:002b:724cf010=0d840000

```

因此我直接断在`CRecordset::PrepareForFetch`，F10 向前步进了几步，到达了`CRecordGroup::AllocateHRowRange`的调用位置：

```
0:005> p
eax=00000000 ebx=00000000 ecx=0d2cfd70 edx=00000000 esi=0d2cfc48 edi=00000000
eip=71f2064b esp=086eee5c ebp=086eee6c iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
msado15!CRecordset::PrepareForFetch+0xdd:
71f2064b e80f000000      call    msado15!CRecordGroup::AllocateHRowRange (71f2065f)

```

第一次中断的时候参数不对，继续执行，直到第三次断在这里的时候，查看 esp：

```
0:005> dd esp
0875ec08  40000358 0875ec48 00000000 0bf1fc48
0875ec18  0875ec5c 71f644ae 40000358 0875ec48
0875ec28  00000001 00000001 0bf1fc48 00000000
0875ec38  0875ec60 743cc2f3 00000000 743cc2fb
0875ec48  00000000 00000000 0bf0ffa4 00000012
0875ec58  0075ec78 0875ecb8 71ef80a5 00000000
0875ec68  00000001 71f8f3c0 00000000 8b4eb1ba
0875ec78  0bf1fc54 0bf1fc48 0bf23f01 0875ecb4

```

可以看到第一个参数是`40000358`，就是 poc 中设置的`CacheSize`的大小。

 

这时候在`CRecordGroup::AllocateHRowRange+0x00000085`设置一个断点，继续执行

```
0:005> g
Breakpoint 2 hit
eax=00000d64 ebx=40000358 ecx=0beb0000 edx=0beb2c98 esi=0bf1fd70 edi=728f9730
eip=71ed06e4 esp=0875ebec ebp=0875ec00 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msado15!CRecordGroup::AllocateHRowRange+0x82:
71ed06e4 51              push    ecx
0:005> p
eax=00000d64 ebx=40000358 ecx=0beb0000 edx=0beb2c98 esi=0bf1fd70 edi=728f9730
eip=71ed06e5 esp=0875ebe8 ebp=0875ec00 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msado15!CRecordGroup::AllocateHRowRange+0x83:
71ed06e5 ffd7            call    edi {MSDART!MpHeapAlloc (728f9730)}

```

`MpHeapAlloc`的参数应该和`HeapAlloc`的参数差不多：

```
DECLSPEC_ALLOCATOR LPVOID HeapAlloc(
  HANDLE hHeap,
  DWORD  dwFlags,
  SIZE_T dwBytes
);

```

看一下栈中元素的内容：

```
0:005> dd esp
0875ebe8  0beb0000 00a00000 00000d64 00000000
0875ebf8  0bf1fc48 00000012 0875ec18 71ed0650
0875ec08  40000358 0875ec48 00000000 0bf1fc48
0875ec18  0875ec5c 71f644ae 40000358 0875ec48
0875ec28  00000001 00000001 0bf1fc48 00000000
0875ec38  0875ec60 743cc2f3 00000000 743cc2fb
0875ec48  00000000 00000000 0bf0ffa4 00000012
0875ec58  0075ec78 0875ecb8 71ef80a5 00000000

```

第三个参数书`d64`，就是分配的堆块大小。看一下这个参数是怎么来的：

```
0:005> ub 71ed06e5
msado15!CRecordGroup::AllocateHRowRange+0x64:
71ed06c6 8bc7            mov     eax,edi
71ed06c8 8b3dfc10ec71    mov     edi,dword ptr [msado15!_imp__MpHeapAlloc (71ec10fc)]
71ed06ce 89460c          mov     dword ptr [esi+0Ch],eax
71ed06d1 8b0d10f0f871    mov     ecx,dword ptr [msado15!g_hHeapHandle (71f8f010)]
71ed06d7 8d048504000000  lea     eax,[eax*4+4]
71ed06de 50              push    eax
71ed06df 680000a000      push    0A00000h
71ed06e4 51              push    ecx

```

可以看到`edi → eax → eax*4+4 → 0xd64`这样一个计算过程，所以需要判断`edi`的值是多少，但是`edi`的值已经被`MpHeapAlloc`的地址覆盖了，所以需要再次调试。上面也说了，不知道为什么，windbg 给出的偏移量是有问题的，所以我直接在`CRecordGroup::AllocateHRowRange`下断点，也是第三次中断的时候，单步到达`mov eax, edi`这条指令：

```
0:005> p
eax=00000001 ebx=40000358 ecx=779236fa edx=0e9a2c98 esi=0ea0fd70 edi=40000358
eip=725b06c6 esp=0845eeec ebp=0845eef8 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
msado15!CRecordGroup::AllocateHRowRange+0x64:
725b06c6 8bc7            mov     eax,edi

```

可以看到此时 edi 的值为`40000358`，正是我们在代中设置的`CacheSize`的值。`40000358*4+4=100000d64`，由于寄存器大小只有四个字节，发生了整数溢出，得到的结果就是`d64`。

3. 总结
=====

这次漏洞分析学习到的是通过`!heap -p -a ADDR`得到栈回溯信息，从而确定堆溢出的位置和具体信息；以及怎样确定 IE 中编程使用的函数与底层 API 函数的对应关系，从而便于漏洞分析。还有在分析之前，环境搭建踩到的很多个坑，下次新的环境搭建就会更有经验了。

4. 参考资料
=======

1.  《漏洞战争》
2.  [MS11-002 Pwn2Own heap overflow](http://vreugdenhilresearch.nl/ms11-002-pwn2own-heap-overflow/)
3.  [Microsoft Data Access Components (MDAC)](https://flylib.com/books/en/2.894.1.118/1/)
4.  [Windbg 32 位版本和 64 位版本的选择](https://www.cnblogs.com/lidabo/p/3706825.html)

5. 资料分享
=======

在整个环境搭建过程了，在网上找到了几个很好的资料和资源，虽然最后可能没用到，但是还是分享给大家，自己也做一个存档：

1.  [安装与配置 windbg 的 symbol(符号)](https://blog.51cto.com/u_11512826/2068421)
2.  [Windows 全部调试符号包下载](https://blog.csdn.net/MengXP/article/details/108712896)
3.  [Windows 调试器及不同平台符号包下载地址 (收集)](https://www.cnblogs.com/flying_bat/archive/2006/10/27/541665.html)

如果有的下载地址已经无法访问，一定要善用 [internet archive](https://archive.org/)，有些资源地址有历史快照。

[第五届安全开发者峰会（SDC 2021）议题征集正式开启！](https://bbs.pediy.com/thread-266645.htm)

[#漏洞分析](forum-150-1-153.htm) [#Windows](forum-150-1-160.htm)