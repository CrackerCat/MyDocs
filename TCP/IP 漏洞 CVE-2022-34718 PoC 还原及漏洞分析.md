> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/5oBAw-oLtHA52-0eBcPSpg)

**背景和准备**

微软上月发布的补丁包含一个可能执行代码的 TCP/IP 协议漏洞。为了验证该漏洞的影响范围和可能后果，Numen 高级安全研究团队对此漏洞做了深入的分析，并通过补丁对比，还原出了 PoC。本文将详细介绍我们如何通过补丁对比还原出 PoC，以及漏洞的细节。Numen 将会持续输出高质量的安全研究文章，以及成果，为 Web3 安全以及网络安全其他领域提供权威高质量的研究成果，助力网络安全健康发展。

首先熟悉这些与 IPv6 和 IPSec ESP 协议相关的数据包结构有助于理解本文。技术参考如下： 

IPv6：https://www.rfc-editor.org/rfc/rfc2460#page-6 

IPSec ESP： https://www.rfc-editor.org/rfc/rfc2406 

**补丁分析**

有了之前的知识，我们可以更容易地理解脆弱性原理。现在让我们分析补丁。 

比较 tcpip.sys 的八月和九月补丁，我们发现有两个函数需要修补。如下所示： 

![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6qJLjUtrDAcnZwGCgHAaTc0HV6pjmMx1lTCb2ibfnA5a714iakgXKMvAw/640?wx_fmt=png)

这里的补丁修补方式表明在重组 ipv6 分片数据的时候，似乎存在某一个内存偏移大于预期的可能错误。除此之外，还有另一个修补过的函数：   

![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6mDYA4CuVicXKibMUicmywib3PBxt37VLXIy3LSIV2SFEO94iasg0sh64M8g/640?wx_fmt=png)

这处函数修补作用并不太直观，我们只能知道接收 IPsec_ESP 封包的处理过程中，如果其某一标志位不满足补丁修补条件，这个包将会被丢弃。 

**PoC 构造** 

**A. 初步尝试** 

尽管 Microsoft 在漏洞描述中明确表示，它将向启用 IPSec 的节点发送 ipv6 数据包。然而，从上面对漏洞补丁的分析来看，我们认为如果我们能够构建一个符合 Ipv6pReassembleDatagram 函数中修补条件的 IPv6 碎片数据，我们可以触发内存中错误（大于预期）偏移量的损坏。

一开始，我们忽略了 IPSec 的条件，专注于 IPV6 碎片化和包重组。tcpip DOS 漏洞分析 CVE-2021-24086 2021 年初（https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html）提供了一个良好的切入点 

参考本文中的 PoC，我们可以在 Ipv6pReassembleDatagram 函数中重新组织一组 IPV6 分区包。但我们发现，只有普通 ipv6 标头携带碎片数据包，这不会影响补丁中限制的参数。 

查看漏洞的官方描述，并注意第二个补丁。我们认为可能有必要使用 IPSec 中的 ESP 包来控制第一个补丁的关键参数。 

我们开始构建启用 IPSec 协议的测试环境。 

**B. 构造 IPSec 流量包** 

如前介绍，IPSec 是一种可以对指定类型 ip 流量筛选过滤，并加密验证的一种协议。通常在 VPN 或者增强其他协议密码安全性的部分条件下使用。在 windows 中 

我们搭建了一个域条件下，两台对对方所有流量都加密验证的环境。因为很多时候它并不是一种默认开启的协议。 

![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6a6ackTY1TeJnqNnW9uCDXtwWBU1SKp5LFO4eK2HsPyiaQibCkvfuFGibA/640?wx_fmt=png)为了构造这种数据包，我们必须知道协议中指定的加密算法和秘钥。其中 IPSec_ESP 中加密方式我们可以自行选择。在本次分析中我们仅仅启用了 IPSec 中的完整性 HASH 验证，使用 SHA1 计算 hash。但这已经能满足漏洞触发的基本要求。 

![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6m3poScUrxnYmqmFlJbficvjw6lm71Z4ibrUicemJhESNMJ7Ph8yT5c1Tw/640?wx_fmt=png) 

这里需要额外说明 IPSec 数据包构造过程中数据加密的秘钥获取（如果选择 linux 作为攻击机的话，密钥获取将比较容易可以忽略这里）。 

Windows 中的 IPSec 的加密过程都是在 tcpip 协议驱动中实现的，虽然在应用层中，微软提供了一套 WFP 流量筛选平台框架 API 可以控制 IPSec 中 SA 的一些参数（如 SPI），但是对于秘钥管理这一部分，我们并不能直接获取到 IPSec_ESP 包中加密所需的秘钥和其他的一些具体的加密规则（不同于流量加密秘钥每次的变化，流量完整性验证秘钥虽然也会不停变化，但在一段时间内，该秘钥是固定的）。 

通过分析 tcpip 驱动，我们可以从 tcpip 的 MICROSOFT_TCPIP_PROVIDER_Context 中获取密钥（在测试环境，我们直接从内核中 BCryptCreateHash 的参数中获取）。并且如前所述，我们的 IPSec 流量中，只启用了流量完整性验证，并没有使用流量加密。这样对后续的分析，协议理解都比较直观。 

构造好 IPSec 流量包后，通过调整 IPSec 数据包中的参数，我们的数据包满足了第二个修补函数对 IPSec_ESP 包在第二处补丁函数对指定标志的限制条件。对照协议结构，我们可以知道，第二处补丁函数限制的标志位对应的是 IPSec_ESP 包中加密数据的类型标志。当 ESP 中加密包 ipv6 扩展头类型为小于等于 0 时丢弃该数据包。具体包括一下几项 0（IPv6 Hop-by-Hop Option）或者 0x2b（Routing Header for IPv6）0x2c(Fragment Header for IPv6)  

我们的测试中，使用了 Fragment Header for IPv6 的包（0x2c）。 ![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6LZM8Gbia06OQxepibh6lSvqUjXbZm8PtakpxyP4II6X1iczf0J8dLOxtw/640?wx_fmt=png)

**C. 最终的 PoC**

有了我们需要的 IPSec 流量包结构后，我们现在需要做的就是将第一步尝试构造的 IPv6 分片数据当做 ESP 协议中需要被加密以及验证的数据（其中关键是 ESP 尾部结构中最后一位标志 ESP 携带的扩展头类型标志设为 0x2c），并组装好后开始发送。 

由于该漏洞需要发送原始 ip 数据包，并且在初期调试的过程中，最好能够比较方便的控制修改每一个发送的 ip 包字节。我们需要一个比较底层且灵活的发包接口。喜欢 python 的朋友可以使用 scapy。 

我们这里使用的是一个现成的 NDIS 协议驱动。（该驱动代码和编译及安装。参考《windows 网络通讯程序设计第二版》代码示例）。使用底层驱动协议的好处是除了个人习惯，另外有很多的各类型协议数据包组装代码示例方便理解。 ![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz62fWribVM7Q8iaHibFlZiaLmwlWngtTbXrBNZDtpAVkDCRticA4NsicPseGQQ/640?wx_fmt=png)

**总结** 

从根本上讲，该漏洞修复主要限制 ESP 携带 IPv6 IPSec 协议中提到的几个 IPv6 扩展头。 

当前 PoC 代码可能导致 NetIo 协议头对象内容中的字节（大于 0x38 的任意偏移地址）被重写为任意值（此处为 0x2C）。这里提到的 0x2c 不是 ESP 中携带的第一个 ipv6 扩展标头类型标志。它是 ESP 中携带的分区标头旁边的 ipv6 扩展标头标志。这可以任意设置。 

在解析下一个扩展头时，我们可以通过构造一些准确的扩展头来崩溃 esp 包。如果随后的 esp 解密内容无效且与扩展头类型不一致，TCPIP 通常不会立即触发异常（通过控制内存损坏的位置，我们可以构建一些不同类型的系统崩溃场景）： ![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cmjatD12h8A2vib4enQDhz6npiaWozdn0wZaFEPCJzpvQiaHsvGibUyAr8uBkKvbHiaBKOVNd91zXxWrA/640?wx_fmt=png)

对于该漏洞的利用，目前有两种思路。 

**A、** 重点分析目前我们可能损坏的 NetIo 协议头对象的详细结构，看看数据大小或其他关键数据位置是否可以通过我们写入的数据转换为其他缓冲区复制错误，从而构建任意读 / 写函数。 

**B、** 因为我们可以破坏的位置不限于 NetIo 协议头对象，我们可以通过构造更大的偏移量（通过修改 ESP 包的长度）来覆盖其他对象。因此，可以使用其他对象来构造读 / 写源语言或代码执行。 

但无论上述哪一种想法，都可能需要进一步分析其确切的可行性 

**实际影响** 

从漏洞本身的范围来看，该漏洞依赖于 IPv6 协议和 IPSec 协议的组合。IPv6 目前被广泛使用。有许多场景支持 IPv6，但一些常用的 VPN 或一些需要流量加密的环境通常不使用 IPSec 作为默认选项，需要由管理员设置。 

此外，我们的 PoC 在域中设置了两个 IP 安全策略的环境中实现。首先，我们通过域验证身份，然后我们可以向其他受信任的域成员目标发送易受攻击的数据包。未经身份验证发送的加密流量将不会被处理。否则，您需要获得预共享的密钥才能完成身份验证。 

漏洞演示，请查看如下视频：

[视频详情](javascript:;)

漏洞 PoC 详情， 请访问：https://github.com/numencyber/VulnerabilityPoC。

![](https://mmbiz.qpic.cn/mmbiz_png/vlekRjgqic0cU6ic2X9KTjlmwxVmR7j7PdvK5D47f4wfYsSEhOQ9Il4V5I6QicxqODdhLmicKicsc5jeFS3pr78dS3g/640?wx_fmt=pngwxfrom=5wx_lazy=1wx_co=1)

**Numen 导航**

**Numen 官网**

https://numencyber.com/ 

**GitHub**

https://github.com/NumenCyber

**Twitter**

https://twitter.com/@numencyber

**Medium**

https://medium.com/@numencyberlabs

**LinkedIn**

https://www.linkedin.com/company/numencyber/