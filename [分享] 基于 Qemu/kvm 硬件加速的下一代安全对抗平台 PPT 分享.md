> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-270001.htm)

> [分享] 基于 Qemu/kvm 硬件加速的下一代安全对抗平台 PPT 分享

安全的本质永远绕不开 “对抗” 这个主题，基于对日常攻防对抗的思考和作为研究员不断探索的天性。

 

蒋浩天先生为我们带来了《基于 Qemu/kvm 硬件加速下一代安全对抗平台》，虚拟化等技术带给传统攻防全新的思考维度，让我们看到了站在上帝模式下的降维打击。随着后续行为监控和武器库的完善，相信此工具可以帮广大安全人员解决安全对抗的疑难杂症。

 

下面就让我们来回顾 2021 看雪第五届安全开发者峰会上《基于 Qemu/kvm 硬件加速的下一代安全对抗平台》的精彩内容。

演讲嘉宾
----

![](https://bbs.pediy.com/upload/attach/202110/236762_CH25C3TUUK6ND6V.png)

> 蒋浩天：字节跳动无恒实验室云安全专家，曾任职于 360、腾讯，现就职于字节跳动无恒实验室。  
> 拥有 6 年一线安全对抗经验。擅长内核安全开发、虚拟化安全、沙箱检测，是某沙箱的核心作者之一。擅长逆向分析、二进制漏洞攻防、游戏安全对抗、嵌入式，bios 开发。

演讲内容
----

以下为速记全文：

 

大家好，接下来由我给大家分享《基于 Qemu/kvm 硬件加速下一代安全对抗平台》。分享者：蒋浩天，来自字节跳动无恒实验室。我的研究方向为：二进制安全、漏洞攻防、游戏安全、沙箱检测、虚拟化安全，喜欢研究一些底层方向。将安全能力下沉，开启安全对抗的上帝模式。

 

我们的议题分为大概几个部分，分别是：

1.  安全对抗思考
    
2.  虚拟化技术
    
3.  Ark 工具设计思路
    
4.  调试器设计思路
    
5.  平台介绍（KVM-Based security platform）
    
6.  后续展望
    

01 安全对抗思考

 

首先，先来说一下：安全对抗思考。我们在安全对抗中会经常遇到那些棘手的问题呢？

 

由于很多黑产模块商业化。导致对抗异常激烈，商业化模块具备各种对抗功能，当恶意样本，黑产工具集成了商业化模块后，会具备很强的对抗能力，例如说：

 

1、反调试，公开插件已经无法绕过。

 

2、反沙箱，反 ark 工具，一旦检测到沙箱环境，行为监控工具，ark 工具等常用的安全工具，样本停止工作。

 

3、机器封禁，当它检测到你在分析它，将会进行机器封禁，导致此机器无法运行此样本。

 

4、样本很紧急，老板让你今晚出报告。

 

目前来说，业界有哪些优秀的解决方案？

 

第一个解决方案，也是目前比较流行的解决方案，就是模拟执行，例如 unicorn。模拟执行具备一定的优势，例如它可以模拟执行一段 shellcode 且是轻量级的。也有一些劣势，例如需要模拟一个可以执行的环境，这个环境想要模拟非常全面，工程量也是很大的。它的致命缺点是效率比较低，且环境模拟不全。无法模拟 D3D，一些依赖于 D3D 的软件无法正常工作运行。例如说：游戏无法运行，游戏外挂就不能正常工作，你就无法分析它。

 

第二个比较主流的解决方案就是硬件调试器，此方案优点比较多：效率高，支持 d3d。劣势是：第一，需要额外购买硬件并且价格比较高；第二，携带不方便，不方便给小伙伴展示高端调试技巧；第三，对于用户态环境识别不是非常好。

 

这两种解决方案为什么比较好用？

 

![](https://bbs.pediy.com/upload/attach/202110/236762_P878GBVFN2QDHMF.png)

 

当前的这些问题，其实我综合分析一下，站在我的角度来看：windbg 依赖于 windows 的调试子系统，gdb 依赖 unix 的 ptrace，所以就会存在很多可检测特征。

 

我理解来说：硬件调试器和模拟执行这两类工具抽象一点来看，更像一个站在 CPU 内部的工具，可以精准的控制每一行指令的执行，监控或修改指令执行结果。它不依赖于系统的调试机制，所以很多反调试方法对其无效。

 

通俗一点说：站在了一个至高点，实现了降维打击。

 

我们继续思考：模拟执行这项技术最开始用于虚拟机，来虚拟一个操作系统，虚拟机本身具备模拟执行的能力。

 

Unicorn 和虚拟机有什么关联？经过查阅资料，unicorn 的代码大部分是移植的 QEMU 中的代码。由于虚拟机模拟执行操作系统时，性能非常低，所以模拟执行逐渐被抛弃。硬件虚拟化成为了主流。启用硬件虚拟化的虚拟机，不再需要模拟执行了，效率得到了非常大的提升。

 

虚拟机一般都具备一个 virtualJTAG 接口，这个接口在模拟执行和硬件虚拟化两种模式中，实现原理不同。VirtualJTAG 接口不能区分进程上下文，不能调试用户态程序，而且不能识别 windows 内核。

 

这时突发奇想，我们是否可以基于虚拟化来开发一套类似的工具？

 

是否可以对虚拟机进行二次开发，开发一个支持 windows 系统，支持用户态和内核态的调试器呢？并且将各种安全工具，ark 工具，调试，都集成到一起，形成平台化。

 

这样，我们也是站在了一个制高点，形成一个降维打击。以后做安全对抗就非常方便了。我们的目标是：将安全工具运行在物理机，对虚拟机进行控制。在开发之前，就可以想到一些优略势，首先说优势：1、不依赖于操作系统机制。例如调试机制。2、不需要在虚拟机中安装模块，安全工具无法被检测。3、直接在物理机对虚拟机进行环境扫描，权限更高且不会被检测。4、可以监控虚拟机中敏感内存的读写执行。

 

但同时也会存在一些劣势：1、数据解析工作量大，适配繁琐。2、不能调用 api。一些常规操作变得异常复杂，例如锁，同步。

 

02 虚拟化技术

 

接下来介绍一下虚拟化技术，先来介绍几个名词：对应的翻译在后面都列出来了，大家可以先看一下，因为后续讲解过程中可能会用到。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_NBRUCZGABQEBX5Z.png)

 

由于模拟执行，性能非常低，随着技术的发展，硬件虚拟化成为了主流。所以我们需要看一下硬件虚拟化的原理：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_QVDREKF9KMK7SHY.png)

 

如图我们调用 vmxon 指令后，cpu 进入虚拟化模式。分别为 guest 模式和 host 模式。通过 VMExit 和 VMEntry 事件来进行驱动。

 

例如说执行 VMLAUNCH 指令后，此时就会有一个 VMEntry 事件，虚拟机从 host 模式，进入到 guest 模式，此时虚拟机就开始执行了。

 

当虚拟机运行过程中，遇到了一些特殊事件比方说执行了 in out 指令，就会产生一个 VMExit 事件，此时 CPU 将会从 guest 模式切换到 host 模式。

 

在 host 模式下，对 in out 指令进行虚拟化处理。处理完成之后，在返回到 guest，让虚拟机继续执行。

 

接下来需要介绍 qemu kvm 的架构图：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_T2Q26VYYU9CWA5R.png)

 

首先最底层，是硬件层，例如说 CPU,GPU， 内存，磁盘，网卡等硬件设备。再硬件层之上，是 linux 内核层，例如说 vmlinux，设备驱动，kvm 等，其中 kvm 就处于这一层。再上一层，就是 linux 用户层，在这一层，运行了很多 linux 程序，服务，守护进程等相关的东西。Qemu 就处于这一层，qemu 以一个进程的形式存在。

 

Qemu 基于 kvm 开启硬件虚拟化。所以说图中的两个 qemu 虚拟机都运行在 kvm 之上。在 qemu 虚拟机内部，运行着虚拟机的操作系统，分为虚拟机的内核层，和虚拟机的用户层。

 

根据上面的架构图得知，虚拟机是运行在 qemu 进程的上下文的。那么 qemu 进程，是否包含虚拟机的内存数据呢？

 

我们在创建虚拟机时，需要设置虚拟机内存的大小。虚拟机在启动时，首先要为虚拟机申请物理内存，代码如下。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_3FM3JSFRW5CC4YV.png)

 

通过此代码反映出一个问题。虚拟机的内存，其实就是对应这个 mmap 的内存，在 qemu 进程的上下文中。大家可以从代码中看到，这个 mmap 函数的调用。

 

如上图可以看到，虚拟机启动后，用户态会存在一个 qemu 的进程。我们的问题是：如何对这块内存进行识别，解析出虚拟机中操作系统的数据？想要完成这项工作，我们必须要完全了解虚拟机中是如何实现内存的虚拟化的。

 

我们先看一下虚拟化模式和非虚拟化模式的内存地址翻译流程区别：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_RFTMJKFJPUDJFDQ.png)

 

对比发现，多了一层地址翻译，需要把虚拟机中的物理地址，再次进行翻译，翻译成物理机的物理地址。也就是 GPA 翻译成 HPA。

 

我们首先需要简单回顾一下 X86 架构下内存翻译流程：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_3DHZ8GPHXCEAHVK.png)

 

逻辑地址到线性地址的翻译，我们在保护模式下，地址访问都是段寄存器加逻辑地址来进行访问的。

 

例如说，TI 位为 0。我们需要在 gdt 中寻址。根据段寄存器的 index 字段，来访问 gdt 表。找到对应的项，例如说，cs 段寄存器的 index 为 2，对应 GDT 的第 3 项，获取到对应的段描述符之后，P 位为 1 表示有效。

 

判断段描述符的 DPL 和段寄存器的 RPL 是否满足一系列的权限检查。如果检查全部通过。将得到段对应的 base。大家可以看到，这些段的 base 都是 0。拿到段的 base 之后，用 base 加上逻辑地址偏移，既可以计算出对应的线性地址。

 

接下来我们说一下从线性地址到物理地址的转换，线性地址到物理地址的转换需要通过页表来完成。由这张图，我们可以找到每一级索引的位置：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_A5KUR3NMUZYZ87F.png)

 

先说一下 4K 页面的转换，CR3 寄存器是页表寄存器。存放了页表的首地址，首先需要对线性地址进行拆分，把每一级的索引都划分出来，偏移也要划分出来。最高级索引，索引 CR3 指向的目录，拿到对应的项之后，这里面存放的也是一个物理地址。然后用第二级索引进行索引，以此类推，直到索引完成，最后拿索引到的物理地址，加上 offset，即可完成线性地址到物理地址的转换。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_ZDEXRU6T4C6AKM8.png)

 

接下来看一下 2M 页面的转换，他跟 4K 页面的转换基本原理一致，只是说索引级别少了。Offset 变长了。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_NF84APQAAYY7BJB.png)

 

再看一下从 GPA 到 HPA 的翻译过程，先将 GPA 进行拆分，划分好每一级的索引，和 offset。根据 eptp 指向的页表，进行一级一级的索引，跟前面的页表翻译原理类似。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_X98HURHDDGYWT2N.png)

 

接着看一下虚拟机的内存虚拟化实现的整体架构，如图：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_YNMPNZGNHMEGPHX.png)

 

1、在虚拟机中，GVA 先通过页表，翻译成 GPA。  
2、通过 EPT，将 GPA 翻译成 HPA.

 

Host 模式下：1、在宿主机中，HVA 通过宿主机的页表翻译成 HPA。2、Qemu 通过 memory slot 机制，管理这个 GPA 到 HPA 的映射。

 

如图，黄色的方块，就代表虚拟机的一块内存，这块内存在 guest 中，访问对应的 GVA 可以访问到。同时，在 host 中，访问对应的 HVA 也可以访问到，因为都是对应的同一块物理内存。

 

前面我们介绍了 X86 架构下的地址翻译过程，我们还需要了解一下 qemu 是如何管理内存的。

 

由于 qemu 在启动时，mmap 了一块内存，这块内存用于虚拟机的物理内存。由于内存的惰性分配，和效率优化，虚拟机需要对他进行管理。

 

Qemu 有两种内存管理方式，第一种是树形管理，具备一个更好的管理视图。第二种是平坦类型管理，用于和 kvm 交互。

 

我们先说一下树形管理：Qemu 的内存，最顶端是一个 address space 结构体，不同类型的内存由不同的 address space 来表示。所有的 address space 通过链表，连接在一起。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_3EAPV3EHSYYUSUY.png)

 

在 address space 结构体内部，有一个 root 字段，指向一个 memory region 结构体，这个字段是内存树的根节点。

 

Memoryregion 下面会有子节点，有一些子节点的 ram_block 是为空的，他表示一个别名的引用。其中 alias offset 就是指向引用的 memory region 对应的这个虚拟机物理内存的偏移。有一些 memory region 的 ram_block 是有值的，如果不为空，里面会有一个 host 字段，这里指向的是虚拟机物理内存对应的 hva。

 

虽然说 qemu 对虚拟机的内存有自己的管理体系。但是想要实现内存虚拟化，必须按照 cpu 的规则来进行 ept 映射。才能够生效。所以 qemu 还有一套平坦内存管理视图，用于和 kvm 进行交互。实现基于硬件的内存虚拟化。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_98D7V2T422J8PGJ.png)

 

如图所示，每一个 memory region 经过 generatememory topology 函数调用后，都会生成一个 Flatview 结构体，这个结构体会插入到一个 flat_views 的一个 hashmap 中，方便下次快速查找。

 

这个 FlatView 内部，存在一个 ranges 字段，这个字段是一个指针，指向 Flat range 的数组。每一个 flat range 结构体管理着一块虚拟机的物理内存，标志着 kvm 中 EPT 如何对虚拟机物理内存进行虚拟化。

 

例如说 flat range 里有一个 addr 字段，Addr 是一个 addrrange 类型，里面包含一个 start，和 size。这里面的 start 存放的是一个 gpa。Qemu 通过调用 kvm 的接口来完成 ept 映射。kvm 会根据调用参数，和上述的 X86 架构的规则来完成 ept 的映射。建立 GPA 和 HPA 的映射关系。从而实现了内存的虚拟化。到目前位置，qemukvm 的内存虚拟化，我们大概介绍完成。

 

03ark 工具设计

 

有了前面的知识体系，我们想实现 ark 的功能，已经有了一些希望。我们就有了初步的想法。虚拟机中的物理内存是 qemu 启动中 mmap 出来的一块内存。所以我们读写这块内存，其实就是在读写虚拟机的物理内存。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_M4RJJVZ6XRSCCVG.png)

 

所以第一步，我们要先完成 HVP ßà GPA 转换。我们可以加载一个内核模块，从而获取到 EPT 的页表。拿到页表后，我们就可以将 GPA 翻译成 HPA。然后再从 HPA 转换成 HVA。

 

但是这样有一个缺点，想要从 HPA 翻译成 GPA 就比较麻烦了，需要遍历 ept 的表，效率非常低。

 

KVM 为了完成这个 GPA 到 HVA 的互相翻译，实现了一个 remap 机制。我们通过解析 kvm 的 remap 可以完成这个步骤，也可以通过 qemu 的两种内存管理模型来完成这项工作。

 

我们完成了上述功能后，我们就具备了读取任意 GPA 的能力了。但是现在的操作系统都是分页的，就跟前面所讲述的一样，通过页表进行了映射。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_XXG85W6Y5K6JXTZ.png)

 

所以说我们具备了 GPA 的任意地址读写能力还是不够的。我们还需要能够读取任意地址 GVA 才行。我们要想具备 GVA 的读写能力，我们就需要一个页表。有了页表，我们才能够自己翻译内存，找到 GVA 和 GPA 的对应关系。

 

现在的操作系统，每一个进程的用户态内存都是隔离的。内核态的内存是相同的。每一个进程都有一个独立的的页表，存放在进程控制块中。所以说我们要想能够读取任意进程的任意 GVA，我们就需要先拿到所有进程的页表。但是我们想要拿到所有进程的页表，我们就需要拿到所有进程控制块信息。

 

由于进程控制块是存放在内核地址空间的，进程的内核态地址空间都是相同的，所以说，我们只要拿到任意一个进程的 cr3，即可通过解析页表，来实现一个读写内核 GVA 的能力。有了这个能力，我们才能进行下一步操作。

 

问题来了，我们如何获得虚拟机中任意进程的 cr3 寄存器？

 

我们如何获取一个 cr3 寄存器的值呢？我们这里尝试了几种方法：  
1、通过 vmread 指令，读取 vmcs 中的 guest cr3。

 

2、通过对 vmexit handler 进行 hook。

 

3、Kvm 运行时，会把 cr3 保存在某个位置。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_FDDKFTXE3BWNKXP.png)

 

如图，只要设置 kvm_valid_regs 的值， kvm 在运行过程中就会自动把所有寄存器保存下来。经过调试发现，默认情况下，这个字段为 0。所以我们需要自己将他置为 1，之后我们就可以去读到 cr3 寄存器了。

 

有了 cr3 之后，我们自己写一套页表翻译的代码，将 GVA 转换成 GPA。我们就可以具备读写内核地址空间 GVA 能力了。我们需要适配各个模式，例如 32 位模式，PAE 模式，64 位模式，4k 页面模式，2M 页面，1G 页面等多种情况。

 

现在，我们只具备了读写内核地址空间任意 GVA，但是我们还不能读写任意进程用户态的任意内存。

 

如前面所述，每一个进程都拥有一个自己的页表。而这个页表存放在进程控制块中。而进程控制块在内核地址空间中。

 

所以接下来我们应该找到所有的进程控制块。进程控制块由操作系统内核进行管理，例如说 windows 平台下，在 ntoskrnl 模块中，我们可以通过解析 PspCidTable， PsActiveProcessHead 等来识别出所有的进程控制块。

 

但是我们目前无法知道这些数据结构所在的地址。所以我们当务之急，我们需要找到 ntoskrnl 模块的首地址在哪里？

 

如何找到它，其实方法很多，可以通过 IDT 中的中断向量的 handler 来进行定位，或者 msr 寄存器等等诸多方法。

 

例如说：我们首先在物理机读取到虚拟机的 IDT 表。获取异常向量的 handler。我们知道，异常向量的 handler，肯定是位于 ntoskrnl 模块中。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_83UXXTW2CCMMJFV.png)

 

第一种方法采用暴力搜索，向上搜做 mz 文件头，肯定能搜到。还是不够优雅。

 

第二种方法采用符号解析，我们通过解析内核符号，来获取 handler 在模块中的位置，Ntoskrnl 首地址 =handler 地址 – 偏移；这样我们就能够获取到内核模块首地址了。

 

我们既然要用到符号信息，那么我们就得具备解析符号的能力。我们的代码运行在 linux 平台，我们如何解决符号解析的问题？

 

对于 linux 虚拟机，我们解析 elf 文件的 debug info 信息，这里面是一个 dwarf 结构，开源，第三方库比较多。所以很好解决。

 

但是 windows pdb 符号如何解析呢。我们知道在 windows 平台下解析 pdb，调用 com 接口即可，非常简单。但是我们运行在 linux 平台上，是无法调用 windows 提供的 api 的。

 

微软最近几年公开了 pdb 相关的格式和代码。但是非常复杂，如果我们自己去解析，将耗费非常多的时间。于是我们想到了其他方法：

 

1、硬编码？放弃，维护很困难。  
2、Llvmpdbutil，解析成功，但是对于 win10 的符号信息解析崩溃，不知道现在 llvm 有没有修复这个问题。  
3、Wine？我们最终采用了 wine 的方式，开发一个 windows 平台的符号解析程序，然后运行在 wine 环境下，来完成 pdb 解析。

 

这样，我们就解决了符号解析的问题。

 

我们现在具备了符号解析的能力，知道内核模块的首地址，并且具备对内核地址空间任意地址读写的能力。我们就可以基于这些能力实现一个 ark 的工具，例如说：

 

解析 PspCidTable，PsActiveProcessHead 读取所有的进程信息；解析 PsLoadedModuleList 读取所有的内核模块信息等等，方法非常多，可以实现的功能也非常多，而且老前辈写过很多文章，这里就不一一讲解了。

 

当我们解析出所有的进程控制块的时候，我们就可以拿到进程对应的页表。通过解析进程对应的页表，我们就具备读写任意进程任意空间 GVA 的能力了。

 

此时有一个潜在的问题，由于内存分页的机制问题，会把不常用的内存交换到磁盘上。

 

这种情况我们就无法读取这块内存了，这个问题我们后续进行讲解。

 

经过我们不懈努力，我们已经具备一个 ark 初级的功能，例如：可以读取到虚拟机中的所有进程；每一个进程中，加载的模块信息；可以读取到虚拟机中所有的内核模块等等。这些都是调试器不可缺少的能力。

 

04 调试器设计

 

接下来我们介绍一下调试器的设计。

 

传统的虚拟机，在未开启硬件虚拟化加速时，采用的模拟执行。实现一个调试接口比较简单。采用了硬件虚拟化后，虚拟机不再需要模拟执行，具备了更高的性能。

 

虚拟机本身提供了一个 virtual JTAG 调试接口。只是在模拟执行和硬件虚拟化两种模式下原理不同。并且不支持 windows 虚拟机，不能区分用户态和内核态。

 

如果我们对 virtual JTAG 调试接口进行改造，二次开发。我们是否可以能实现 windows 内核态，用户态调试呢？

 

![](https://bbs.pediy.com/upload/attach/202110/236762_P4ZYDSVKDBWH666.png)

 

我们首先需要深入分析一下 virtual JTAG 的实现原理。我们以软件断点为例，会调用 kvmarch insert sw breakpoint 函数来插入一个断点，我们看这个代码实现，我们发现，就是保存了原来的位置的字节码，然后替换成了 cc。

 

把内存改写成一个 0xcc，就能实现断点功能？看似平平无奇，其实在 kvm_update_guest_debug 中存在着奥秘。

 

我们首先得介绍一下 intel 硬件虚拟化中的一个特性，exception bitmat 特性。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_BDFCJ887XT6E4V7.png)

 

他是一个 32 位的字段，每一位对应一个异常。当对应的位为 1 时，虚拟机中，产生对应的异常，就会产生 vmexit 事件。从而 host 可以进行捕获，并进行虚拟化。

 

kvm_update_guest_debug 函数，看名字就可以猜到，会和 kvm 进行交互。我们分析到最后，到最关键的位置，发现：最终通过一个 vmcs_write32 函数，更新了 vmcs 的 ExceptionBitmap，使得 vcpu 对 guest 中 int3 异常具备拦截能力。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_WFKZ92VAJJ5H5EV.png)

 

虚拟机中执行代码，如果遇到 int3 指令，会产生 vmexit，进入 host 模式，首先由宿主机接管，宿主机将 int3 指令封装成一个事件，投递给 qemu 中内置的 gdbserver 来处理。

 

接着我们整体梳理一下 virtualJTAG 流程：

 

![](https://bbs.pediy.com/upload/attach/202110/236762_ERF3CAE84GYEY2B.png)

 

1、Vcpu 遇到 int 3，会产生异常，如果 exception bitmap 中第四位为 1，则产生 vmexit 事件，并切换到 host 模式。  
2、执行 kvm 中注册的 vmexit handler。  
3、Handler 将此次的这个 vmexit 的事件封装成一个结构体，投递给 qemu。4、Qemu 把此事件交给内置的 gdb server。  
5、Gdb server 会和 gdb client 进行交互。  
6、Gdb server 收到请求后，返回到 vmexit handler 中。  
7、Vmexit handler 中调用 vmresume 指令，产生 vmentry 事件，虚拟机恢复执行。  
这个 virtual jtag 方案大概是这个原理。

 

我们通过分析发现，virtualJTAG 之所以不能调试用户态内存，不支持 windows，根本原因在于这个 gdbserver 不能识别 windows 的结构体，

 

无法解析虚拟机中的所有进程，所有模块等等系统信息。

 

所以我们要做的事情，就是帮它来完成这个功能。于是我们就有了实现一个基于 virtualJTAG 的调试接口的思路的。

 

我们通过我们自己的 ark，来识别所有的进程，进程中所有的模块。我们的 ark，具备对虚拟机任意进程，任意内存的读写能力，我们对想调试的位置，把内存改写成 int3。通过 ExceptionBitmap 的能力，拦截 int3 异常。后续的处理流程交给 qemu 内置的 gdbserver。

 

我们对内置的 gdb server 进行了修改，来完成了这个功能。有个问题是：是否可以采用硬件断点？其实采用硬件断点也是可以的，我们需要在 kvm 中对 dr 寄存器操作进行拦截，由于精力有限，所以并未实现。

 

其实不止如此，还有非常多的细节问题，例如说：

 

我们采用软件断点的方法，最终还是改写了内存，容易被检测到，怎么办？

 

用户态的内存，可能会被交换到磁盘，如何解决？  
对于系统动态库，copy_on_write 如何解决？  
Cpu 缓存问题？等等

 

有感兴趣的可以私下交流。我们需要把重点放在第一个问题上。用调试器下断点时还是把内存改写成了 int 3，如何才能不被检测到？

 

我们要做的一件事情就是隐藏 int3 断点。保证不被检测。

 

通过 ept 特性，对虚拟机的内存进行 hook，来欺骗虚拟机，使其无法感知到内存被修改。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_GMVEMGBJVCEVAB5.png)

 

如图所示，左边这部分时正常状态下的内存翻译流程，和权限，例如说，GPAàHPA 的翻译，此页面具备读写执行三个权限。

 

右边这部分时我们 hook 之后的状态。我们对原始内存页面进行复制，将权限进行拆分，分为读写权限对应原始内存，和执行权限对应复制的内存，对复制的内存改写 int3。

 

当 guest 进程读写这块内存的时，读取到的是原始页面。当 guest 进程执行这块内存的时候，将翻译成另一个已修改的另一个页面，执行的是修改成 int 3 的内存页面。

 

通过此方法，我们欺骗进程，让其无法检测到我们修改了内存。

 

我们通过 eptMTF 等特性，进行了一些其他功能的扩展，例如说指令 trace，内存读写监控。

 

05 平台介绍（KVM-Based security platform）

 

通过上述介绍，我们的安全对抗平台，大概原理想必大家都已经理解。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_S4SCG8TP9EU76VY.png)

 

现在我们介绍一下我们安全对抗平台的整体架构：

 

1、首先我们具备一个 linux 内核模块，用于 patchkvm，读写 kvm 中的关键数据，hookkvm 的关键函数。

 

2、我们需要对 qemu 进行二次编译，将我们自己实现的调试相关的代码移植到 qemu 去。使其具备调试能力。

 

3、Manager 模块，分为几个子模块。虚拟机管理功能；符号解析功能，支持 windows，支持 linux；鼠标键盘模拟功能，虚拟机屏幕图片查找功能；Hypervisorsdk，用于和内核模块，qemu 调试模块交互。

 

5、Python 引擎，用于将目前的大部分功能通过 python 接口的形式导出，降低开发门槛。方便安全人员参与开发

 

6、还开发了一个简易的 ui。

 

Python 插件，来实现一些强力的功能，例如 antirootkit，武器库，调试器等功能。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_BNWA4EK3GHQBZ25.png)

 

这是我们目前导出的部分 python 接口。例如说，获取所有进程，获取所有内核模块。获取符号信息。读写 GPA，读写 GVA，EPT hook， 内存读写执行监控等。

 

开发者，知道内核模块地址，进程控制块信息，然后通过解析符号的方法，可以轻松的开发其他的功能。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_UJBMFJCRU9XDHSM.png)

 

例如上面代码，大家可以通过非常简单的几行代码，就可以获取到虚拟机中的所有进程，所有内核模块等信息。

 

只需要在 python 中，importhypervisor_engine，即可。

 

接下来是视频演示：通过视频可以观察，我们的工具在运行过程中，不会出现虚拟机卡顿情况，而且不需要在虚拟机安装任何程序。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_JRG2H2ASV73T962.png)

 

![](https://bbs.pediy.com/upload/attach/202110/236762_7VXEZYBQ7BEU2ZA.png)

 

如果采用传统方法，对 working set 进行对抗，比较麻烦。通过我们平台提供的能力，几行代码就可以搞定。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_U5UZZ3XWKKN339M.png)

 

如图，非常简单，我们直接定位到内核的 PsWatchEnabled，直接进行修改，关闭 working set 的信息收集。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_8UFD58WX6BHRQQY.png)

 

调试能力展示，大家可以看到，我们在 linux 宿主机，直接调试虚拟机中的进程。

 

右边是被调试程序的 ida 截图，大家可以看一下汇编指令，和地址。左边是在物理机通过 gdb，调试虚拟机中的这个 demo 程序。可以观察，汇编指令，和地址都是对应的。

 

调试能力展示，大家可以看到，我们在 linux 宿主机，直接调试虚拟机中的进程。

 

![](https://bbs.pediy.com/upload/attach/202110/236762_RAT2P8N2B7CX972.png)

 

06 后续展望

 

1、武器库完善，后续希望把 ark 中的常用功能全部移植，实现一个完整的 ark。

 

2、通过 hook 虚拟机内核，完善行为监控工具，将沙箱检测能力放在 host 中。

 

3、后续尝试支持 arm 架构，通过 arm 服务器，运行安卓系统，完成对安卓系统的支持。

 

4、希望此工具可以帮广大安全人员解决安全对抗的疑难杂症

 

最后是这次议题相关的一些参考文献。那么今天我分享的议题就到这里，谢谢大家！

 

注意：可于下方附件获取本次峰会演讲完整 PPT！其它议题演讲 PPT 经讲师同意后会陆续放出！

[第五届安全开发者峰会（SDC 2021）10 月 23 日上海召开！限时 2.5 折门票 (含自助午餐 1 份）](https://www.bagevent.com/event/6334937)

最后于 1 小时前 被 Editor 编辑 ，原因：

[#活动](forum-45-1-108.htm)

上传的附件：

*   [基于 Qemukvm 硬件加速的下一代安全对抗平台. rar](javascript:void(0)) （5.88MB，25 次下载）