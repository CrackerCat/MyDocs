> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [vul.360.net](https://vul.360.net/archives/144)

> 在 2020 年 7 月，我们向谷歌上报了一条远程 ROOT 利用链，该利用链首次实现了针对谷歌旗舰机型 Pixel 4 的一键远程 ROOT，从而在用户未察觉的情况下实现对设备的远程控制。

> 在 2020 年 7 月，我们向谷歌上报了一条远程 ROOT 利用链，该利用链首次实现了针对谷歌旗舰机型 Pixel 4 的一键远程 ROOT，从而在用户未察觉的情况下实现对设备的远程控制。截至漏洞公开前，360 Alpha Lab 已协助厂商完成了相关漏洞的修复。该漏洞研究成果也被 2021 年 BlackHat USA 会议收录，相关资料可以在[这里](https://www.blackhat.com/us-21/briefings/schedule/#typhoon-mangkhut-one-click-remote-universal-root-formed-with-two-vulnerabilities-22946)找到。**该项研究成果也因其广泛的影响力在谷歌 2020 年官方漏洞奖励计划年报中得到了公开致谢，并斩获 “安全界奥斯卡”Pwnie Awards 的“史诗级成就” 和“最佳提权漏洞”两大奖项的提名。这条利用链也因其广泛的影响力被我们命名为“飓风山竹”。**

这篇文章将对利用链中使用的 Chrome V8 引擎漏洞（CVE-2020-6537）进行分析，并介绍该漏洞在利用过程中遇到的困难与限制，在研究过程中，我们先后提出了两种不同利用思路，其中的心路历程也会在文中进行分享。

The Bug
-------

`Promise.allSettled` 是一个 JavaScript 内建函数。从 MDN 的介绍可以了解到，该函数接收一个可迭代的对象作为参数，并返回一个 promise 对象。在所有位于可迭代对象中的 promise-like 元素得到处理后，这个 promise 对象将被 resolve，从而得到一个结果数组。下面是`Promise.allSettled` 的用法示例：

```
Promise.allSettled([
  Promise.resolve(1),
  Promise.reject(2)
])
.then(results => console.log(results));







```

可以看到，结果数组中包含了 2 个对象，分别描述了参数中传递的 2 个 promise 的处理结果。

在详细分析 V8 引擎对于`Promise.allSettled`的实现之前，需要强调一点：只有当参数中所有的 promise 都被处理后，allSettled 返回的 promise 才会被 resolve，这意味着 V8 内部应当有相应的实现机制，用于判断是否所有的 promise 都已经被处理，并决定何时 resolve 作为返回值的 promise。

以下源码分析均基于 V8 8.4.371 版本。`Promise.allSettled`是使用 [Touque language](https://v8.dev/docs/torque) 来实现的：

```
transitioning javascript builtin PromiseAllSettled(
    js-implicit context: Context, receiver: JSAny)(iterable: JSAny): JSAny {
  return GeneratePromiseAll(
      receiver, iterable, PromiseAllSettledResolveElementFunctor{},
      PromiseAllSettledRejectElementFunctor{});
}

```

`PromiseAllSettled`仅仅是调用了`GeneratePromiseAll`, 然后再调用至`PerformPromiseAll`。这个函数代码比较多，因此只在这里列出相关的部分：

```
transitioning macro PerformPromiseAll<F1: type, F2: type>(
    implicit context: Context)(
    constructor: JSReceiver, capability: PromiseCapability,
    iter: iterator::IteratorRecord, createResolveElementFunctor: F1,
    createRejectElementFunctor: F2): JSAny labels
Reject(Object) {
  
  while (true) {
    let nextValue: JSAny;

    const next: JSReceiver = iterator::IteratorStep(
        iter, fastIteratorResultMap) otherwise goto Done;
    nextValue = iterator::IteratorValue(next, fastIteratorResultMap);

    
    
    const remainingElementsCount = UnsafeCast<Smi>(
        resolveElementContext[PromiseAllResolveElementContextSlots::
                                  kPromiseAllResolveElementRemainingSlot]);
    resolveElementContext[PromiseAllResolveElementContextSlots::
                              kPromiseAllResolveElementRemainingSlot] =
        remainingElementsCount + 1;

    const resolveElementFun = createResolveElementFunctor.Call(
        resolveElementContext, nativeContext, index, capability);
    const rejectElementFun = createRejectElementFunctor.Call(
        resolveElementContext, nativeContext, index, capability);

    
    
    const nextPromise = CallResolve(
      UnsafeCast<Constructor>(constructor), promiseResolveFunction,
      nextValue);

    const then = GetProperty(nextPromise, kThenString);
    const thenResult = Call(
      nativeContext, then, nextPromise, resolveElementFun,
      rejectElementFun);
    
  }
  return promise;
}

```

大致上说，这个函数对传入的参数进行迭代，并对其中的每一个元素都调用了 promiseResolve。同时，函数中使用了`remainingElementsCount`这个变量来代表 “尚未处理完成的 promise 数量”，并将这个值保存在了 resolveElementContext 中，便于全局访问。我们可以用下面的伪代码来概括性的描述这个函数所做的事情：

```
for(promise in iterable) {
  remainingElementsCount += 1
  promiseResolve(promise).then(resolveElementFun, rejectElementFun)
}

```

当 promise 被 resolve 时，就会调用`resolveElementFun`；相应的，promise 被 reject 时，就会调用 `rejectElementFun` 。这两个函数分别由`createResolveElementFunctor` 和 `createRejectElementFunctor`生成，并且它们最终都会调用至`PromiseAllResolveElementClosure`。在这里，V8 会将 promise 处理的结果保存至一个数组中，同时减少 “尚未处理完成的 promise 数量” 的值。

```
transitioning macro PromiseAllResolveElementClosure<F: type>(
    implicit context: Context)(
    value: JSAny, function: JSFunction, wrapResultFunctor: F): JSAny {
  
  let remainingElementsCount =
      UnsafeCast<Smi>(context[PromiseAllResolveElementContextSlots::
                                  kPromiseAllResolveElementRemainingSlot]);
  remainingElementsCount = remainingElementsCount - 1;       
  context[PromiseAllResolveElementContextSlots::
              kPromiseAllResolveElementRemainingSlot] = remainingElementsCount;
  if (remainingElementsCount == 0) {
    const capability = UnsafeCast<PromiseCapability>(
        context[PromiseAllResolveElementContextSlots::
                    kPromiseAllResolveElementCapabilitySlot]);
    const resolve = UnsafeCast<JSAny>(capability.resolve);
    Call(context, resolve, Undefined, valuesArray);          
  }
  return Undefined;
}

```

可以看到，函数会从 resolveElementContext 中读取出 remainingElementsCount，减去 1，然后再保存回去（代码 [1] 处）。当 remainingElementsCount 减少至 0 时，代表所有 promise 都处理完毕，那么函数就会将结果数组返回给用户（代码 [2] 处）。

正常而言，`resolveElementFun` 和`rejectElementFun` 这两个函数，最多只能有一个被调用，代表着这个 promise 是被 resolve，还是被 reject（promise 不可能既 resolve，同时又 reject）。但是，通过一些回调手法，我们可以获得`resolveElementFun` 和`rejectElementFun` 这两个函数对象，从而有机会同时调用这两个函数。这将导致在处理一个 promise 对象时，`remainingElementsCount` 会被减去 2 次，于是进一步导致我们可以在并非所有 promise 都被处理完的情况下，提前拿到结果数组。此时，V8 内部和我们都会持有`valuesArray` ，这就为类型混淆创造了机会。

Type Confusion
--------------

让我们重新来审计`PromiseAllResolveElementClosure`这个函数，只不过这一次我们关心的是 V8 如何将 promise 的处理结果保存至`valuesArray` 中。

```
transitioning macro PromiseAllResolveElementClosure<F: type>(
    implicit context: Context)(
    value: JSAny, function: JSFunction, wrapResultFunctor: F): JSAny {
  

  
  
  const updatedValue = wrapResultFunctor.Call(nativeContext, value); 

  const identityHash =
      LoadJSReceiverIdentityHash(function) otherwise unreachable;
  assert(identityHash > 0);
  const index = identityHash - 1;

  
  const valuesArray = UnsafeCast<JSArray>(
      context[PromiseAllResolveElementContextSlots::
                  kPromiseAllResolveElementValuesArraySlot]);
  const elements = UnsafeCast<FixedArray>(valuesArray.elements);   
  const valuesLength = Convert<intptr>(valuesArray.length);
  if (index < valuesLength) {
    
    
    elements.objects[index] = updatedValue;                        
  } 
  
}

```

在代码 [4] 处，`valuesArray` 的 element 被直接当作 FixedArray 来进行处理。但与此同时，我们已经获得了`valuesArray`，并能够对其进行操作了。通过在其上设置一个较大的索引值，我们可以把它转换为一个 dictionary array，此时，就会出现 FixedArray 和 NumberDictionary 之间的类型混淆。

Exploitation
------------

在发现这个漏洞后，我们实现的第一套利用方法，在稳定性和兼容性上都存在一定问题，但仍不失为一个有趣的思路。最终的 Android Root 利用链中，我们采取的是另一种稳定性更高的方法。下面我们将分别进行介绍。

### Limitations

乍一看上去，利用 FixedArray 和 NumberDictionary 之间的类型混淆似乎很容易就能造成可控的越界写。当 V8 想要将结果保存至`valuesArray`时，会首先检查 index 是否越界。如果 index <array.length，那么 V8 就直接将结果写入 array.elements（如代码 [5] 所示）。这是因为 V8 假定了`valuesArray`一定是属于 PACKED_ELEMENT 类型，使用的是 FixedArray 来存储元素，这种类型的数组，一定会有 FixedArray 长度大于等于 array 长度的约束。如果满足了 index < array.length，显然也就满足了 index < FixedArray.length，因此向 FixedArray 写入数据是不可能发生越界的。但利用类型混淆，我们可以将`valuesArray`转换为 dictionary mode，此时使用的是 NumberDictionary 存储元素，array.length 可以是一个很大的值，而 NumberDictionary 的 size 却可以比较小。这样一来，我们就可以绕过 index < array.length 的检查，造成越界写。但实际情况真的是这样吗？

经过进一步测试发现，在 Torque 编译器生成形如 _elements.objects[index] = value_ 的代码时，是会额外加入越界检查的：

```
struct Slice<T: type> {
  macro TryAtIndex(index: intptr):&T labels OutOfBounds {
    if (Convert<uintptr>(index) < Convert<uintptr>(this.length)) {
      return unsafe::NewReference<T>(
          this.object, this.offset + index * %SizeOf<T>());
    } else {
      goto OutOfBounds;
    }
  }
  
}

```

这会最终执行到’unreachable code’，然后导致进程崩溃。因此，我们必须考虑其他方式。

另外的一个限制在于，越界写入的数据内容并不是我们可以控制的，它总是一个 JSObject 的地址，这个 object 生成于代码 [2] 处，例如： _{status: “fulfilled”, value: 1}_ 。

### The NumberDictionary

我们虽然能造成 FixedArray 与 NumberDictionary 之间的类型混淆，但是只能往 NumberDictionary 的范围内写入受限的内容。那么 NumberDictionary 中有什么内容是值得被写的呢？

首先来看一下 FixedArray 与 NumberDictionary 的内存结构对比：

![](https://vul.360.net/wp-content/uploads/2021/08/FixedArray_NumberDictionary-1.png)

可以看到，NumberDictionary 有着更多的 metadata fields。`Capacity`代表了 NumberDictionary 所能保存的最大 entry 数量，看上去是一个比较有价值的目标。通过将其修改为一个 JSObject 的地址（通常是一个很大的值），我们就得到一个畸形的 JSArray，并利用其中的 NumberDictionary 造成越界读写。然而，通过这种方式进行的越界访问偏移值却是不可预测的。

我们通过向普通 NumberDictionary 中写入一次数据为例：

```
let arr = [];
arr[0x10000] = 0x42;

```

为了写入 key-value，V8 需要确定两件事情。

1.  当前 NumberDictionary 中是否已经存在以 key 为索引的 entry，如果存在，则只需更新该 entry 即可
2.  如果不存在对应 entry，则可以使用一个空 entry，或者新增 entry

这个过程是通过`FindEntry`来完成的。

```
template <typename Derived, typename Shape>
InternalIndex HashTable<Derived, Shape>::FindEntry(IsolateRoot isolate,
                                                   ReadOnlyRoots roots, Key key,
                                                   int32_t hash) {
  uint32_t capacity = Capacity();
  uint32_t count = 1;
  Object undefined = roots.undefined_value();
  Object the_hole = roots.the_hole_value();
  USE(the_hole);
  
  for (InternalIndex entry = FirstProbe(hash, capacity);;
       entry = NextProbe(entry, count++, capacity)) {
    Object element = KeyAt(isolate, entry);
    
    
    if (element == undefined) return InternalIndex::NotFound();
    if (Shape::kMatchNeedsHoleCheck && element == the_hole) continue;
    if (Shape::IsMatch(key, element)) return entry;
  }
}


inline static InternalIndex FirstProbe(uint32_t hash, uint32_t size) {
  return InternalIndex(hash & (size - 1));
}

inline static InternalIndex NextProbe(InternalIndex last, uint32_t number,
                                      uint32_t size) {
  return InternalIndex((last.as_uint32() + number) & (size - 1));
}


uint32_t NumberDictionaryBaseShape::Hash(ReadOnlyRoots roots, uint32_t key) {
  return ComputeSeededHash(key, HashSeed(roots));
}

```

函数调用了`FirstProbe` 来决定从何处开始搜索 key。假设`FirstProbe` 返回了 _i_ ，且偏移为 _i_ 的 entry 不符合条件，那么 V8 将会调用`NextProbe` 来获得下一个偏移。这个尝试偏移的序列为：_i_, _i + 1_, _i + 1 + 2_, _i + 1 + 2 + 3_ …

`FirstProbe`接受 2 个参数，`size`代表 NumberDictionary 的容量，即我们覆写的 Capacity 字段，`hash` 则由`NumberDictionaryBaseShape::Hash`计算而来。不幸的是，`hash` 并不是可预测的，因为 V8 使用了一个 Int64 长度的随机值作为种子。

因此如果我们通过覆写 Capacity，以此来触发越界，那么计算出来的偏移将可能是 _[0, capacity – 1]_ 范围内的任意值。

### Strategy 1

既然我们不能控制越界的偏移，那么是否能利用堆喷来让越界访问变得 “有意义”？

正常而言，在 32 位环境下的堆喷比 64 位更稳定，因为 64 位环境下的地址空间实在是太大了。但是在 V8 堆上，情况可能有所不同。目前 64 位下的 V8 开启了名为[指针压缩](https://v8.dev/blog/pointer-compression)的配置，确保所有的 V8 对象都分配在一个 4GB 大小的空间中。这个配置反而让 64 位环境下的堆喷存在一定可能。

我们继续来分析 NumberDictionary 的元素存取方式。前文说到了，将一个 key-value 对保存在 dictionary array 中时，V8 需要在 NumberDictionary 中寻找到合适的 entry。`IsMatch` 函数负责检查当前的 key 是否等于 entry 中保存的 key。

```
bool NumberDictionaryBaseShape::IsMatch(uint32_t key, Object other) {
  DCHECK(other.IsNumber());
  return key == static_cast<uint32_t>(other.Number());
}

double Object::Number() const {
  DCHECK(IsNumber());
  return IsSmi() ? static_cast<double>(Smi(this->ptr()).value())
                 : HeapNumber::unchecked_cast(*this).value();
}

```

如果 entry 中保存的 key 不是一个`Smi`，V8 则会直接将其当作`HeapNumber`，然后把它的值转为`uint32_t`类型。这也可以理解为一次类型混淆，因为在触发越界访问时，位于越界堆上的数据可能为任意 object。一旦 V8 在越界堆上找到了所谓 “正确的”entry，它将往这个 entry 的 value field 中写入一个可控的值。因此，我们可以大量的在堆上伪造 entry，然后触发一次越界写，让 V8 往我们想要的地方写入值，从而造成影响更大的内存破坏。下面是我们采取的方式：

1.  使用 JSObject _`obj`_ 进行堆喷。
2.  触发一次越界写，让 V8 将 _`obj.properties`_ 当作 _`dictionary_entry.key`_ ，将 _`obj.elements`_ 当作 _`dictionary_entry.value`_ 。因此 V8 将向 _`obj.elements`_ 写入我们控制的值。在这里我们选择的是写入一个 double JSArray _`array`_。这会造成 FixedArray（_`obj.elements`_）和 JSArray（_`array`_）之间的类型混淆。
3.  现在，类似 _obj[idx] = value_ 的代码将会直接修改 _`array`_ 的内存，例如修改其 length。
4.  利用这个 length 被修改的 JSArray，达到任意地址读写的目标就很容易了。

下面的图片展示了在堆喷之后的内存布局：

![](https://vul.360.net/wp-content/uploads/2021/08/spray1.png)

举例来看，我们的目标是让 V8 将 0x21e60bedc760 处的内存当作一个 dictionary entry，同时让 V8 认为它找到了正确的 entry。Fake entry 中的 `Key` field 实际上是某个 JSObject 的 `Properties` field。V8 会将其视作一个`HeapNumber`，然后把它的 value 转换为`uint32_t`类型。在这里例子中，转换后的值是 3。因此我们只需要执行`confused_array[3] = xxx`，即可让 V8 覆写 Fake entry 的 `Value` field。

![](https://vul.360.net/wp-content/uploads/2021/08/spray2-1024x237.png)

到这里可能有人会产生一个疑惑，既然越界访问的偏移是随机的，那么如果 V8 没有访问到上面描述的那个 Fake entry 怎么办？实际上，我们可以通过利用 V8 寻找 entry 的特性以及合理控制堆喷的内容来解决这个问题：

1.  前文已经介绍过，当 entry 不符合要求时，V8 会利用 next probe 计算下一次访问的偏移。这就像堆喷中的 nop sled 一样，保证了访问 entry 这个操作会持续不断进行。
2.  由于指针压缩特性，V8 的堆只有 4GB 大小，完全可以在一个可接受的时间内完成堆喷。

完成这一步之后，实现任意地址读写就是一件很简单的事情了。目前已有很多优秀的资料介绍了相关内容，在这里不再赘述。

### Strategy 2

上述利用思路存在着一些缺点：

*   它不是一个 100% 成功率的方案
*   它无法在 32 位环境中使用

而当时 Pixel 4 上的 Chrome 是 32 位的，意味着并不能满足要求。在之后的几周时间，我们找到了新的利用思路。

重新回顾这张对比图：

![](https://vul.360.net/wp-content/uploads/2021/08/FixedArray_NumberDictionary-2.png)

除了修改 Capacity 之外，是否有其他更好的选择？经过研究我们发现，MaxNumberKey 这个字段有着非常特殊的含义。MaxNumberKey 代表了这个数组中保存的所有元素的最大索引值，同时，其最低有效位表明了数组中是否存在特殊元素，例如 accessors。以如下代码为例，我们可以在数组上定义一个 getter：

```
let arr = []
arr[0x10000] = 1
Object.defineProperty(arr, 0, {
  get : () => {
    console.log("getter called")
    return 1
  }
}) 

```

此时，MaxNumberKey 最低有效位为 0，代表存在特殊元素。但是通过漏洞，我们可以将其覆写为一个 JSObject 的地址，而在 V8 中，任何 HeapObject 地址的最低位，恰好为 1。即经过覆写的数组，即使上面定义了特殊元素，V8 也会认为它不再特殊。

接下来，我们需要寻找能够充分利用这一影响的代码，在这里我们选择了 Array.prototype.concat 函数。该函数会调用至`IterateElements`，用于迭代被连接的数组。

```
bool IterateElements(Isolate* isolate, Handle<JSReceiver> receiver,
                     ArrayConcatVisitor* visitor) {
  
  if (!visitor->has_simple_elements() ||
      !HasOnlySimpleElements(isolate, *receiver)) {
    return IterateElementsSlow(isolate, receiver, length, visitor);
  }
  
  FOR_WITH_HANDLE_SCOPE(isolate, int, j = 0, j, j < fast_length, j++, {
    Handle<Object> element_value(elements->get(j), isolate);
    if (!element_value->IsTheHole(isolate)) {
      if (!visitor->visit(j, element_value)) return false;
    } else {
      Maybe<bool> maybe = JSReceiver::HasElement(array, j);
      if (maybe.IsNothing()) return false;
      if (maybe.FromJust()) {
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_value,
            JSReceiver::GetElement(isolate, array, j), false);
        if (!visitor->visit(j, element_value)) return false;
      }
    }
  });

} 

```

在代码 [6] 处，V8 检查了数组是否含有特殊元素，我们通过覆写 MaxNumberKey，可以绕过这一检查，让函数进入后续的快速遍历路径。在代码 [8] 处，GetElement 将触发 accessor，执行自定义的 js 代码，从而有机会将数组的长度改为一个更小的值。随着遍历循环中的索引不断增大，最终在代码 [7] 处，会发生越界读。

```
var arr; 
var victim_arr = new Array(0x200);
Object.defineProperty(arr, 0, {
  get : () => {
    print("=== getter called ===");
    victim_arr.length = 0x10;   
    gc();
    return 1;
  }
});

arr.concat(victim_arr);

```

通过上述方案，我们将原本的类型混淆，转换成了另一处越界读问题。利用越界读，我们就拥有了 fake obj 的能力，进而也可以轻松实现任意地址读写了。

Conclusion
----------

本文对 CVE-2020-6537 的成因进行了分析，并介绍了两种利用思路。这个漏洞是我们远程 ROOT Pixel 4 利用链中的一环，在后面的系列文章中，我们将会对利用链中的提权漏洞进行详细介绍。