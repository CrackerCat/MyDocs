> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [github.com](https://github.com/veritas501/pipe-primitive)

> An exploit primitive in linux kernel inspired by DirtyPipe - veritas501/pipe-primitive: An exploit pr......

[](#pipe-primitive)pipe-primitive
=================================

An exploit primitive in linux kernel inspired by DirtyPipe (CVE-2022-0847).

前些日子，我像众多安全前辈那样对 DirtyPipe（CVE-2022-0847）漏洞进行了学习和复现，深深感觉到这个洞的好用，这个洞始于一处内存的未初始化问题，终于对任意文件的修改，且中途不涉及 KASLR 的 leak 以及 ROP、JOP 等操作。因此无需绕过 SMEP，SMAP 等保护。

复现完后，我开始思考，DirtyPipe 这个洞为什么好用？难道随着 DirtyPipe 的修复，它就会像昙花一现一样，对将来的漏洞利用不具备任何学习价值吗？

突然，我意识到，DirtyPipe 所在结构体——`struct pipe_buffer`，似乎非常的耳熟。啊！它不正是那个用`GFP_KERNEL_ACCOUNT`flag 分配的，位于 slab-1k 中，且包含一个 ops 字段常被我拿来用于做 KASLR leak 和 RIP 劫持的结构体吗？

随即我感到自己像个傻子，当时为什么要去修改 pipe_buffer 的 ops 做 ROP？直接修改 pipe_buffer 的 flags 并配合 splice 不就直接做到任意文件写了嘛！这样就不用 leak kaslr，也就不需要对不同内核版本做 exploit 适配，也不用管 gadgets 的事情，也不需要绕过 SMEP，SMAP，KPTI 等保护了。

我马上掏出了之前复现学习 CVE-2021-22555 及其他涉及 pipe_buffer 结构体的 exploit，稍作修改，马上就能在未打补丁的不同版本内核中利用成功，下面是几个例子：

*   [https://github.com/veritas501/CVE-2021-22555-PipeVersion](https://github.com/veritas501/CVE-2021-22555-PipeVersion)
*   [https://github.com/veritas501/CVE-2022-0185-PipeVersion](https://github.com/veritas501/CVE-2022-0185-PipeVersion)
*   [https://github.com/veritas501/CVE-2022-25636-PipeVersion](https://github.com/veritas501/CVE-2022-25636-PipeVersion)

由于在这之前并没有看到有人将其作为一种原语用于 Linux kernel exploit 中，所以本人就自作主张的将其称为 “**Pipe Primitive**” 吧 XD。

**总结一下**，就是需要获取到对 Pipe 结构体的修改能力，比如可以是 slab-1k 下的 UAF，或是 slab-1k 下带偏移的（即不是按顺序的直接 overflow）越界写。

这样，在 kernel >= 5.8 中，我们只需修改 pipe_buffer 中 splice 页的`flag |= PIPE_BUF_FLAG_CAN_MERGE`即可（有能力可以顺便把 offset 和 len 改成 0，这样就能从文件的开头开始写）；在 kernel < 5.8 中，需要先 leak 一下 pipe_buffer 中的 anon_pipe_ops，然后将 splice 页的的 ops 改为 anon_pipe_ops（因为 < 5.8 版本中能否 merge 是看 ops 的）（有能力依然可以顺便把 offset 和 len 改成 0）。

至于你问这样的话容器逃逸怎么做？我想要做的应该和 CVE-2019-5736 差不多吧 XD。