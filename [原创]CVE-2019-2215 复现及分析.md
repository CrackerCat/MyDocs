> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-264932.htm)

目录

*   [受影响机型](#受影响机型)
*   [poc](#poc)
*   [基础知识](#基础知识)
*            了解 epoll
*            [源码解读](#源码解读)
*            [EPOLL_CTL_ADD](#epoll_ctl_add)
*            [epoll_create 函数](#epoll_create函数)
*            [EPOLL_CTL_DEL](#epoll_ctl_del)
*   [heapspray 的理念](#heapspray的理念)
*   [漏洞利用：](#漏洞利用：)
*   [泄露内核进程地址](#泄露内核进程地址)
*            patch addr_limit(任意地址写）
*   [有些手机会崩溃](#有些手机会崩溃)
*   [其他知识点](#其他知识点)
*            [Printk 不可见的原因](#printk不可见的原因)
*            [日志的插入位置](#日志的插入位置)
*   [总结](#总结)
*   [适配情况：](#适配情况：)
*   [Patch](#patch)
*   [References](#references)

受影响机型
=====

1) Pixel 2 with Android 9 and Android 10 preview

 

2) Huawei P20

 

3) Xiaomi Redmi 5A

 

4) Xiaomi Redmi Note 5

 

5) Xiaomi A1

 

6) A3

 

7) Moto Z3

 

8) Oreo LG phones (run according to)

 

9) Samsung S7, S8, S9

 

10) Kernel 3.4.x and 3.18.x on Samsung Devices using Samsung Android and LineageOS

 

11) It works on Pixel 1 and 2, but not Pixel 3 and 3a.

 

12) It was patched in the Linux kernel >= 4.14 without a CVE

 

13) accessible from inside the Chrome sandbox.

 

根据 https://bugs.chromium.org/p/project-zero/issues/detail?id=1942 公开的 poc 拿到了拿到了任意内核读写权限。后续的文章为 https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/，这个漏洞比较好用，可以在公开的漏洞中能够 root 比较新的机器。

 

基于原始的 poc 代码任意地址写的基础上在 patch kernel 绕过了一些缓解机制所做的完整的工作，但拿到任意地址写的的原理的过程并未开篇陈述，基于此，本人开始着手复现并阐述这里面的实现原理以及漏洞利用的方法。

poc
===

```
#include #include #include #include #define BINDER_THREAD_EXIT 0x40046208ul
 
int main()
{
 int fd, epfd;
 struct epoll_event event = { .events = EPOLLIN };
 fd = open("/dev/binder", O_RDONLY);
 epfd = epoll_create(1000);
 epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
 ioctl(fd, BINDER_THREAD_EXIT, NULL);
} 
```

*   官方描述如下：

> As described in the upstream commit:  
> “binder_poll() passes the thread->wait waitqueue that  
> can be slept on for work. When a thread that uses  
> epoll explicitly exits using BINDER_THREAD_EXIT,  
> the waitqueue is freed, but it is never removed  
> from the corresponding epoll data structure. When  
> the process subsequently exits, the epoll cleanup  
> code tries to access the waitlist, which results in  
> a use-after-free.”

 

其含义就是：

 

就是 binder_thread->waitqueue 成员链表中链接了 epoll data 结构，但当调用了 BINDER_THREAD_EXIT 对应的方法，就会导致 binder_thread 被释放，当程序结束的时候，epoll 相应的结构重复遍历到此成员，造成 uaf。

*   对应的 poc 步骤为：

1.  open(“/dev/binder”), 会创建 binder_thread
    
2.  epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event); 初始化 binder_thread->wait_queue_head_t, 调用 add_wait_queue 插入 wait_queue_t 到 binder_thread.wait 中,
    
3.  ioctl(fd, BINDER_THREAD_EXIT, NULL); 释放 binder_thread 结构体
    
4.  程序结束的时候，会遍历这个链表中，触发 uaf
    
5.  此外，如果调用 epoll_ctl(epfd, EPOLL_CTL_DEL, fd,event) 也会遍历到这个链表中触发漏洞，原因是调用 remove_wait_queue, 然后删除 wait_queue_t，会遍历到 binder_thread->wait 成员（wait_queue_head_t）这样可以跟 4 是一样的效果。
    

*   poc 还可以这样写：
    
    ![](https://bbs.pediy.com/upload/attach/202101/726411_B7J88VCX43WG3QM.png)
    

基础知识
====

了解 epoll
--------

好了，写完 poc 之后，在讲解利用之前，不妨看一下内核的基本流程和一些基本概念：

1.  epoll 是 select 和 poll 的升级版，应用程序中调用 select() 和 poll() 函数, 使进程进入睡眠之前, 内核先检查设备驱动程序上有无对应事件的状态, 此时可通过查看 poll() 函数的返回值。
    
2.  能够在返回值上使用的宏变量有以下组合:  
    POLLIN, POLLPRI, POLLOUT, POLLERR, POLLHUP, POLLNVAL, POLLRDNORM, POLLRDBAND, POLLWRNORM, POLLWRBAND, POLLMSG, POLLREMOVE  
    这些值中使用最多的是下面几个组合:
    

· POLLIN | POLLRDNORM 表示可读

 

· POLLOUT | POLLWRNORM 表示可写

 

. POLLERR 表示出错

源码解读
----

它们是如何初始化，结构体是怎么样的？

EPOLL_CTL_ADD
-------------

epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event); 会调用 binder_poll 函数。/dev/binder 绑定了一些系统调用，并且实现了 binder_poll，binder_poll 中对 binder_thread.wait 进行了初始化，并调用 add_wait_queue(重点）。

 

其具体调用链为 EPOLL_CTL_ADD->ep_insert()->binder_poll 函数，binder_poll 函数会获取 binder_thread 结构，调用 poll_wait.

*   binder 设备实现的函数如下图：
    
    ![](https://bbs.pediy.com/upload/attach/202101/726411_A8D29R6CZ52M4GM.png)
    

/dev/binder， 会有 binder_poll 这个调用

 

![](https://bbs.pediy.com/upload/attach/202101/726411_5Y4V5C7FJAJCZZ8.png)

 

binder_poll 调用核心的函数为 poll_wait

 

![](https://bbs.pediy.com/upload/attach/202101/726411_DBYN87C9BTMMYNA.png)

 

poll_wait() 会调用 epq.pt.qproc 所对应的回调函数 ep_ptable_queue_proc, 执行 add_wait_queue 操作。

 

![](https://bbs.pediy.com/upload/attach/202101/726411_MFK8FAQYYE3REB9.png)

 

以上其具体含义为设置 pwq->wait 的成员变量 func 唤醒回调函数为 ep_poll_callback；并将 ep_poll_callback 放入等待队列 whead 中，ep_poll_callback 函数核心功能是当目标 fd 的就绪事件到来时，将 fd 对应的 epitem 实例添加到就绪队列。当调用 epoll_wait() 时，内核会将就绪队列中的事件报告给应用。

 

也就是 ep_insert 会调用到 ep_item_poll->binder_poll->poll_wait。

 

![](https://bbs.pediy.com/upload/attach/202101/726411_5728TDVKBBWHN5J.png)  
binder_poll 调用核心的函数为 poll_wait

 

![](https://bbs.pediy.com/upload/attach/202101/726411_DPMPW2NPAMUQ6WS.png)

 

主要结构体的初始化都发生在 ep_insert->binder_poll 中，poll_wait 的第一个参数为 binder 的 fd, 第二个参数为 binder_thread 的 wait 成员。来看一下它的成员情况：

```
struct binder_thread {
    wait_queue_head_t wait;
；；；；；；；；；；
}
struct __wait_queue_head {
    spinlock_t        lock;
    struct list_head    task_list;
};
struct __wait_queue {
    unsigned int        flags;
    void            *private;
    wait_queue_func_t    func;
    struct list_head    task_list;
};

```

![](https://bbs.pediy.com/upload/attach/202101/726411_GRRNMSFFQKUG7D4.png)

 

当调用一次 add_wait_queue 增加 wait_queue_t

 

![](https://bbs.pediy.com/upload/attach/202101/726411_8AK5QYY8QXWX95E.png)  
当 insert 多次就会变为以下:

 

![](https://bbs.pediy.com/upload/attach/202101/726411_GE75MZM76QSMD6F.png)

epoll_create 函数
---------------

以上成员如何初始化的呢？ 需要了解 epoll_create 函数，`open(“/dev/binder”)`进入内核会调用`binder_open`分配`binder_proc`结构体，epoll_create 会调用 ep_alloc，对成员进行初始化

 

![](https://bbs.pediy.com/upload/attach/202101/726411_KHNNWJEE9RXNYZX.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_Q4BZZ979TJKPNPH.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_CB9UYSRR772W623.png)

 

在这个链表中，有两种数据结构：等待队列头（wait_queue_head_t）和等待队列项（wait_queue_t）。等待队列头和等待队列项中都包含一个 list_head 类型, 由于我们只需要对队列进行添加和删除操作，并不会修改其中的对象（等待队列项）一开始它是 INIT_LIST_HEAD(&q->task_list); next,prev 指针分别指向自己。

*   当初始化时：
    
    ![](https://bbs.pediy.com/upload/attach/202101/726411_GKSSGNEYB737999.png)
    

而对队列项的初始化 wait_queue_t 在

 

![](https://bbs.pediy.com/upload/attach/202101/726411_GDZBU97EE2PQSQE.png)

EPOLL_CTL_DEL
-------------

epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event); 函数相对比较简单，会调用 remove_wait_queue

 

![](https://bbs.pediy.com/upload/attach/202101/726411_B9ZRQBSSZK2FYG5.png)

 

当调用 remove_wait_queue

 

![](https://bbs.pediy.com/upload/attach/202101/726411_M3FTM65RX6VY6W5.png)

heapspray 的理念
=============

1.  readv 和 writev 堆喷。
2.  Time of check time of use，简称 toctou，堆喷完，中间会有一个等待时机，阻塞住内核，可以绕过 check，内核的数据通过漏洞已经被改写，然后再 use，可以转化为任意地址读或者写。

既然看完了内核的追溯过程，回到 poc 本身如果是 binder_thread 结构体的释放，并且是 uaf，就会离不开堆喷。

 

其内核的源码追溯如下：

 

readv 和 writev 内部会调用 kmalloc 分配空间，内部采用分散读（scatter read）和集合写（gather write），内核都会调用到 do_loop_readv_writev 函数。  
![](https://bbs.pediy.com/upload/attach/202101/726411_T7JDA86CDFV83JY.png)  
可以参考 retme 的 https://speakerdeck.com/retme7/the-art-of-exploiting-unconventional-use-after-free-bugs-in-android-kernel  
![](https://bbs.pediy.com/upload/attach/202101/726411_QTTCG7KZGVHZA9C.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_C7NHTQZXBKH45KQ.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_7T2KZ2SRPZWDWJ9.png)

 

ssize_t readv(int fd, const struct iovec *iov, int iovcnt);

 

ssize_t writev(int fd, const struct iovec *iov, int iovcnt);

 

也会再开始调用 rw_copy_check_uvector，其源码如下：

 

![](https://bbs.pediy.com/upload/attach/202101/726411_EVTPMZ5AMATYWVQ.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_WTRZ4CBWFTZRFGR.png)  
调用 kmalloc 分配大小，然后根据 iov_base 依次进行写入或者读取 iov_len 长度的内容。

```
struct iovec
{
    void __user *iov_base;    /* BSD uses caddr_t (1003.1g requires void *) */
    __kernel_size_t iov_len; /* Must be size_t (1003.1g) */
};

```

关键要理解的是随着 readv 和 writev 调用 kmalloc 分配完相应的对象，并对之前 free 掉的 object 进行占位时，会等待 write 和 read 的调用，中间会有一个时机是触发漏洞的时机，以方便对 iov_base 的修改。

[](#漏洞利用：)漏洞利用：
===============

从这里开始分析如何从 poc 转变为 kernel 的任意地址读写，至于任意读写之后到拿到 root 部分因为网络资料较多，暂不分析

 

所使用的手机环境为 pixel 2, linux 内核版本 tag 为 4.4.116-gbcd0ecccd040

 

作者的 exp 可以分为两次的触发漏洞

1.  触发漏洞，通过创建 pipe，writev（堆喷）和 read 配合使用，泄露 task_struct 地址。
    
2.  触发漏洞， 创建 socket，readv（堆喷）和 write 配合使用，实现 patch addr_limit 内核变量，打开任意内核地址读写
    
    注意这两步都会重新触发漏洞，每一步两个函数的之间的调用是有时间差的，并且都会等待下一个函数的开始调用，比如 writev 会等待 read 的调用，否则一直阻塞，所以会 fork 子进程之前会有 sleep 的动作，以保证执行的先后顺序，fd(文件描述符) 之间可以父子进程共享。
    
    接下来详细解释：
    

泄露内核进程地址
========

先看第一步：leak_task_struct，观察 step1-6（按时间先后顺序）的运行, 放大图片来观看  
![](https://bbs.pediy.com/upload/attach/202101/726411_3EPBJV8G8AE8DYV.png)

 

![](https://bbs.pediy.com/upload/attach/202101/726411_ZNYJPRK5MBKGRP6.png)  
简单总结下：

 

1.EPOLL_CTL_ADD 会调用 add_wait_queue

 

2.BINDER_THREAD_EXIT 释放 binder_thread.

 

3. 调用 writev 堆喷大小一样的 binder_thread 结构体.

 

4. 调用 EPOLL_CTL_DEL 即 remove_wait_queue 对链表进程删除，会造成 iov_base 的修改.

 

5. 然后调用 read, 绕过内核的检查，读取 iov_base 的内容，即造成内核地址数据的泄露。

 

关键在于 remove_wait_queue 中

 

![](https://bbs.pediy.com/upload/attach/202101/726411_KJY98CC5MAVCFVZ.png)

 

数据成员指向了自己，read 的时候读出了内核地址。

 

我在内核中也打印 log 验证了这一点  
![](https://bbs.pediy.com/upload/attach/202101/726411_USWPUS9RWH65QXP.png)  
之前的漏洞利用都是通过 readv 进程堆喷，已经检查过 iov_base, 没有数据，会一直阻塞，这时候会等待 write 的到来，然而中间的某个时刻会触发漏洞改变 iov_base 为 kernel address，然后进行 write，可以往 kernel_address 写入内容，实现内核地址写, 而这种相反的方式扩大了一些苛刻场景的漏洞利用，达到了绕过 kalsr 的技巧。

patch addr_limit(任意地址写）
-----------------------

![](https://bbs.pediy.com/upload/attach/202101/726411_DZBWXAP2E8JDJ9C.png)

 

![](https://bbs.pediy.com/upload/attach/202101/726411_QPEJ3UHSUZPE8PT.png)  
注释已经写的很清楚了。

```
iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned;
iovec_array[IOVEC_INDX_FOR_WQ].iov_len = 1;
iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_base = (void *)0xDEADBEEF;
iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_len = 0x8 + 2 * 0x10;
iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_base = (void *)0xBEEFDEAD;
 
iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_len = 8;

```

当 epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event); 调用完毕，

```
iovec_array[IOVEC_INDX_FOR_WQ].iov_len = &(binder_thread->wait+8)                 iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_base =&(binder_thread->wait+8)

```

这时候 write 调用开始连续写入 iov_base. 写入的内容如下：

```
unsigned long second_write_chunk[] = {
    1, /* iov_len */
    0xdeadbeef, /* iov_base (already used) */
    0x8 + 2 * 0x10, /* iov_len (already used) */
    current_ptr + 0x8, /* next iov_base (addr_limit) */
    8, /* next iov_len (sizeof(addr_limit)) */
    0xfffffffffffffffe /* value to write */
  };

```

注意因为在 //step 2 write(socks[1], "X", 1) 已经提前写入长度为 1 的值，所以对 iov_len 的修改后期并没有起作用，否则将会拷贝 iovec_array[IOVEC_INDX_FOR_WQ].iov_len = &(binder_thread->wait+8) 长度的数据到 dummy_page_4g_aligned。

 

然后 step 5 中

 

write(socks[1],second_write_chunk,sizeof(second_write_chunk)) 开始对

 

iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_base =&(binder_thread->wait+8) 这个地址进行写入，长度为 0x8 + 2 * 0x10

 

这时候 binder_thread 的内部数据发生变化：

```
binder_thread.wait.task_list.next = 1 //iov_len
 
binder_thread.wait.task_list.prev = 0xdeadbeef //base
 
binder_thread.x1 = 0x8 + 2 * 0x10 //len
 
binder_thread.x2 = current_ptr + 0x8//base
 
binder_thread.x3 = 8

```

继续进行执行程序:

```
iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_base = (void *)0xBEEFDEAD;
 
 iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_len = 8;

```

因为这 iovec_array 是堆喷的数据，它其实相当于 binder_thread.x2 的内容，已经由 0xBEEFDEAD 修改成 current_prt+0x8 了，这时候 second_chunk 只剩下最后一个值 0xfffffffffffffffe，然后继续 write(fd,current_prt+0x8, 0xfffffffffffffffe), 达到 patch addr_limit，从而实现任意内核写，拿到 root:

 

这里需要注意的是：int recvmsg_result = recvmsg(socks[0], &msg, MSG_WAITALL); MSG_WAITALL 的标志起到了等待 write 调用的完成，也就是一直会等待下去。

 

对应 android 9， 10 都运行拿到了 root，以下为 android10 的运行日志。

 

![](https://bbs.pediy.com/upload/attach/202101/726411_PXPVMNC35SD8C57.png)

有些手机会崩溃
=======

1.  崩溃地方在 spin_lock_irqsave(&q->lock，flags)，![img] ![](https://bbs.pediy.com/upload/attach/202101/726411_4TD4WB5JBPQ9QNH.png)

1.  readv 和 write 调用，会将所有的内容写入 dummy_page_4g_aligned 中，可能内核 read 和 write 实现的机制不同，但这部分还未分析。

其他知识点
=====

Printk 不可见的原因
-------------

```
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 0a51559..279d5ff 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -1514,7 +1514,7 @@ char *pointer(const char *fmt, char *buf, char *end, void
                case 3: /* restrict all non-extensioned %p and %pK */
                case 4: /* restrict all non-extensioned %p, %pK, %pa*, %p[rR] */
                default:
-                       ptr = NULL;
+                       //ptr = NULL;
                        break;
                }
                break;

```

或者 echo 0>/prcoc/sys/kernel/kptr_restrict

 

dmsg

 

cat /proc/kmsg

 

cat /dev/kmsg。

日志的插入位置
-------

分别在 add_wait_queue，remove_wait_queue 和 binder_free_thread 函数插入前后的 log 并以进程名字为过滤，指针有可能会被其他的值覆盖，所以最好不要用 %p, 否则内核会崩溃在自己写的 log 上

总结
==

此次漏洞由 syzcaller 产生，主要在于设备实现了 binder_poll 函数，binder_poll 函数内部使用了 binder_thread 结构成员，但未考虑 binder_thread 结构如果已经释放的情况下，epoll 机制仍然使用其中的成员，导致的 uaf，其 patch 在释放 binder_thread 结构提前会对 epoll 上的链表进行清理，其漏洞利用特点来看，是 tocttou 的升级利用，衍生出了某些条件下可以遇到 uaf，或者 heap overflow 这类漏洞实现信息泄露和绕过 kalsr 的有效机制。

 

于 2019 年 11 月记录，分享出来与大家一起学习。

[](#适配情况：)适配情况：
===============

A use-after-free in binder.c allows an elevation of privilege from an application to the Linux Kernel. Aimed at kernel 4.4

 

https://github.com/kangtastic/cve-2019-2215/blob/master/cve-2019-2215.c

 

A use-after-free in binder.c allows an elevation of privilege from an application to the Linux Kernel. Use one way and aimed at kernel 4.4

 

https://github.com/kangtastic/cve-2019-2215/blob/master/cve-2019-2215.c

 

A use-after-free in binder.c allows an elevation of privilege from an application to the Linux Kernel. Use another way to root and aimed at kernel 3.18 and kernel 4

 

https://pastebin.com/mDaGMM6K

Patch
=====

![](https://bbs.pediy.com/upload/attach/202101/726411_D5CCME994TNZRK3.png)  
增加了

 

![](https://bbs.pediy.com/upload/attach/202101/726411_U82KBEEYUAYVU9Y.png)  
在 free binder_thread 的时候会对 wait_queue_head 进行处理, 置 0

 

在 ep_poll_callback 中：

 

![](https://bbs.pediy.com/upload/attach/202101/726411_N7M2RDA2TEV7952.png)  
![](https://bbs.pediy.com/upload/attach/202101/726411_NWUUAJAUTTGAM6T.png)

References
==========

crash:

 

https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414028

 

issue:

 

https://bugs.chromium.org/p/project-zero/issues/detail?id=1942

 

poc: https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414030

 

https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414885

 

patch:

 

https://elixir.bootlin.com/linux/latest/ident/POLLFREE

 

https://pacsec.jp/psj17/PSJ2017_DiShen_Pacsec_FINAL.pdf

 

https://github.com/externalist/exploit_playground/blob/master/CVE-2016-2434/exploit_CVE-2016-2434_commented.c

 

https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=5&ved=2ahUKEwit3fb2zLHlAhWNF6YKHX_DC1UQFjAEegQIAhAB&url=https%3A%2F%2Fsecurityaffairs.co%2Fwordpress%2F92633%2Fhacking%2Fcve-2019-2215-zero-day-exploit.html&usg=AOvVaw2ItkF7ngwGi8z6SfNtHj3x

 

epoll 的简单描述:

 

https://www.cppfans.org/1418.html

[看雪社区年底排行榜，查查你的排名？](https://www.kanxue.com/rank.htm)