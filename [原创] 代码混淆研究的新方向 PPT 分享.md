> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.pediy.com](https://bbs.pediy.com/thread-270019.htm)

> [原创] 代码混淆研究的新方向 PPT 分享

混淆技术的研究，在软件保护，云计算，免杀等领域有着极其重要的作用。

西安交通大学的两位网安新生火种对混淆模型的研究，具体函数的安全类介绍，特殊混淆模型，以及代码混淆技术的推广与实际应用，甚至到未来该项技术的展望，都值得我们去学习和深思。

下面就让我们来回顾 [2021 看雪第五届安全开发者峰会](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458396801&idx=1&sn=2d13a137f3d17766558e8689d48fd341&chksm=b18f180b86f8911d25d2ff9e0c50068c4e202187e72f9b77fe1bfcfcc14ffd662805264c7dab&scene=21#wechat_redirect)上**《代码混淆研究的新方向》**此议题的精彩内容。

演讲嘉宾  

=======

![](https://bbs.pediy.com/upload/attach/202110/236762_X495RUSZ7X4R3EM.jpg)

【程瑞 - 西安交大智能网络与网络安全实验室】

程瑞：西安交通大学软件工程学院，智能网络与网络安全实验室，参与代码混淆与代码相似度检测课题研究。研究兴趣为程序分析，Fuzzing，恶意软件检测。

![](https://bbs.pediy.com/upload/attach/202110/236762_JYH5HZUK9JEMEJW.jpg)

【南子龙 - 西安交大智能网络与网络安全实验室】

南子龙：西安交通大学微电子科学与技术学院，网络安全社团负责人。研究兴趣为密码学应用，IoT 安全，量子器件，同态芯片。

演讲内容  

以下为速记全文：

大家好，我们今天分享的议题名称为《代码混淆研究的新方向》，我是来自西安交通大学的程瑞，作者列表中还有一位就是范铭，范铭老师是我在实验室学习时的导师，不过很可惜他今天没有到场。我们今天的报告分为两个部分，第一部分由我来介绍，第二部分由南子龙同学来介绍。

引言
==

首先是引言部分，也就是代码混淆的定义以及应用。代码混淆可以看成是一个转换过程，它接受一个程序 P 作为输入输出混淆后的程序，P'相比于 P 其分析难度应该增加了。

![](https://bbs.pediy.com/upload/attach/202110/236762_9ZMEYV5CHZ8DSUQ.jpg)

图中就是一个代码混淆的案例，可以看到混淆后的程序 P 具有更多的流程转移以及算术运算指令，同时混淆转换前后的语义应该是相等的，形式化一点的定义就是当它们接受相同且合法的输入时，应该产生相同的输出。

代码混淆的应用场景就是保护那些不得不执行于不可信执行环境的代码，不可信的执行环境指的是攻击者能够在任意时刻中断程序，修改代码与内存，也就是我们所说的 mate 攻击模型，然后是代码混淆的应用非常广泛，基本可以分为两类，一类应用于恶意软件，比如对蠕虫木马使用混淆加密，增加安全分析师的分析难度，一类应用于数字版权保护，就是对商业软件的关键代码进行保护。以使其免受于剽窃等非法攻击。这方面常见的解决方案有 vmp、tmd、ollvm。

研究现状  

=======

接着是研究现状，也就是产业界与学术界的研究现状。  

产业界可能比较关注的就是混淆逻辑门，属于数据流混淆中的一大类，已经被广泛使用的逻辑门有 VMP 外用门，还有最近被提出的量子逻辑门以及三输入门。

我们想问一个问题：**这些混淆他们是足够安全的吗？**

我们使用 VMP 万用门中的 Nand 门实现了 AND、XOR 以及 SUB 运算。使用 clang 编译开启 - O3 优化，编译得到的 BIN 中复杂的逻辑运算全部被化简了。

然后我们来考察量子逻辑门的安全性。实际上量子逻辑门基本等价于三输入门，考察它基本上也就是考察三输入门的安全性，我们依次使用量子门与三输入门实现了减法运算，开启编译优化后复杂的逻辑运算仍然被化简成了可读的形式。然后我们讨论为什么这种逻辑门的数据流混淆是不安全的，首先是比较一下三输入门与二输入门。

我们看 AOI 门为例，AOI 接受三个输入，当接受 a,b, -1 三个输入时，其输出结果等于 Nor(a, b) 然后我们注意到有 b & -1 = b 这个式子，我们把它带进去就能把它化简得到 Nor(a,b)，就是二输入门，这只需要使用基础的离散数学知识就能做到，也就是说从内联代码的角度来看，三输入门等价于二输入门，当然不是说三输入门完全等价于二输入门，而是在我们代码混淆的语境下来看，同时因布尔代数已经是非常成熟的话题了，有明确的运算规则可以用于化简二输入门。

右图是 LLVM 中 InstCombine 这一优化 pass 中的部分代码，即是这一个优化 pass，完成了逻辑门的化简功能。可以看到其中进行了很多模式匹配以进行化简工作。

![](https://bbs.pediy.com/upload/attach/202110/236762_WGWBSCAV7EWPQUT.jpg)

接着是控制流混淆中的不透明谓词，最常见的控制流混淆就是不透明谓词，谓词简单来说就是在原程序中某个位置插入一个 if 分支。

如图中所示就是原程序控制流与混淆后的控制流，这可以干扰攻击者对代码的分析，不透明谓词按其取值可以分为两种类型，一种是永远为真或者永远为假的不透明谓词，一种是可以为真或假的不透明谓词。

![](https://bbs.pediy.com/upload/attach/202110/236762_T7DWRSU8Y5B4YEV.jpg)

永真或者永假型的不透明谓词插入的后继基本块，也即是图中的基本块二与基本块三中必然有一个是永远不会被执行的，另一种就是可真可假型的不透明谓词，也就是说后面插入的两个基本块都有可能被执行，也正是因为这个原因，其插入的两个基本块他们的语义应该是相同的，但是可以对他们使用不同的混淆方案进行加密。以使攻击者第一时间无法判断出这两个基本块是同一个基本块，然后来混淆攻击者。

我们还要考量的问题仍然是他们的安全性问题， O-LLVM 中存在很多基于数论构造的不透明谓词，但是 angr，一个在 BIN 上进行动态符号执行的工具，检测出他们所需要的时间是极短的。

另一种方案是基于 API 来构造，比如 CreateFile API 接受错误的输入时它是永远返回 0 的，但是我们可以通过 HOOK API 或者拓展符号执行工具为 API 实现输入正确性检测，符号执行工具已经被广泛应用于反混淆，传统代码混淆方法正面临非常大的挑战，但是目前关于反符号执行的混淆的研究还是存在很多的不足，这也是我们的研究动机。

有研究测量了符号执行工具覆盖混淆后程序所有可能的执行路径所需时间并得出一个结论，除代码虚拟化以外的传统混淆技术，已然无法有效抵抗基于符号执行的反混淆手段，但是不管是学术界还是产业界，都有许多针对虚拟机的反混淆研究，比如 VTIL 它能完整还原 VMP 保护的程序。

作者还提出了第一个尝试，左侧是原程序，右侧是混淆后的程序，可以看见方案是在一个循环中插入分支，这即是尝试利用符号执行的路径爆炸问题构造混淆。路径爆炸问题，就是说符号执行的程序中可能执行路径非常多，导致无法处理。

比如说一个大程序的循环，这个循环可以执行一次两次或者很多很多次，这些都是可能的执行路径，然后循环内有条件分支语句，条件分支中执行某一侧的分支是不可确定的，这又极大增加了可能的执行路径，这种可能执行路径的增加是指数形式的。

作者后来又提出了一种新的混淆方案，基本思想是在程序中插入 for 循环。其循环次数，依次与一个整形变量中的字节相关联，从而导致其可能执行路径产生了激增。以 4 个 for 循环为例，其所有可能执行路径应该是 256×256×256×256，也就是 2 的 32 次方。

接着我们讨论一下：**这两种混淆方案为什么是安全的?**

作者将符号执行的攻击场景分为两类，一种是覆盖程序的所有可能执行路径，一种是试图寻找到能触发程序特定行为的输入值，range divider 只能对覆盖执行路径场景产生作用，因为其在循环中引入的 if 分支两侧基本块语义都是相等的，因为插入的 if 分支可以看成是可真可假的不透不透明，也即是说探索了一条分支，就等于探索了两条分支，在整个循环中探索了一条执行路径，就等于探索了所有执行路径。for 循环对两者都适用。

以 dfs 寻路（深度优先搜索寻路）说明问题，每一次符号执行工具无法到达某一基本块时，只能选择向上回溯一次，试图在离他最近的 for 循环中多循环一次，依次取尽所有可能执行路径。

还有研究是基于哈希函数加密跳转条件。有研究基于哈希函数提出了一种加密分支条件的混淆方案，其存在的问题是引入的 MD5 与 SHA256 等哈希函数带来的时间过开销都过高了，左侧是原程序，if 分支中将变量 x 与一个常数 c 比较，右侧是混淆后的程序，对等式两侧都应用哈希加密，同时使用常量 c 加密了后继基本块中的机器码，只有 if 分支成立时才进行解密，由于基本块中的机器码被加密了，故而攻击者没找到正确的输入 x 之前是无法进行进一步分析的。

然后是上一种方法存在的问题，就是哈希函数的时间开销过大，有研究基于 3x+1 猜想，构造了一种基于路径爆炸的混淆方法。

![](https://bbs.pediy.com/upload/attach/202110/236762_FZXMPEVKNWA2BTH.jpg)

3x+1 猜想指的是对任意一个正整数，如果其是偶数则除以 2，如果其是奇数则乘以 3 再加 1，如此迭代若干次后其一定能收敛回定值 1. 左侧是原程序，右侧是混淆后的代码，可以看到原来 x=30 这一条件表达式被替换为 x - y>28 且 x + y < 32，这一组不等式在 x, y 都为正整数的情况下，是只有 x = 30 与 y = 1 这一组解的，注意到 3x+1 猜想，其性质正是其最终能收敛到 1。

while 循环的前半部分就是实现了 3x+1 猜想的迭代过程，但是其存在的问题就是具有类似性质的数学猜想的个数是有限的，因而很容易被攻击者使用模式匹配攻击。

研究动机
----

然后是我们的研究动机，也就是目前已有研究存在的不足。

首先是我们希望改进 for 混淆，我们测量了 angr 求解 k=2，也就是有两个 for 循环的那种混淆方法中，每增加一条 deadended 路径所需要的时间。

![](https://bbs.pediy.com/upload/attach/202110/236762_AES32DJUSR55WA3.jpg)

从左图中可以看到，大部分路径求解所需时间都在 0.1 秒到 0.3 秒，相当一部分路径所需时间在 0.02 秒左右，for 循环可以显著增加可能的执行路径数，然而求解每一条增加的路径所需时间都是极少的。我们的改进思路就是增加求解每一条路径所需的时间，显然，求解所需总时间等于每条路径所需时间的总和，for 混淆只考虑了路径总数，然后我们引入对求解一条路径一条路径所需时间的考量。

然后是系统化关于 3x+1 混淆的研究，我们试图系统化关于 3x+1 混淆的研究，也即寻找一种构造这一类混淆的框架。过去的研究都表明 3x+1 混淆能有效抵抗符号执行工具的路径探索，然而问题就是具有类似数学性类似性质的数学猜想只有数个，同时猜想迭代回 1 的循环次数也是比较高的，引入的时间开销也比较多。

然后是减小哈希函数混淆方法带来的时间开销，过去的研究都表明这种方法是有效的，但是直接应用哈希函数的方法过于粗糙。

比如说 MD5、SHA56 等哈希算法，它们的输入都是以块为单位的，一般 512 位为一个快，但是一般而言我们要加密的常数 c 不过是 8 字节大小，使用哈希算法就引入了许多不必要的开销。我们的改进方案就是使用密码学原语构造输入是 int 与 int64 类型上的单射函数，然后使用单射函数来替换希函数，高强度的密码学算法往往考虑了各种攻击手段，然而混淆语境中我们要考虑的性质只有一点，那就是约束求解器难以处理他们。

提出若干新的混淆方法
==========

然后就是方法，也就是我们提出的若干新的混淆方法。

![](https://bbs.pediy.com/upload/attach/202110/236762_ZEWSVAUJKSKY7GE.jpg)![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

首先是对 3x+1 猜想的深入研究，我们使用 angr 对编译后的 BIN 进行分析，左图显示的就是随着分析的推进，每 fork 一条新路径所需的时间，左图中有三处低峰，第一处是刚开始分析时，而随着 fork 路径数的增加，也就是说沿着这条路收集到的路径约束越来越多，约束越来越复杂，fork 新路径所需的时间也增加了。

这张图能给我们的启发有两点：

1) 简单的分段函数，经过 n 次迭代后可能也能让约束求解器难以处理，3x+1 猜想就可以看成是简单的分段函数，然后随着 fork 路径的增加，就说明这个循环迭代的次数增加了，也就是说不断的在复合使用 3x+1 这一简单的复合函数。

2) x 除以 2 的值可能是偶数，也可能是基数，这就是产生了路径爆炸。当然使用程序语言实现分段函数的时候，是肯定会引入分支的，关键是避免一些无效分支的产生，比如当 x 是奇数时，3x+1 就一定是偶数，这就是我们后面要提到的受循环次数影响的无效分支，这种分支不会对混淆的效果产生加强影响，路径爆炸产生了更多执行路径，增加了路径总数，约束求解器难以处理复合使用单射函数的情况，也既是也就是增加了单条路径的求解时间，然后总的来看就是显著增加了符号执行工具求解所需要的总时间。

然后我们先定义一些概念。

首先我们要明确一个概念，构造类似 3x+1 混淆的时候，循环体内的路径分支不是越多越好，有两类分支就是无效的分支，一类是可真可假型的不透明谓词，理由我们已经说过了，分支两侧语义相等，执行了一条就等价于执行了所有条；另一类是分支条件受循环次数影响的分支，比如一个分支某次循环成立，它下一次循环就一定不成立了。一个很显然的事实就是符号执行工具找到输入 x 的概率 P 是 n 的 m 方的倒数，m 为输入值为 x 时循环执行次数，n 为循环体内有效分支的分支总数，实际上这个定义还是保守了一些，因为循环的最大可执行次数可能超过 m，其引入的路径总数远不止 n 的 m 方。

![](https://bbs.pediy.com/upload/attach/202110/236762_J3HXC3PPBQCMJHK.jpg)

基于这些我们构造了一种变量递减型的路径混淆，可以看到 LOOP == 27 这一个条件被替换成了 f(u) + LOOP == 31，循环过程中，f(u)的取值范围是 4 或者大于 32 的正整数值，故而能令其成立的情况只有 LOOP == 27，函数 f 在左下角显示，其中 0x1C71C71C 这一常数是 2^64 / 9 的近似值，故而 f(u)近似于 u / 9。我们在 while 循环中使用了一些技巧，使得 f(u)的值略过了 (4, 32] 这个区间，这个技巧在第 2 与第 3 个 else if 分支中可以看见，当 u 的值下降到一定程度后，直接对其赋一个值使 f(u)掠过 (4, 32] 这个区间，注意到我们程序中进行了对 u % 4 取值的判断。

这与我们之前提到了两个启发对应，第一是复合使用简单分段函数能让约束求解器难以处理。第二是产生了路径爆炸，因为 f(u) 或者 u×3/4 的值可能能被 4 整除，也可能不能被 4 整除。我们测试结果是 angr 无法在 5 小时内返回正确输入，还要注意一点的是 f(u) + LOOP == 31 这条判断语句，这有可能会产生溢出导致意外输入也能触发分支。最保险的办法，还是把它们转换成 64 位的整数，然后再相加判断，以避免产生溢出情况。

接下来我们要介绍符号执行目前面临的一个难题叫符号内存选址，一般来说如果一条指令其访问的目标内存地址的表达式中包含符号值，就产生了符号寻址难题，比如这条给出的对 global 变量访问的代码，因为 a 是符号值，所以访问的目标内存表达式里面就有符号值。与难题关联的就是符号内存模型，符号内存模型是符号执行工具对内存的建模，不同符号内存模型处理符号内存寻址问题的能力大不相同。

目前而言符号内存模型主要有 4 种，单一对象模型、分叉模型、聚合模型以及平坦内存模型。我们主要关注聚合模型，因为现代化的符号执行工具一般采用这一内存模型，聚合模型简单来说就是首先得到符号内存地址的所有可能取值情况，然后为每个取值情况与其对应的内存值对应起来，接着使用约束求解器中的 ite 让它们组合成约束，在 z3py 这里面就是使用了 If 函数。

还有一个符号执行工具叫 KLEE，KLEE 的实现与 Angr 有一些不同，我们后来又针对 KLEE 做了很多工作，对这个工作有兴趣的可以联系我们。

接下来我们要介绍一种混淆方法叫**去符号化**，就是在代码中插入一个小片段，就能显著延长符号执行工具求解所需的时间，以这段代码为例，table 中的元素是按 0,1, 2~255 递增排列的，也就是说 ch1 = table6[ch1]，这条代码实际上不会改变 ch1 的真实值，但是当时会引入一次符号内存寻址问题。我们以一个不透明位谓词例，x 是 int 类型的变量，我们对其中的每一个字节进行一次去符号化操作，去符号化前 Angr 检测出不透明谓词的时间小于一秒，插入后 Angr 检测出这个谓词所需时间为 62 秒。我们前面提到 for 混淆只考虑了增加路径总数，我们现在引入对增加每一条路径求解所需时间的考察。

接下来我们来谈谈**去符号内存混淆的强度来源****。**它的强度来源分为两个部分，一是 Angr 模拟设涉及符号内存问题的指令所需要的时间，涉及到 Angr 与它的符号内存模块的交互以及产生路径约束的过程。二是约束求解器求解所需的时间。插入去符号化代码后，Angr 生成的约束如下图所示，可以看到每一个 if 对应一种取值情况，生成的约束表达式 "大约等价于" 让符号求解器暴力遍历每一种取值情况，这就是我们说的去符号化的含义。

![](https://bbs.pediy.com/upload/attach/202110/236762_EGSSBD6HNEKE6KM.jpg)

然后是改进哈希混淆。密码学原语指的是密码中的基础组件，它们被以恰当的方式组合，形成一个高强度的加密系统。我们将要介绍的密码学原语都可以看成是一个单射函数，单射函数具有的数学性质，让它可以替换用在哈希混淆中的哈希算法，我们要做的就是构造让约束求解器难以处理的单射函数，但是有一些密码学原语它涉及到了符号内存寻址问题，比如 AES 的 S-BOX 置换，还有路径爆炸，比如说在 feistel 网络中存在 if 分支。

使用它们的时候，我们不知道我们构造的混淆的强度到到底是来源于这些符号内存难题，路径爆炸难题，还是来源于我们构造的单射函数上约束求解器难以处理，故而我们接下来要用到的原语都不涉及到这些难题。

我们对 feistel 网络做了一些修改，取其 1 轮形成 feistel 的函数，它的输入是 I, R，可以把一个 int 类型拆成左右两个部分作为输入传入，其中可以被替换的部分是 G，这可以是任意一个单射函数，只要不是 f(x) = x 这一特殊映射就好。还有仿射变换，数据依赖的循环移位，异或移位，这些都是对称密码中的基础组件。数据上扩展是把 n 字节扩展到 m 字节，m 大于 n。很多哈希算法在初始化时都会先扩展一遍输入。

然后是 feistel 函数的单射性证明，证明是不难的。  

过程中我们主要运用到了异或运算的一个性质，也就是说假如有 a1，a2，同时 a1 不等于 a2，那么一定有 a1 ^ b != a2 ^ b。也就是说我们可以把异或运算重新定义为其他运算，只要运算满足这个性质就行了，生成的函数仍然是单射的，我们称这些生成的函数为类 feistel 的函数。我们引入一种类 feistel 函数，异或运算被重新定义为这个形式了（f(a) ^ g(b)），f，g 均为单数函数，很显然这个函数具有我们刚刚提到的性质。

然后就是构造单射函数的一个例子，data 变量是 int 类型，我们先用数据扩展把它扩展到 8 字节，然后取其高低两部分输入类 feistel 函数，进行 4 轮类 feistel 函数加密，其中每进行完一轮类 feistel 函数加密后，再进行一仿射变化与数据依赖的循环移位。类 feistel 函数中的异或运算被重新定义为 f(a)^g(b) 的形式。f 是仿射变换，g 是异或移位。这个单射函数的强度是很高的，我们使用 angr 求解触发输入，设定超时限制为 6 小时，angr 不能输出结果，angr 使用的求解器是 z3，还有很多其他的求解器，比如 klee 用的 stp。

不同求解器的效果不同，当然我们还可以继续加强单射函数，比如说我们这个例子中，类 feistel 函数只进行了 4 轮，我们可以把它改成 8 轮，同时每进行完一次类 feistel 函数后，我们的加密只进行了一次仿射变换与循环移位，可以再重复一次进行两次仿射变换与循环移位。构造类似单设函数的技巧就是最好引入类 feistel 函数，同时先做数据向扩展输入，输入类 feistel 函数的 I, R 的长度最好都是 int，也就是 4 字节大小的。

现在我们讨论如何结合符号内存寻址难题，改进 for 混淆。输入 data 是 4 字节大小的，我们首先对它进行一次去符号化，就是我们对 data 进行数据扩展，注意扩展过程中我们引入了很多分支，这是为了产生路径爆炸，增加路径总数，扩展完成后，我们再进行一次去符号化，使用 Angr 对此进行求解。设置超时时间为 2 小时，Angr 无法返回能触发该分支的输入值。Angr 求解 1 条路径所需的时间大约为 400 秒，这有 4 的 4 次方条路径总数，极端复杂情况就是 Angr 最后才找到这条正确的路径，差不多需要 28.4 个小时，极端简单情况就是 Angr 第一次就找到了，那就只需要 400 秒，取折中认为搜索了一半找到可能是比较合理的，那就是 14.2 个小时。

实验验证
====

然后我们的实验环节，也就是与目前现有的研究进行对比。

首先是我们考量 Dec 混淆，我们测量了 Dec 混淆的 fork 新路径所需要的时间，可以看到它的峰值更高，同时更快出现峰值。峰值登高说明约束求解器求解所需时间更长，更快出现峰值，说明我们使用的分段函数经过更少的迭代值就能挫败约束求解器。

![](https://bbs.pediy.com/upload/attach/202110/236762_J7U7GKNSN43JHES.jpg)

经过测试，我们暂时认为 3x+1 混淆与 Dec 混淆的保护强度不分上下，因为符号执行工具都无法在很长的一段时间内返回结果。接着我们比较插入这些混淆所带来的运行开销与空间开销。首先我们比较 Dec 混淆与 3x+1 混淆收敛到定值所需的平均迭代次数，示例中的 Dec 混淆收敛到 4，3x+1 混淆收敛到 1。在一个很大的数据范围内，Dec 混淆平均 24 次，3x+1 混淆平均 152 次，Dec 混淆胜出。

![](https://bbs.pediy.com/upload/attach/202110/236762_Y5EY4CMJXV2NK2H.jpg)

然后我们比较收敛到定值所需要的迭代次数一致时的情况，Dec 混淆它执行所需时间为 14 秒，这个是执行了很多次的结果，3x+1 混淆它是 6 秒，也就是说当迭代次数一致的时候，Dec 混淆的耗时是 3x+1 混淆的 2 倍左右。但是 Dec 混淆收敛到定值所需要的迭代次数平均下来看是 3s+1 混淆的 1/6，故而一般情况来看，Dec 混淆的时间开销是远小于 3x+1 混淆的。

从空间开销来看，3x+1 混淆好于 Dec 混淆。但是一般可执行文件中都存在着很多为了对齐而尚未使用的空间，故而我们认为严格讨论空间开销是没有非常大的意义的。

![](https://bbs.pediy.com/upload/attach/202110/236762_NJBN3S24JGQBTG7.jpg)

然后是结合去符号化与数据扩展的那个混淆方法与 for 混淆对比，只有当插入两个 for 循环时， for 混淆才开始产生作用，而且使用一小时作为超时时间，15 个程序中只有一个超时不能返回结果，我们就使用这个 k = 2 的情况与去符号化对比，我们取平均情况认为 2 个 for 循环每个执行 128 次，此时 for 混淆的时间开销大约是去符号化的是 17 倍。

![](https://bbs.pediy.com/upload/attach/202110/236762_HNAH6JXP6A9FDVH.jpg)

同时我们认为可以单独使用去符号化，我们将去符号化片段插入了程序，试图加强不透明谓词的强度。从第一个表格中我们可以发现符号变量个数的增加带来的时间增增长是线性的，但如果各符号变量之间并不是独立的，而是互相存在约束关系的，那么带来的时间增长就是指数形式的，第二个表格就显示了我们在符号变量之间建立的约束关系，以及求解时间的变化。

回顾一下我们的贡献，我们研究了现有的反符号执行的混淆方法，基于路径爆炸与复杂约束这两类符号执行面临的挑战性问题提出了两种构造框架，使用这两种框架，软件开发者能简单构造出可以挫败基于符号执行的反混淆攻击手段的混淆方法，还提出了一种去符号化代码片段，插入任意位置就可以显著增加求解所需时间，可以将其与现有的不透明谓词结合使用，它能极大加强不透明位次的强度，同时他们引入的时间开销都远好于现有的研究，我的报告就到这里结束了，谢谢大家。

我们之后会将我们的工作投稿到网安学术界的会议，欢迎继续关注我们的工作，同时我们在研究过程中得到了复旦大学徐辉老师，还有 VXProtect 研究团队的赵川老师的许多帮助，在此一并表示感谢，谢谢大家。

同态加密 & 混淆电路
===========

先生们，女士们，大家好，我是西安交通大学的南子龙，刚才程瑞老师已经讲完了我们关于基于反符号执行的代码混淆方法，接下来我给大家介绍一下我们**通过安全计算实现代码保护的一些想法。**

就如 ppt 所说的，多方计算指在无可信第三方情况下，通过多方共同参与，安全地完成某种协同计算，首先安全计算分为基于噪声和不基于噪声，而**我们的研究主要通过混淆电路和同态加密来实行。**

**首先是混淆电路，**这是源于多年前姚院士提出的百万富翁问题。百万富翁问题想必大家都听说过，就是两个百万富翁想在不暴露自身财富的情况下比较谁更富有。而他的解决办法已经在屏幕上展示了，经过两次消息传递，就可以得出比较的结果，就不过多赘述了。而这个过程用密码学的语言可以这样表示，由 A 选取公钥，B 选取大数 来保证双方不知道彼此的财产。

由此我们可以看出，混淆电路的流程可以分为这样几步，A 生成混淆电路 A 与 B 进行通信 B 再计算所生成的电路 最后分享结果。下来就是混淆电路的搭建了，通过如下电路，三个异或门和一个与门，再由 A 对每一个模块进行 0、1 的替换，在完成替换后进行加密，生成真值表，在最后打乱。这样就实现一个混淆电路。

![](https://bbs.pediy.com/upload/attach/202110/236762_D6XVGY6CXX2EFTZ.jpg)

大家很容易可以发现，这是一个三输入门，可以视为去年讲的量子逻辑门的一种推广，而前面程瑞老师也提到过，量子逻辑门还是存在一定的安全问题，但混淆逻辑门很难用布尔代数的内容化简逻辑表达式，所以在前面程老师提到的方法下是安全的。

但想必大家也能感觉到，混淆逻辑门运行的流程是较为复杂的，在代码保护的其他流程中，可能出现安全问题，然后最简单粗暴的解决办法就是在电路层面解决这些问题，即将上述流程进行封装，而这个也限制了该方法在实际生产中的应用，我们目前也在寻找一个简单高效的利用方式。

而**第二种方式就是通过同态加密**，对于同态加密，大家应该已经有所耳闻了吧，就是一种可以直接在密文域实现运算的加密方式。我们的工作主要是利用 09 年克雷格 · 金特里论文中提出的全同态加密。

![](https://bbs.pediy.com/upload/attach/202110/236762_W862PPXMSFKRMVY.jpg)

如图所示，这就是两种最基本的同态加密，我们熟知的 RSA 就满足于其中的乘法同态，而全同态则是能同时满足这两种运算在基本逻辑门层面来说，乘加运算可以实现所有的运算，所以同时满足加法和乘法同态的加密算法被称为全同态。

所以同态加密可以不知道操作数的情况下进行运算的实现，所以我们想通过同态加密的方式来进行对代码中关键数据的保护。而我们设计的具体流程是这样的，这个的原理也很好理解，就是将 A 加密过后的 A’当做操作数，与 fx 中的参数进行计算，再进行一次加密，通过同态加密的性质，我们这样在加解密过程中不会出现太大的问题，但为了实现同态运算，我们这里需要选择统一的加密算法。

![](https://bbs.pediy.com/upload/attach/202110/236762_E9QDA7593XNK2X9.jpg)

而这就是我们设计的流程，对 A 和 f(x) 采用相同算法下不同 Enc 进行加密，之后再进行运算，最后对运算结果进行解密 。

![](https://bbs.pediy.com/upload/attach/202110/236762_EZ4MUG3Z4J4N64B.jpg)

而这样的一个流程构建完成之后，我们可以看到，它可以实现如图所示的效果。蓝色部分是用户得到的，绿色部分是提供在程序里，而其余部分即我们想要保护的 f(x) 即加密他的 ENC 函数则会在程序设计完成后删除, 达到了我们对目标函数 保护的目的。

同样的，全同态加密的开销是不小的，我在算法设计初期，曾使用该方案进行了一次 AES 运算，花了将近一天时间，而且随运算数的增大，开销是成指数性增长的，对此我们有两种解决方案，其一是分段加密解密，甚至对于基本逻辑门进行加密，但这样必然会损失一定的安全性，其二是对算法进行改进，我们正在研究，如何构建一个高效的一个 Dec 对应两个 Enc 的函数生成方法，这样既提高了安全性，也能进行一个适当的加速。比如说构造更加良好的 Enc1、Enc2、Dec3 的秘钥对，使得 Enc1、Enc2 具有一定联系，并使得 Dec3 进一步简化，也保障安全性 。

好的，我们的报告就差不多到此结束了，最后我想以我们老学长，道哥的一句话作为结尾，就是构建更安全的互联网。

[[培训] 优秀毕业生寄语：恭喜 id 咸鱼炒白菜拿到远超 3W 月薪的 offer，《安卓高级研修班》火热招生！！！](https://zhuanlan.kanxue.com/article-16096.htm)

最后于 2 小时前 被 kanxue 编辑 ，原因：

上传的附件：

*   [程瑞、南子龙 - 代码混淆研究的新方向. rar](javascript:void(0)) （4.38MB，93 次下载）